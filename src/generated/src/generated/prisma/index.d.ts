
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CategoryList
 * 
 */
export type CategoryList = $Result.DefaultSelection<Prisma.$CategoryListPayload>
/**
 * Model FileList
 * 
 */
export type FileList = $Result.DefaultSelection<Prisma.$FileListPayload>
/**
 * Model DocumentPage
 * Stores visual snapshots of document pages
 */
export type DocumentPage = $Result.DefaultSelection<Prisma.$DocumentPagePayload>
/**
 * Model FileChunk
 * Stores granular text chunks with layout coordinates
 */
export type FileChunk = $Result.DefaultSelection<Prisma.$FileChunkPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model UserEnrollment
 * 
 */
export type UserEnrollment = $Result.DefaultSelection<Prisma.$UserEnrollmentPayload>
/**
 * Model Conversation
 * Stores conversation sessions for chat history
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationMessage
 * Stores individual messages within conversations
 */
export type ConversationMessage = $Result.DefaultSelection<Prisma.$ConversationMessagePayload>
/**
 * Model AiApiKey
 * Stores encrypted API keys and metadata for AI providers
 */
export type AiApiKey = $Result.DefaultSelection<Prisma.$AiApiKeyPayload>
/**
 * Model AiModel
 * Lists available models per provider, manageable by admin
 */
export type AiModel = $Result.DefaultSelection<Prisma.$AiModelPayload>
/**
 * Model app_settings
 * 
 */
export type app_settings = $Result.DefaultSelection<Prisma.$app_settingsPayload>
/**
 * Model SubscriptionPlan
 * Subscription plans available for users
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model UserSubscription
 * User subscription information
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model UsageTracking
 * Usage tracking for subscription limits
 */
export type UsageTracking = $Result.DefaultSelection<Prisma.$UsageTrackingPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model Institution
 * 
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model ChapterChunk
 * 
 */
export type ChapterChunk = $Result.DefaultSelection<Prisma.$ChapterChunkPayload>
/**
 * Model ChapterChunkBoard
 * 
 */
export type ChapterChunkBoard = $Result.DefaultSelection<Prisma.$ChapterChunkBoardPayload>
/**
 * Model ChapterPage
 * 
 */
export type ChapterPage = $Result.DefaultSelection<Prisma.$ChapterPagePayload>
/**
 * Model SystemSetting
 * System-wide settings for quiz configuration
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model Question
 * Question Bank Model - Stores pre-generated questions for chapters
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model UserPoints
 * 
 */
export type UserPoints = $Result.DefaultSelection<Prisma.$UserPointsPayload>
/**
 * Model StudyMaterial
 * 
 */
export type StudyMaterial = $Result.DefaultSelection<Prisma.$StudyMaterialPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model StreakBadge
 * 
 */
export type StreakBadge = $Result.DefaultSelection<Prisma.$StreakBadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model LearningSession
 * 
 */
export type LearningSession = $Result.DefaultSelection<Prisma.$LearningSessionPayload>
/**
 * Model Battle
 * 
 */
export type Battle = $Result.DefaultSelection<Prisma.$BattlePayload>
/**
 * Model BattleParticipant
 * 
 */
export type BattleParticipant = $Result.DefaultSelection<Prisma.$BattleParticipantPayload>
/**
 * Model Syllabus
 * 
 */
export type Syllabus = $Result.DefaultSelection<Prisma.$SyllabusPayload>
/**
 * Model SyllabusUnit
 * 
 */
export type SyllabusUnit = $Result.DefaultSelection<Prisma.$SyllabusUnitPayload>
/**
 * Model SyllabusChapter
 * 
 */
export type SyllabusChapter = $Result.DefaultSelection<Prisma.$SyllabusChapterPayload>
/**
 * Model Textbook
 * Represents a complete textbook project
 */
export type Textbook = $Result.DefaultSelection<Prisma.$TextbookPayload>
/**
 * Model TextbookUnit
 * Represents a unit/part within a textbook
 */
export type TextbookUnit = $Result.DefaultSelection<Prisma.$TextbookUnitPayload>
/**
 * Model TextbookChapter
 * Represents a chapter within a unit
 */
export type TextbookChapter = $Result.DefaultSelection<Prisma.$TextbookChapterPayload>
/**
 * Model TextbookImage
 * Stores generated images/diagrams for chapters
 */
export type TextbookImage = $Result.DefaultSelection<Prisma.$TextbookImagePayload>
/**
 * Model TextbookGenerationJob
 * Tracks generation jobs for async processing
 */
export type TextbookGenerationJob = $Result.DefaultSelection<Prisma.$TextbookGenerationJobPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ChapterStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ChapterStatus = (typeof ChapterStatus)[keyof typeof ChapterStatus]


export const MessageRole: {
  user: 'user',
  assistant: 'assistant'
};

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]


export const UserRole: {
  admin: 'admin',
  institution: 'institution',
  student: 'student'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SubscriptionStatus: {
  active: 'active',
  canceled: 'canceled',
  past_due: 'past_due',
  trialing: 'trialing',
  incomplete: 'incomplete',
  incomplete_expired: 'incomplete_expired'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const BillingCycle: {
  monthly: 'monthly',
  yearly: 'yearly'
};

export type BillingCycle = (typeof BillingCycle)[keyof typeof BillingCycle]


export const UsageType: {
  file_upload: 'file_upload',
  chat_message: 'chat_message',
  document_export: 'document_export',
  ai_processing: 'ai_processing',
  quiz_generation: 'quiz_generation',
  battle_match: 'battle_match',
  ai_tutor_session: 'ai_tutor_session'
};

export type UsageType = (typeof UsageType)[keyof typeof UsageType]


export const Provider: {
  gemini: 'gemini',
  openai: 'openai',
  anthropic: 'anthropic',
  llamaparse: 'llamaparse',
  openrouter: 'openrouter'
};

export type Provider = (typeof Provider)[keyof typeof Provider]


export const QuestionType: {
  MCQ: 'MCQ',
  TRUE_FALSE: 'TRUE_FALSE',
  FILL_IN_BLANK: 'FILL_IN_BLANK',
  SHORT_ANSWER: 'SHORT_ANSWER',
  LONG_ANSWER: 'LONG_ANSWER'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const QuizStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED'
};

export type QuizStatus = (typeof QuizStatus)[keyof typeof QuizStatus]


export const BattleStatus: {
  WAITING: 'WAITING',
  STARTING: 'STARTING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED',
  EXPIRED: 'EXPIRED'
};

export type BattleStatus = (typeof BattleStatus)[keyof typeof BattleStatus]


export const SyllabusStatus: {
  DRAFT: 'DRAFT',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  ARCHIVED: 'ARCHIVED'
};

export type SyllabusStatus = (typeof SyllabusStatus)[keyof typeof SyllabusStatus]


export const TextbookStatus: {
  DRAFT: 'DRAFT',
  PARSING: 'PARSING',
  GENERATING: 'GENERATING',
  REVIEWING: 'REVIEWING',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type TextbookStatus = (typeof TextbookStatus)[keyof typeof TextbookStatus]


export const ChapterGenStatus: {
  PENDING: 'PENDING',
  GENERATING: 'GENERATING',
  GENERATED: 'GENERATED',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REVIEWED: 'REVIEWED'
};

export type ChapterGenStatus = (typeof ChapterGenStatus)[keyof typeof ChapterGenStatus]


export const ImageGenStatus: {
  PENDING: 'PENDING',
  GENERATING: 'GENERATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ImageGenStatus = (typeof ImageGenStatus)[keyof typeof ImageGenStatus]


export const TextbookImageType: {
  DIAGRAM: 'DIAGRAM',
  FLOWCHART: 'FLOWCHART',
  CHART: 'CHART',
  GRAPH: 'GRAPH',
  ILLUSTRATION: 'ILLUSTRATION',
  INFOGRAPHIC: 'INFOGRAPHIC',
  MINDMAP: 'MINDMAP',
  MOLECULAR: 'MOLECULAR',
  ANATOMICAL: 'ANATOMICAL',
  EXPERIMENTAL: 'EXPERIMENTAL',
  GEOMETRIC: 'GEOMETRIC',
  TIMELINE: 'TIMELINE',
  COMPARISON: 'COMPARISON',
  MAP: 'MAP',
  COVER: 'COVER',
  ANATOMY: 'ANATOMY',
  CIRCUIT: 'CIRCUIT',
  PHOTO: 'PHOTO',
  ICON: 'ICON'
};

export type TextbookImageType = (typeof TextbookImageType)[keyof typeof TextbookImageType]


export const TextbookGenerationJobType: {
  PARSE_SYLLABUS: 'PARSE_SYLLABUS',
  GENERATE_CHAPTER: 'GENERATE_CHAPTER',
  GENERATE_QUESTIONS: 'GENERATE_QUESTIONS',
  GENERATE_IMAGE: 'GENERATE_IMAGE',
  COMPILE_PDF: 'COMPILE_PDF',
  FULL_TEXTBOOK: 'FULL_TEXTBOOK'
};

export type TextbookGenerationJobType = (typeof TextbookGenerationJobType)[keyof typeof TextbookGenerationJobType]


export const TextbookJobStatus: {
  QUEUED: 'QUEUED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type TextbookJobStatus = (typeof TextbookJobStatus)[keyof typeof TextbookJobStatus]

}

export type ChapterStatus = $Enums.ChapterStatus

export const ChapterStatus: typeof $Enums.ChapterStatus

export type MessageRole = $Enums.MessageRole

export const MessageRole: typeof $Enums.MessageRole

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type BillingCycle = $Enums.BillingCycle

export const BillingCycle: typeof $Enums.BillingCycle

export type UsageType = $Enums.UsageType

export const UsageType: typeof $Enums.UsageType

export type Provider = $Enums.Provider

export const Provider: typeof $Enums.Provider

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type QuizStatus = $Enums.QuizStatus

export const QuizStatus: typeof $Enums.QuizStatus

export type BattleStatus = $Enums.BattleStatus

export const BattleStatus: typeof $Enums.BattleStatus

export type SyllabusStatus = $Enums.SyllabusStatus

export const SyllabusStatus: typeof $Enums.SyllabusStatus

export type TextbookStatus = $Enums.TextbookStatus

export const TextbookStatus: typeof $Enums.TextbookStatus

export type ChapterGenStatus = $Enums.ChapterGenStatus

export const ChapterGenStatus: typeof $Enums.ChapterGenStatus

export type ImageGenStatus = $Enums.ImageGenStatus

export const ImageGenStatus: typeof $Enums.ImageGenStatus

export type TextbookImageType = $Enums.TextbookImageType

export const TextbookImageType: typeof $Enums.TextbookImageType

export type TextbookGenerationJobType = $Enums.TextbookGenerationJobType

export const TextbookGenerationJobType: typeof $Enums.TextbookGenerationJobType

export type TextbookJobStatus = $Enums.TextbookJobStatus

export const TextbookJobStatus: typeof $Enums.TextbookJobStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CategoryLists
 * const categoryLists = await prisma.categoryList.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CategoryLists
   * const categoryLists = await prisma.categoryList.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.categoryList`: Exposes CRUD operations for the **CategoryList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryLists
    * const categoryLists = await prisma.categoryList.findMany()
    * ```
    */
  get categoryList(): Prisma.CategoryListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileList`: Exposes CRUD operations for the **FileList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileLists
    * const fileLists = await prisma.fileList.findMany()
    * ```
    */
  get fileList(): Prisma.FileListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentPage`: Exposes CRUD operations for the **DocumentPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentPages
    * const documentPages = await prisma.documentPage.findMany()
    * ```
    */
  get documentPage(): Prisma.DocumentPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileChunk`: Exposes CRUD operations for the **FileChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileChunks
    * const fileChunks = await prisma.fileChunk.findMany()
    * ```
    */
  get fileChunk(): Prisma.FileChunkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userEnrollment`: Exposes CRUD operations for the **UserEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEnrollments
    * const userEnrollments = await prisma.userEnrollment.findMany()
    * ```
    */
  get userEnrollment(): Prisma.UserEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationMessage`: Exposes CRUD operations for the **ConversationMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationMessages
    * const conversationMessages = await prisma.conversationMessage.findMany()
    * ```
    */
  get conversationMessage(): Prisma.ConversationMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiApiKey`: Exposes CRUD operations for the **AiApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiApiKeys
    * const aiApiKeys = await prisma.aiApiKey.findMany()
    * ```
    */
  get aiApiKey(): Prisma.AiApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiModel`: Exposes CRUD operations for the **AiModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiModels
    * const aiModels = await prisma.aiModel.findMany()
    * ```
    */
  get aiModel(): Prisma.AiModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.app_settings`: Exposes CRUD operations for the **app_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_settings
    * const app_settings = await prisma.app_settings.findMany()
    * ```
    */
  get app_settings(): Prisma.app_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageTracking`: Exposes CRUD operations for the **UsageTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageTrackings
    * const usageTrackings = await prisma.usageTracking.findMany()
    * ```
    */
  get usageTracking(): Prisma.UsageTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution`: Exposes CRUD operations for the **Institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.InstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapterChunk`: Exposes CRUD operations for the **ChapterChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterChunks
    * const chapterChunks = await prisma.chapterChunk.findMany()
    * ```
    */
  get chapterChunk(): Prisma.ChapterChunkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapterChunkBoard`: Exposes CRUD operations for the **ChapterChunkBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterChunkBoards
    * const chapterChunkBoards = await prisma.chapterChunkBoard.findMany()
    * ```
    */
  get chapterChunkBoard(): Prisma.ChapterChunkBoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapterPage`: Exposes CRUD operations for the **ChapterPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterPages
    * const chapterPages = await prisma.chapterPage.findMany()
    * ```
    */
  get chapterPage(): Prisma.ChapterPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPoints`: Exposes CRUD operations for the **UserPoints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPoints
    * const userPoints = await prisma.userPoints.findMany()
    * ```
    */
  get userPoints(): Prisma.UserPointsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studyMaterial`: Exposes CRUD operations for the **StudyMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyMaterials
    * const studyMaterials = await prisma.studyMaterial.findMany()
    * ```
    */
  get studyMaterial(): Prisma.StudyMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.streakBadge`: Exposes CRUD operations for the **StreakBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StreakBadges
    * const streakBadges = await prisma.streakBadge.findMany()
    * ```
    */
  get streakBadge(): Prisma.StreakBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningSession`: Exposes CRUD operations for the **LearningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningSessions
    * const learningSessions = await prisma.learningSession.findMany()
    * ```
    */
  get learningSession(): Prisma.LearningSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.battle`: Exposes CRUD operations for the **Battle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Battles
    * const battles = await prisma.battle.findMany()
    * ```
    */
  get battle(): Prisma.BattleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.battleParticipant`: Exposes CRUD operations for the **BattleParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BattleParticipants
    * const battleParticipants = await prisma.battleParticipant.findMany()
    * ```
    */
  get battleParticipant(): Prisma.BattleParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syllabus`: Exposes CRUD operations for the **Syllabus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Syllabi
    * const syllabi = await prisma.syllabus.findMany()
    * ```
    */
  get syllabus(): Prisma.SyllabusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syllabusUnit`: Exposes CRUD operations for the **SyllabusUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyllabusUnits
    * const syllabusUnits = await prisma.syllabusUnit.findMany()
    * ```
    */
  get syllabusUnit(): Prisma.SyllabusUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syllabusChapter`: Exposes CRUD operations for the **SyllabusChapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyllabusChapters
    * const syllabusChapters = await prisma.syllabusChapter.findMany()
    * ```
    */
  get syllabusChapter(): Prisma.SyllabusChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textbook`: Exposes CRUD operations for the **Textbook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Textbooks
    * const textbooks = await prisma.textbook.findMany()
    * ```
    */
  get textbook(): Prisma.TextbookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textbookUnit`: Exposes CRUD operations for the **TextbookUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextbookUnits
    * const textbookUnits = await prisma.textbookUnit.findMany()
    * ```
    */
  get textbookUnit(): Prisma.TextbookUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textbookChapter`: Exposes CRUD operations for the **TextbookChapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextbookChapters
    * const textbookChapters = await prisma.textbookChapter.findMany()
    * ```
    */
  get textbookChapter(): Prisma.TextbookChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textbookImage`: Exposes CRUD operations for the **TextbookImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextbookImages
    * const textbookImages = await prisma.textbookImage.findMany()
    * ```
    */
  get textbookImage(): Prisma.TextbookImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.textbookGenerationJob`: Exposes CRUD operations for the **TextbookGenerationJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextbookGenerationJobs
    * const textbookGenerationJobs = await prisma.textbookGenerationJob.findMany()
    * ```
    */
  get textbookGenerationJob(): Prisma.TextbookGenerationJobDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CategoryList: 'CategoryList',
    FileList: 'FileList',
    DocumentPage: 'DocumentPage',
    FileChunk: 'FileChunk',
    user: 'user',
    UserEnrollment: 'UserEnrollment',
    Conversation: 'Conversation',
    ConversationMessage: 'ConversationMessage',
    AiApiKey: 'AiApiKey',
    AiModel: 'AiModel',
    app_settings: 'app_settings',
    SubscriptionPlan: 'SubscriptionPlan',
    UserSubscription: 'UserSubscription',
    UsageTracking: 'UsageTracking',
    Country: 'Country',
    Board: 'Board',
    Institution: 'Institution',
    Program: 'Program',
    Profile: 'Profile',
    Subject: 'Subject',
    Chapter: 'Chapter',
    ChapterChunk: 'ChapterChunk',
    ChapterChunkBoard: 'ChapterChunkBoard',
    ChapterPage: 'ChapterPage',
    SystemSetting: 'SystemSetting',
    Quiz: 'Quiz',
    QuizQuestion: 'QuizQuestion',
    Question: 'Question',
    UserPoints: 'UserPoints',
    StudyMaterial: 'StudyMaterial',
    Exam: 'Exam',
    StreakBadge: 'StreakBadge',
    UserBadge: 'UserBadge',
    LearningSession: 'LearningSession',
    Battle: 'Battle',
    BattleParticipant: 'BattleParticipant',
    Syllabus: 'Syllabus',
    SyllabusUnit: 'SyllabusUnit',
    SyllabusChapter: 'SyllabusChapter',
    Textbook: 'Textbook',
    TextbookUnit: 'TextbookUnit',
    TextbookChapter: 'TextbookChapter',
    TextbookImage: 'TextbookImage',
    TextbookGenerationJob: 'TextbookGenerationJob'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "categoryList" | "fileList" | "documentPage" | "fileChunk" | "user" | "userEnrollment" | "conversation" | "conversationMessage" | "aiApiKey" | "aiModel" | "app_settings" | "subscriptionPlan" | "userSubscription" | "usageTracking" | "country" | "board" | "institution" | "program" | "profile" | "subject" | "chapter" | "chapterChunk" | "chapterChunkBoard" | "chapterPage" | "systemSetting" | "quiz" | "quizQuestion" | "question" | "userPoints" | "studyMaterial" | "exam" | "streakBadge" | "userBadge" | "learningSession" | "battle" | "battleParticipant" | "syllabus" | "syllabusUnit" | "syllabusChapter" | "textbook" | "textbookUnit" | "textbookChapter" | "textbookImage" | "textbookGenerationJob"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CategoryList: {
        payload: Prisma.$CategoryListPayload<ExtArgs>
        fields: Prisma.CategoryListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>
          }
          findFirst: {
            args: Prisma.CategoryListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>
          }
          findMany: {
            args: Prisma.CategoryListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>[]
          }
          create: {
            args: Prisma.CategoryListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>
          }
          createMany: {
            args: Prisma.CategoryListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>[]
          }
          delete: {
            args: Prisma.CategoryListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>
          }
          update: {
            args: Prisma.CategoryListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>
          }
          deleteMany: {
            args: Prisma.CategoryListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>[]
          }
          upsert: {
            args: Prisma.CategoryListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryListPayload>
          }
          aggregate: {
            args: Prisma.CategoryListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryList>
          }
          groupBy: {
            args: Prisma.CategoryListGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryListGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryListCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryListCountAggregateOutputType> | number
          }
        }
      }
      FileList: {
        payload: Prisma.$FileListPayload<ExtArgs>
        fields: Prisma.FileListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>
          }
          findFirst: {
            args: Prisma.FileListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>
          }
          findMany: {
            args: Prisma.FileListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>[]
          }
          create: {
            args: Prisma.FileListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>
          }
          createMany: {
            args: Prisma.FileListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>[]
          }
          delete: {
            args: Prisma.FileListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>
          }
          update: {
            args: Prisma.FileListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>
          }
          deleteMany: {
            args: Prisma.FileListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>[]
          }
          upsert: {
            args: Prisma.FileListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileListPayload>
          }
          aggregate: {
            args: Prisma.FileListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileList>
          }
          groupBy: {
            args: Prisma.FileListGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileListGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileListCountArgs<ExtArgs>
            result: $Utils.Optional<FileListCountAggregateOutputType> | number
          }
        }
      }
      DocumentPage: {
        payload: Prisma.$DocumentPagePayload<ExtArgs>
        fields: Prisma.DocumentPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          findFirst: {
            args: Prisma.DocumentPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          findMany: {
            args: Prisma.DocumentPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
          }
          create: {
            args: Prisma.DocumentPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          createMany: {
            args: Prisma.DocumentPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
          }
          delete: {
            args: Prisma.DocumentPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          update: {
            args: Prisma.DocumentPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          deleteMany: {
            args: Prisma.DocumentPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
          }
          upsert: {
            args: Prisma.DocumentPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          aggregate: {
            args: Prisma.DocumentPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentPage>
          }
          groupBy: {
            args: Prisma.DocumentPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentPageCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentPageCountAggregateOutputType> | number
          }
        }
      }
      FileChunk: {
        payload: Prisma.$FileChunkPayload<ExtArgs>
        fields: Prisma.FileChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>
          }
          findFirst: {
            args: Prisma.FileChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>
          }
          findMany: {
            args: Prisma.FileChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>[]
          }
          create: {
            args: Prisma.FileChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>
          }
          createMany: {
            args: Prisma.FileChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>[]
          }
          delete: {
            args: Prisma.FileChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>
          }
          update: {
            args: Prisma.FileChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>
          }
          deleteMany: {
            args: Prisma.FileChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileChunkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>[]
          }
          upsert: {
            args: Prisma.FileChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileChunkPayload>
          }
          aggregate: {
            args: Prisma.FileChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileChunk>
          }
          groupBy: {
            args: Prisma.FileChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileChunkCountArgs<ExtArgs>
            result: $Utils.Optional<FileChunkCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserEnrollment: {
        payload: Prisma.$UserEnrollmentPayload<ExtArgs>
        fields: Prisma.UserEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.UserEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>
          }
          findMany: {
            args: Prisma.UserEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>[]
          }
          create: {
            args: Prisma.UserEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>
          }
          createMany: {
            args: Prisma.UserEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.UserEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>
          }
          update: {
            args: Prisma.UserEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.UserEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.UserEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.UserEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEnrollment>
          }
          groupBy: {
            args: Prisma.UserEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<UserEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationMessage: {
        payload: Prisma.$ConversationMessagePayload<ExtArgs>
        fields: Prisma.ConversationMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          findFirst: {
            args: Prisma.ConversationMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          findMany: {
            args: Prisma.ConversationMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          create: {
            args: Prisma.ConversationMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          createMany: {
            args: Prisma.ConversationMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          delete: {
            args: Prisma.ConversationMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          update: {
            args: Prisma.ConversationMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          deleteMany: {
            args: Prisma.ConversationMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          upsert: {
            args: Prisma.ConversationMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          aggregate: {
            args: Prisma.ConversationMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationMessage>
          }
          groupBy: {
            args: Prisma.ConversationMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationMessageCountAggregateOutputType> | number
          }
        }
      }
      AiApiKey: {
        payload: Prisma.$AiApiKeyPayload<ExtArgs>
        fields: Prisma.AiApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>
          }
          findFirst: {
            args: Prisma.AiApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>
          }
          findMany: {
            args: Prisma.AiApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>[]
          }
          create: {
            args: Prisma.AiApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>
          }
          createMany: {
            args: Prisma.AiApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>[]
          }
          delete: {
            args: Prisma.AiApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>
          }
          update: {
            args: Prisma.AiApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.AiApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.AiApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiApiKeyPayload>
          }
          aggregate: {
            args: Prisma.AiApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiApiKey>
          }
          groupBy: {
            args: Prisma.AiApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<AiApiKeyCountAggregateOutputType> | number
          }
        }
      }
      AiModel: {
        payload: Prisma.$AiModelPayload<ExtArgs>
        fields: Prisma.AiModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>
          }
          findFirst: {
            args: Prisma.AiModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>
          }
          findMany: {
            args: Prisma.AiModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>[]
          }
          create: {
            args: Prisma.AiModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>
          }
          createMany: {
            args: Prisma.AiModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>[]
          }
          delete: {
            args: Prisma.AiModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>
          }
          update: {
            args: Prisma.AiModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>
          }
          deleteMany: {
            args: Prisma.AiModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>[]
          }
          upsert: {
            args: Prisma.AiModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>
          }
          aggregate: {
            args: Prisma.AiModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiModel>
          }
          groupBy: {
            args: Prisma.AiModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiModelCountArgs<ExtArgs>
            result: $Utils.Optional<AiModelCountAggregateOutputType> | number
          }
        }
      }
      app_settings: {
        payload: Prisma.$app_settingsPayload<ExtArgs>
        fields: Prisma.app_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>
          }
          findFirst: {
            args: Prisma.app_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>
          }
          findMany: {
            args: Prisma.app_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>[]
          }
          create: {
            args: Prisma.app_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>
          }
          createMany: {
            args: Prisma.app_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>[]
          }
          delete: {
            args: Prisma.app_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>
          }
          update: {
            args: Prisma.app_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>
          }
          deleteMany: {
            args: Prisma.app_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.app_settingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>[]
          }
          upsert: {
            args: Prisma.app_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_settingsPayload>
          }
          aggregate: {
            args: Prisma.App_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_settings>
          }
          groupBy: {
            args: Prisma.app_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<App_settingsCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UsageTracking: {
        payload: Prisma.$UsageTrackingPayload<ExtArgs>
        fields: Prisma.UsageTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          findFirst: {
            args: Prisma.UsageTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          findMany: {
            args: Prisma.UsageTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          create: {
            args: Prisma.UsageTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          createMany: {
            args: Prisma.UsageTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          delete: {
            args: Prisma.UsageTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          update: {
            args: Prisma.UsageTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          deleteMany: {
            args: Prisma.UsageTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>[]
          }
          upsert: {
            args: Prisma.UsageTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageTrackingPayload>
          }
          aggregate: {
            args: Prisma.UsageTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageTracking>
          }
          groupBy: {
            args: Prisma.UsageTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<UsageTrackingCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      Institution: {
        payload: Prisma.$InstitutionPayload<ExtArgs>
        fields: Prisma.InstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findMany: {
            args: Prisma.InstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          create: {
            args: Prisma.InstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          createMany: {
            args: Prisma.InstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          delete: {
            args: Prisma.InstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          update: {
            args: Prisma.InstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstitutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          upsert: {
            args: Prisma.InstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.InstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      ChapterChunk: {
        payload: Prisma.$ChapterChunkPayload<ExtArgs>
        fields: Prisma.ChapterChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>
          }
          findFirst: {
            args: Prisma.ChapterChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>
          }
          findMany: {
            args: Prisma.ChapterChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>[]
          }
          create: {
            args: Prisma.ChapterChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>
          }
          createMany: {
            args: Prisma.ChapterChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>[]
          }
          delete: {
            args: Prisma.ChapterChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>
          }
          update: {
            args: Prisma.ChapterChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>
          }
          deleteMany: {
            args: Prisma.ChapterChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterChunkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>[]
          }
          upsert: {
            args: Prisma.ChapterChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkPayload>
          }
          aggregate: {
            args: Prisma.ChapterChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterChunk>
          }
          groupBy: {
            args: Prisma.ChapterChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterChunkCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterChunkCountAggregateOutputType> | number
          }
        }
      }
      ChapterChunkBoard: {
        payload: Prisma.$ChapterChunkBoardPayload<ExtArgs>
        fields: Prisma.ChapterChunkBoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterChunkBoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterChunkBoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>
          }
          findFirst: {
            args: Prisma.ChapterChunkBoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterChunkBoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>
          }
          findMany: {
            args: Prisma.ChapterChunkBoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>[]
          }
          create: {
            args: Prisma.ChapterChunkBoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>
          }
          createMany: {
            args: Prisma.ChapterChunkBoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterChunkBoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>[]
          }
          delete: {
            args: Prisma.ChapterChunkBoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>
          }
          update: {
            args: Prisma.ChapterChunkBoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>
          }
          deleteMany: {
            args: Prisma.ChapterChunkBoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterChunkBoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterChunkBoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>[]
          }
          upsert: {
            args: Prisma.ChapterChunkBoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterChunkBoardPayload>
          }
          aggregate: {
            args: Prisma.ChapterChunkBoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterChunkBoard>
          }
          groupBy: {
            args: Prisma.ChapterChunkBoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterChunkBoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterChunkBoardCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterChunkBoardCountAggregateOutputType> | number
          }
        }
      }
      ChapterPage: {
        payload: Prisma.$ChapterPagePayload<ExtArgs>
        fields: Prisma.ChapterPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>
          }
          findFirst: {
            args: Prisma.ChapterPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>
          }
          findMany: {
            args: Prisma.ChapterPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>[]
          }
          create: {
            args: Prisma.ChapterPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>
          }
          createMany: {
            args: Prisma.ChapterPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>[]
          }
          delete: {
            args: Prisma.ChapterPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>
          }
          update: {
            args: Prisma.ChapterPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>
          }
          deleteMany: {
            args: Prisma.ChapterPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>[]
          }
          upsert: {
            args: Prisma.ChapterPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPagePayload>
          }
          aggregate: {
            args: Prisma.ChapterPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterPage>
          }
          groupBy: {
            args: Prisma.ChapterPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterPageCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterPageCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      UserPoints: {
        payload: Prisma.$UserPointsPayload<ExtArgs>
        fields: Prisma.UserPointsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPointsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPointsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>
          }
          findFirst: {
            args: Prisma.UserPointsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPointsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>
          }
          findMany: {
            args: Prisma.UserPointsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>[]
          }
          create: {
            args: Prisma.UserPointsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>
          }
          createMany: {
            args: Prisma.UserPointsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPointsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>[]
          }
          delete: {
            args: Prisma.UserPointsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>
          }
          update: {
            args: Prisma.UserPointsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>
          }
          deleteMany: {
            args: Prisma.UserPointsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPointsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPointsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>[]
          }
          upsert: {
            args: Prisma.UserPointsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPointsPayload>
          }
          aggregate: {
            args: Prisma.UserPointsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPoints>
          }
          groupBy: {
            args: Prisma.UserPointsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPointsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPointsCountArgs<ExtArgs>
            result: $Utils.Optional<UserPointsCountAggregateOutputType> | number
          }
        }
      }
      StudyMaterial: {
        payload: Prisma.$StudyMaterialPayload<ExtArgs>
        fields: Prisma.StudyMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>
          }
          findFirst: {
            args: Prisma.StudyMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>
          }
          findMany: {
            args: Prisma.StudyMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>[]
          }
          create: {
            args: Prisma.StudyMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>
          }
          createMany: {
            args: Prisma.StudyMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>[]
          }
          delete: {
            args: Prisma.StudyMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>
          }
          update: {
            args: Prisma.StudyMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>
          }
          deleteMany: {
            args: Prisma.StudyMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>[]
          }
          upsert: {
            args: Prisma.StudyMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyMaterialPayload>
          }
          aggregate: {
            args: Prisma.StudyMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyMaterial>
          }
          groupBy: {
            args: Prisma.StudyMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<StudyMaterialCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      StreakBadge: {
        payload: Prisma.$StreakBadgePayload<ExtArgs>
        fields: Prisma.StreakBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreakBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreakBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>
          }
          findFirst: {
            args: Prisma.StreakBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreakBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>
          }
          findMany: {
            args: Prisma.StreakBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>[]
          }
          create: {
            args: Prisma.StreakBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>
          }
          createMany: {
            args: Prisma.StreakBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreakBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>[]
          }
          delete: {
            args: Prisma.StreakBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>
          }
          update: {
            args: Prisma.StreakBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>
          }
          deleteMany: {
            args: Prisma.StreakBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreakBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StreakBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>[]
          }
          upsert: {
            args: Prisma.StreakBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakBadgePayload>
          }
          aggregate: {
            args: Prisma.StreakBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStreakBadge>
          }
          groupBy: {
            args: Prisma.StreakBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreakBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreakBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<StreakBadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      LearningSession: {
        payload: Prisma.$LearningSessionPayload<ExtArgs>
        fields: Prisma.LearningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          findFirst: {
            args: Prisma.LearningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          findMany: {
            args: Prisma.LearningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          create: {
            args: Prisma.LearningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          createMany: {
            args: Prisma.LearningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          delete: {
            args: Prisma.LearningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          update: {
            args: Prisma.LearningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          deleteMany: {
            args: Prisma.LearningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>[]
          }
          upsert: {
            args: Prisma.LearningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningSessionPayload>
          }
          aggregate: {
            args: Prisma.LearningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningSession>
          }
          groupBy: {
            args: Prisma.LearningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<LearningSessionCountAggregateOutputType> | number
          }
        }
      }
      Battle: {
        payload: Prisma.$BattlePayload<ExtArgs>
        fields: Prisma.BattleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BattleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BattleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          findFirst: {
            args: Prisma.BattleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BattleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          findMany: {
            args: Prisma.BattleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>[]
          }
          create: {
            args: Prisma.BattleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          createMany: {
            args: Prisma.BattleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BattleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>[]
          }
          delete: {
            args: Prisma.BattleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          update: {
            args: Prisma.BattleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          deleteMany: {
            args: Prisma.BattleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BattleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BattleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>[]
          }
          upsert: {
            args: Prisma.BattleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattlePayload>
          }
          aggregate: {
            args: Prisma.BattleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBattle>
          }
          groupBy: {
            args: Prisma.BattleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BattleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BattleCountArgs<ExtArgs>
            result: $Utils.Optional<BattleCountAggregateOutputType> | number
          }
        }
      }
      BattleParticipant: {
        payload: Prisma.$BattleParticipantPayload<ExtArgs>
        fields: Prisma.BattleParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BattleParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BattleParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>
          }
          findFirst: {
            args: Prisma.BattleParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BattleParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>
          }
          findMany: {
            args: Prisma.BattleParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>[]
          }
          create: {
            args: Prisma.BattleParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>
          }
          createMany: {
            args: Prisma.BattleParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BattleParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>[]
          }
          delete: {
            args: Prisma.BattleParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>
          }
          update: {
            args: Prisma.BattleParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>
          }
          deleteMany: {
            args: Prisma.BattleParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BattleParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BattleParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>[]
          }
          upsert: {
            args: Prisma.BattleParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BattleParticipantPayload>
          }
          aggregate: {
            args: Prisma.BattleParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBattleParticipant>
          }
          groupBy: {
            args: Prisma.BattleParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<BattleParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.BattleParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<BattleParticipantCountAggregateOutputType> | number
          }
        }
      }
      Syllabus: {
        payload: Prisma.$SyllabusPayload<ExtArgs>
        fields: Prisma.SyllabusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          findFirst: {
            args: Prisma.SyllabusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          findMany: {
            args: Prisma.SyllabusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>[]
          }
          create: {
            args: Prisma.SyllabusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          createMany: {
            args: Prisma.SyllabusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyllabusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>[]
          }
          delete: {
            args: Prisma.SyllabusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          update: {
            args: Prisma.SyllabusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyllabusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>[]
          }
          upsert: {
            args: Prisma.SyllabusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          aggregate: {
            args: Prisma.SyllabusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabus>
          }
          groupBy: {
            args: Prisma.SyllabusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyllabusCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusCountAggregateOutputType> | number
          }
        }
      }
      SyllabusUnit: {
        payload: Prisma.$SyllabusUnitPayload<ExtArgs>
        fields: Prisma.SyllabusUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>
          }
          findFirst: {
            args: Prisma.SyllabusUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>
          }
          findMany: {
            args: Prisma.SyllabusUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>[]
          }
          create: {
            args: Prisma.SyllabusUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>
          }
          createMany: {
            args: Prisma.SyllabusUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyllabusUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>[]
          }
          delete: {
            args: Prisma.SyllabusUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>
          }
          update: {
            args: Prisma.SyllabusUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyllabusUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>[]
          }
          upsert: {
            args: Prisma.SyllabusUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusUnitPayload>
          }
          aggregate: {
            args: Prisma.SyllabusUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabusUnit>
          }
          groupBy: {
            args: Prisma.SyllabusUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyllabusUnitCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusUnitCountAggregateOutputType> | number
          }
        }
      }
      SyllabusChapter: {
        payload: Prisma.$SyllabusChapterPayload<ExtArgs>
        fields: Prisma.SyllabusChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>
          }
          findFirst: {
            args: Prisma.SyllabusChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>
          }
          findMany: {
            args: Prisma.SyllabusChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>[]
          }
          create: {
            args: Prisma.SyllabusChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>
          }
          createMany: {
            args: Prisma.SyllabusChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyllabusChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>[]
          }
          delete: {
            args: Prisma.SyllabusChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>
          }
          update: {
            args: Prisma.SyllabusChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyllabusChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>[]
          }
          upsert: {
            args: Prisma.SyllabusChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusChapterPayload>
          }
          aggregate: {
            args: Prisma.SyllabusChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabusChapter>
          }
          groupBy: {
            args: Prisma.SyllabusChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyllabusChapterCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusChapterCountAggregateOutputType> | number
          }
        }
      }
      Textbook: {
        payload: Prisma.$TextbookPayload<ExtArgs>
        fields: Prisma.TextbookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextbookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextbookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>
          }
          findFirst: {
            args: Prisma.TextbookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextbookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>
          }
          findMany: {
            args: Prisma.TextbookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>[]
          }
          create: {
            args: Prisma.TextbookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>
          }
          createMany: {
            args: Prisma.TextbookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextbookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>[]
          }
          delete: {
            args: Prisma.TextbookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>
          }
          update: {
            args: Prisma.TextbookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>
          }
          deleteMany: {
            args: Prisma.TextbookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextbookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextbookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>[]
          }
          upsert: {
            args: Prisma.TextbookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookPayload>
          }
          aggregate: {
            args: Prisma.TextbookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextbook>
          }
          groupBy: {
            args: Prisma.TextbookGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextbookGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextbookCountArgs<ExtArgs>
            result: $Utils.Optional<TextbookCountAggregateOutputType> | number
          }
        }
      }
      TextbookUnit: {
        payload: Prisma.$TextbookUnitPayload<ExtArgs>
        fields: Prisma.TextbookUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextbookUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextbookUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>
          }
          findFirst: {
            args: Prisma.TextbookUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextbookUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>
          }
          findMany: {
            args: Prisma.TextbookUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>[]
          }
          create: {
            args: Prisma.TextbookUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>
          }
          createMany: {
            args: Prisma.TextbookUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextbookUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>[]
          }
          delete: {
            args: Prisma.TextbookUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>
          }
          update: {
            args: Prisma.TextbookUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>
          }
          deleteMany: {
            args: Prisma.TextbookUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextbookUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextbookUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>[]
          }
          upsert: {
            args: Prisma.TextbookUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookUnitPayload>
          }
          aggregate: {
            args: Prisma.TextbookUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextbookUnit>
          }
          groupBy: {
            args: Prisma.TextbookUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextbookUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextbookUnitCountArgs<ExtArgs>
            result: $Utils.Optional<TextbookUnitCountAggregateOutputType> | number
          }
        }
      }
      TextbookChapter: {
        payload: Prisma.$TextbookChapterPayload<ExtArgs>
        fields: Prisma.TextbookChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextbookChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextbookChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>
          }
          findFirst: {
            args: Prisma.TextbookChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextbookChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>
          }
          findMany: {
            args: Prisma.TextbookChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>[]
          }
          create: {
            args: Prisma.TextbookChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>
          }
          createMany: {
            args: Prisma.TextbookChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextbookChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>[]
          }
          delete: {
            args: Prisma.TextbookChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>
          }
          update: {
            args: Prisma.TextbookChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>
          }
          deleteMany: {
            args: Prisma.TextbookChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextbookChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextbookChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>[]
          }
          upsert: {
            args: Prisma.TextbookChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookChapterPayload>
          }
          aggregate: {
            args: Prisma.TextbookChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextbookChapter>
          }
          groupBy: {
            args: Prisma.TextbookChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextbookChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextbookChapterCountArgs<ExtArgs>
            result: $Utils.Optional<TextbookChapterCountAggregateOutputType> | number
          }
        }
      }
      TextbookImage: {
        payload: Prisma.$TextbookImagePayload<ExtArgs>
        fields: Prisma.TextbookImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextbookImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextbookImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>
          }
          findFirst: {
            args: Prisma.TextbookImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextbookImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>
          }
          findMany: {
            args: Prisma.TextbookImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>[]
          }
          create: {
            args: Prisma.TextbookImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>
          }
          createMany: {
            args: Prisma.TextbookImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextbookImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>[]
          }
          delete: {
            args: Prisma.TextbookImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>
          }
          update: {
            args: Prisma.TextbookImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>
          }
          deleteMany: {
            args: Prisma.TextbookImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextbookImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextbookImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>[]
          }
          upsert: {
            args: Prisma.TextbookImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookImagePayload>
          }
          aggregate: {
            args: Prisma.TextbookImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextbookImage>
          }
          groupBy: {
            args: Prisma.TextbookImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextbookImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextbookImageCountArgs<ExtArgs>
            result: $Utils.Optional<TextbookImageCountAggregateOutputType> | number
          }
        }
      }
      TextbookGenerationJob: {
        payload: Prisma.$TextbookGenerationJobPayload<ExtArgs>
        fields: Prisma.TextbookGenerationJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TextbookGenerationJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TextbookGenerationJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>
          }
          findFirst: {
            args: Prisma.TextbookGenerationJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TextbookGenerationJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>
          }
          findMany: {
            args: Prisma.TextbookGenerationJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>[]
          }
          create: {
            args: Prisma.TextbookGenerationJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>
          }
          createMany: {
            args: Prisma.TextbookGenerationJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TextbookGenerationJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>[]
          }
          delete: {
            args: Prisma.TextbookGenerationJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>
          }
          update: {
            args: Prisma.TextbookGenerationJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>
          }
          deleteMany: {
            args: Prisma.TextbookGenerationJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TextbookGenerationJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TextbookGenerationJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>[]
          }
          upsert: {
            args: Prisma.TextbookGenerationJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TextbookGenerationJobPayload>
          }
          aggregate: {
            args: Prisma.TextbookGenerationJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTextbookGenerationJob>
          }
          groupBy: {
            args: Prisma.TextbookGenerationJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<TextbookGenerationJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.TextbookGenerationJobCountArgs<ExtArgs>
            result: $Utils.Optional<TextbookGenerationJobCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    categoryList?: CategoryListOmit
    fileList?: FileListOmit
    documentPage?: DocumentPageOmit
    fileChunk?: FileChunkOmit
    user?: userOmit
    userEnrollment?: UserEnrollmentOmit
    conversation?: ConversationOmit
    conversationMessage?: ConversationMessageOmit
    aiApiKey?: AiApiKeyOmit
    aiModel?: AiModelOmit
    app_settings?: app_settingsOmit
    subscriptionPlan?: SubscriptionPlanOmit
    userSubscription?: UserSubscriptionOmit
    usageTracking?: UsageTrackingOmit
    country?: CountryOmit
    board?: BoardOmit
    institution?: InstitutionOmit
    program?: ProgramOmit
    profile?: ProfileOmit
    subject?: SubjectOmit
    chapter?: ChapterOmit
    chapterChunk?: ChapterChunkOmit
    chapterChunkBoard?: ChapterChunkBoardOmit
    chapterPage?: ChapterPageOmit
    systemSetting?: SystemSettingOmit
    quiz?: QuizOmit
    quizQuestion?: QuizQuestionOmit
    question?: QuestionOmit
    userPoints?: UserPointsOmit
    studyMaterial?: StudyMaterialOmit
    exam?: ExamOmit
    streakBadge?: StreakBadgeOmit
    userBadge?: UserBadgeOmit
    learningSession?: LearningSessionOmit
    battle?: BattleOmit
    battleParticipant?: BattleParticipantOmit
    syllabus?: SyllabusOmit
    syllabusUnit?: SyllabusUnitOmit
    syllabusChapter?: SyllabusChapterOmit
    textbook?: TextbookOmit
    textbookUnit?: TextbookUnitOmit
    textbookChapter?: TextbookChapterOmit
    textbookImage?: TextbookImageOmit
    textbookGenerationJob?: TextbookGenerationJobOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FileListCountOutputType
   */

  export type FileListCountOutputType = {
    pages: number
    chunks: number
  }

  export type FileListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | FileListCountOutputTypeCountPagesArgs
    chunks?: boolean | FileListCountOutputTypeCountChunksArgs
  }

  // Custom InputTypes
  /**
   * FileListCountOutputType without action
   */
  export type FileListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileListCountOutputType
     */
    select?: FileListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileListCountOutputType without action
   */
  export type FileListCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPageWhereInput
  }

  /**
   * FileListCountOutputType without action
   */
  export type FileListCountOutputTypeCountChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileChunkWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    categories: number
    conversations: number
    files: number
    usage_tracking: number
    quizzes: number
    points: number
    badges: number
    learning_sessions: number
    created_battles: number
    battle_participations: number
    textbooks_created: number
    enrollments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | UserCountOutputTypeCountCategoriesArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    files?: boolean | UserCountOutputTypeCountFilesArgs
    usage_tracking?: boolean | UserCountOutputTypeCountUsage_trackingArgs
    quizzes?: boolean | UserCountOutputTypeCountQuizzesArgs
    points?: boolean | UserCountOutputTypeCountPointsArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    learning_sessions?: boolean | UserCountOutputTypeCountLearning_sessionsArgs
    created_battles?: boolean | UserCountOutputTypeCountCreated_battlesArgs
    battle_participations?: boolean | UserCountOutputTypeCountBattle_participationsArgs
    textbooks_created?: boolean | UserCountOutputTypeCountTextbooks_createdArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsage_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPointsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearning_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreated_battlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBattle_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTextbooks_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEnrollmentWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    boards: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | CountryCountOutputTypeCountBoardsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
  }


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    institutions: number
    programs: number
    chunkBoards: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institutions?: boolean | BoardCountOutputTypeCountInstitutionsArgs
    programs?: boolean | BoardCountOutputTypeCountProgramsArgs
    chunkBoards?: boolean | BoardCountOutputTypeCountChunkBoardsArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountChunkBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChunkBoardWhereInput
  }


  /**
   * Count Type InstitutionCountOutputType
   */

  export type InstitutionCountOutputType = {
    programs: number
    profiles: number
  }

  export type InstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | InstitutionCountOutputTypeCountProgramsArgs
    profiles?: boolean | InstitutionCountOutputTypeCountProfilesArgs
  }

  // Custom InputTypes
  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionCountOutputType
     */
    select?: InstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    subjects: number
    profiles: number
    exams: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | ProgramCountOutputTypeCountSubjectsArgs
    profiles?: boolean | ProgramCountOutputTypeCountProfilesArgs
    exams?: boolean | ProgramCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    chapters: number
    quizzes: number
    conversations: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | SubjectCountOutputTypeCountChaptersArgs
    quizzes?: boolean | SubjectCountOutputTypeCountQuizzesArgs
    conversations?: boolean | SubjectCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    chunks: number
    pages: number
    quizzes: number
    learning_sessions: number
    conversations: number
    questions: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunks?: boolean | ChapterCountOutputTypeCountChunksArgs
    pages?: boolean | ChapterCountOutputTypeCountPagesArgs
    quizzes?: boolean | ChapterCountOutputTypeCountQuizzesArgs
    learning_sessions?: boolean | ChapterCountOutputTypeCountLearning_sessionsArgs
    conversations?: boolean | ChapterCountOutputTypeCountConversationsArgs
    questions?: boolean | ChapterCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChunkWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterPageWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountLearning_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }


  /**
   * Count Type ChapterChunkCountOutputType
   */

  export type ChapterChunkCountOutputType = {
    chunkBoards: number
  }

  export type ChapterChunkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunkBoards?: boolean | ChapterChunkCountOutputTypeCountChunkBoardsArgs
  }

  // Custom InputTypes
  /**
   * ChapterChunkCountOutputType without action
   */
  export type ChapterChunkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkCountOutputType
     */
    select?: ChapterChunkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterChunkCountOutputType without action
   */
  export type ChapterChunkCountOutputTypeCountChunkBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChunkBoardWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
    battles: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    battles?: boolean | QuizCountOutputTypeCountBattlesArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountBattlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
  }


  /**
   * Count Type StreakBadgeCountOutputType
   */

  export type StreakBadgeCountOutputType = {
    user_badges: number
  }

  export type StreakBadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_badges?: boolean | StreakBadgeCountOutputTypeCountUser_badgesArgs
  }

  // Custom InputTypes
  /**
   * StreakBadgeCountOutputType without action
   */
  export type StreakBadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadgeCountOutputType
     */
    select?: StreakBadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StreakBadgeCountOutputType without action
   */
  export type StreakBadgeCountOutputTypeCountUser_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type BattleCountOutputType
   */

  export type BattleCountOutputType = {
    participants: number
  }

  export type BattleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | BattleCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * BattleCountOutputType without action
   */
  export type BattleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleCountOutputType
     */
    select?: BattleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BattleCountOutputType without action
   */
  export type BattleCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleParticipantWhereInput
  }


  /**
   * Count Type SyllabusCountOutputType
   */

  export type SyllabusCountOutputType = {
    units: number
    textbooks: number
  }

  export type SyllabusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | SyllabusCountOutputTypeCountUnitsArgs
    textbooks?: boolean | SyllabusCountOutputTypeCountTextbooksArgs
  }

  // Custom InputTypes
  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusCountOutputType
     */
    select?: SyllabusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusUnitWhereInput
  }

  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeCountTextbooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookWhereInput
  }


  /**
   * Count Type SyllabusUnitCountOutputType
   */

  export type SyllabusUnitCountOutputType = {
    chapters: number
  }

  export type SyllabusUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | SyllabusUnitCountOutputTypeCountChaptersArgs
  }

  // Custom InputTypes
  /**
   * SyllabusUnitCountOutputType without action
   */
  export type SyllabusUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnitCountOutputType
     */
    select?: SyllabusUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SyllabusUnitCountOutputType without action
   */
  export type SyllabusUnitCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusChapterWhereInput
  }


  /**
   * Count Type TextbookCountOutputType
   */

  export type TextbookCountOutputType = {
    units: number
    generation_jobs: number
    enrollments: number
  }

  export type TextbookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | TextbookCountOutputTypeCountUnitsArgs
    generation_jobs?: boolean | TextbookCountOutputTypeCountGeneration_jobsArgs
    enrollments?: boolean | TextbookCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * TextbookCountOutputType without action
   */
  export type TextbookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookCountOutputType
     */
    select?: TextbookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TextbookCountOutputType without action
   */
  export type TextbookCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookUnitWhereInput
  }

  /**
   * TextbookCountOutputType without action
   */
  export type TextbookCountOutputTypeCountGeneration_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookGenerationJobWhereInput
  }

  /**
   * TextbookCountOutputType without action
   */
  export type TextbookCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEnrollmentWhereInput
  }


  /**
   * Count Type TextbookUnitCountOutputType
   */

  export type TextbookUnitCountOutputType = {
    chapters: number
  }

  export type TextbookUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | TextbookUnitCountOutputTypeCountChaptersArgs
  }

  // Custom InputTypes
  /**
   * TextbookUnitCountOutputType without action
   */
  export type TextbookUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnitCountOutputType
     */
    select?: TextbookUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TextbookUnitCountOutputType without action
   */
  export type TextbookUnitCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookChapterWhereInput
  }


  /**
   * Count Type TextbookChapterCountOutputType
   */

  export type TextbookChapterCountOutputType = {
    images: number
  }

  export type TextbookChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | TextbookChapterCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * TextbookChapterCountOutputType without action
   */
  export type TextbookChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapterCountOutputType
     */
    select?: TextbookChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TextbookChapterCountOutputType without action
   */
  export type TextbookChapterCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookImageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CategoryList
   */

  export type AggregateCategoryList = {
    _count: CategoryListCountAggregateOutputType | null
    _avg: CategoryListAvgAggregateOutputType | null
    _sum: CategoryListSumAggregateOutputType | null
    _min: CategoryListMinAggregateOutputType | null
    _max: CategoryListMaxAggregateOutputType | null
  }

  export type CategoryListAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type CategoryListSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type CategoryListMinAggregateOutputType = {
    id: number | null
    category: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
  }

  export type CategoryListMaxAggregateOutputType = {
    id: number | null
    category: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
  }

  export type CategoryListCountAggregateOutputType = {
    id: number
    category: number
    created_at: number
    updated_at: number
    user_id: number
    _all: number
  }


  export type CategoryListAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type CategoryListSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type CategoryListMinAggregateInputType = {
    id?: true
    category?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type CategoryListMaxAggregateInputType = {
    id?: true
    category?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type CategoryListCountAggregateInputType = {
    id?: true
    category?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    _all?: true
  }

  export type CategoryListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryList to aggregate.
     */
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     */
    orderBy?: CategoryListOrderByWithRelationInput | CategoryListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryLists
    **/
    _count?: true | CategoryListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoryListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryListMaxAggregateInputType
  }

  export type GetCategoryListAggregateType<T extends CategoryListAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryList[P]>
      : GetScalarType<T[P], AggregateCategoryList[P]>
  }




  export type CategoryListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryListWhereInput
    orderBy?: CategoryListOrderByWithAggregationInput | CategoryListOrderByWithAggregationInput[]
    by: CategoryListScalarFieldEnum[] | CategoryListScalarFieldEnum
    having?: CategoryListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryListCountAggregateInputType | true
    _avg?: CategoryListAvgAggregateInputType
    _sum?: CategoryListSumAggregateInputType
    _min?: CategoryListMinAggregateInputType
    _max?: CategoryListMaxAggregateInputType
  }

  export type CategoryListGroupByOutputType = {
    id: number
    category: string
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    _count: CategoryListCountAggregateOutputType | null
    _avg: CategoryListAvgAggregateOutputType | null
    _sum: CategoryListSumAggregateOutputType | null
    _min: CategoryListMinAggregateOutputType | null
    _max: CategoryListMaxAggregateOutputType | null
  }

  type GetCategoryListGroupByPayload<T extends CategoryListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryListGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryListGroupByOutputType[P]>
        }
      >
    >


  export type CategoryListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | CategoryList$userArgs<ExtArgs>
  }, ExtArgs["result"]["categoryList"]>

  export type CategoryListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | CategoryList$userArgs<ExtArgs>
  }, ExtArgs["result"]["categoryList"]>

  export type CategoryListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | CategoryList$userArgs<ExtArgs>
  }, ExtArgs["result"]["categoryList"]>

  export type CategoryListSelectScalar = {
    id?: boolean
    category?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
  }

  export type CategoryListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "created_at" | "updated_at" | "user_id", ExtArgs["result"]["categoryList"]>
  export type CategoryListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CategoryList$userArgs<ExtArgs>
  }
  export type CategoryListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CategoryList$userArgs<ExtArgs>
  }
  export type CategoryListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | CategoryList$userArgs<ExtArgs>
  }

  export type $CategoryListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryList"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      created_at: Date | null
      updated_at: Date | null
      user_id: number | null
    }, ExtArgs["result"]["categoryList"]>
    composites: {}
  }

  type CategoryListGetPayload<S extends boolean | null | undefined | CategoryListDefaultArgs> = $Result.GetResult<Prisma.$CategoryListPayload, S>

  type CategoryListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryListCountAggregateInputType | true
    }

  export interface CategoryListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryList'], meta: { name: 'CategoryList' } }
    /**
     * Find zero or one CategoryList that matches the filter.
     * @param {CategoryListFindUniqueArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryListFindUniqueArgs>(args: SelectSubset<T, CategoryListFindUniqueArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoryList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryListFindUniqueOrThrowArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryListFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListFindFirstArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryListFindFirstArgs>(args?: SelectSubset<T, CategoryListFindFirstArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListFindFirstOrThrowArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryListFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryListFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoryLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryLists
     * const categoryLists = await prisma.categoryList.findMany()
     * 
     * // Get first 10 CategoryLists
     * const categoryLists = await prisma.categoryList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryListWithIdOnly = await prisma.categoryList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryListFindManyArgs>(args?: SelectSubset<T, CategoryListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoryList.
     * @param {CategoryListCreateArgs} args - Arguments to create a CategoryList.
     * @example
     * // Create one CategoryList
     * const CategoryList = await prisma.categoryList.create({
     *   data: {
     *     // ... data to create a CategoryList
     *   }
     * })
     * 
     */
    create<T extends CategoryListCreateArgs>(args: SelectSubset<T, CategoryListCreateArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoryLists.
     * @param {CategoryListCreateManyArgs} args - Arguments to create many CategoryLists.
     * @example
     * // Create many CategoryLists
     * const categoryList = await prisma.categoryList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryListCreateManyArgs>(args?: SelectSubset<T, CategoryListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryLists and returns the data saved in the database.
     * @param {CategoryListCreateManyAndReturnArgs} args - Arguments to create many CategoryLists.
     * @example
     * // Create many CategoryLists
     * const categoryList = await prisma.categoryList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryLists and only return the `id`
     * const categoryListWithIdOnly = await prisma.categoryList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryListCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoryList.
     * @param {CategoryListDeleteArgs} args - Arguments to delete one CategoryList.
     * @example
     * // Delete one CategoryList
     * const CategoryList = await prisma.categoryList.delete({
     *   where: {
     *     // ... filter to delete one CategoryList
     *   }
     * })
     * 
     */
    delete<T extends CategoryListDeleteArgs>(args: SelectSubset<T, CategoryListDeleteArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoryList.
     * @param {CategoryListUpdateArgs} args - Arguments to update one CategoryList.
     * @example
     * // Update one CategoryList
     * const categoryList = await prisma.categoryList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryListUpdateArgs>(args: SelectSubset<T, CategoryListUpdateArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoryLists.
     * @param {CategoryListDeleteManyArgs} args - Arguments to filter CategoryLists to delete.
     * @example
     * // Delete a few CategoryLists
     * const { count } = await prisma.categoryList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryListDeleteManyArgs>(args?: SelectSubset<T, CategoryListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryLists
     * const categoryList = await prisma.categoryList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryListUpdateManyArgs>(args: SelectSubset<T, CategoryListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryLists and returns the data updated in the database.
     * @param {CategoryListUpdateManyAndReturnArgs} args - Arguments to update many CategoryLists.
     * @example
     * // Update many CategoryLists
     * const categoryList = await prisma.categoryList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoryLists and only return the `id`
     * const categoryListWithIdOnly = await prisma.categoryList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryListUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoryList.
     * @param {CategoryListUpsertArgs} args - Arguments to update or create a CategoryList.
     * @example
     * // Update or create a CategoryList
     * const categoryList = await prisma.categoryList.upsert({
     *   create: {
     *     // ... data to create a CategoryList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryList we want to update
     *   }
     * })
     */
    upsert<T extends CategoryListUpsertArgs>(args: SelectSubset<T, CategoryListUpsertArgs<ExtArgs>>): Prisma__CategoryListClient<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoryLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListCountArgs} args - Arguments to filter CategoryLists to count.
     * @example
     * // Count the number of CategoryLists
     * const count = await prisma.categoryList.count({
     *   where: {
     *     // ... the filter for the CategoryLists we want to count
     *   }
     * })
    **/
    count<T extends CategoryListCountArgs>(
      args?: Subset<T, CategoryListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryListAggregateArgs>(args: Subset<T, CategoryListAggregateArgs>): Prisma.PrismaPromise<GetCategoryListAggregateType<T>>

    /**
     * Group by CategoryList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryListGroupByArgs['orderBy'] }
        : { orderBy?: CategoryListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryList model
   */
  readonly fields: CategoryListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends CategoryList$userArgs<ExtArgs> = {}>(args?: Subset<T, CategoryList$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryList model
   */
  interface CategoryListFieldRefs {
    readonly id: FieldRef<"CategoryList", 'Int'>
    readonly category: FieldRef<"CategoryList", 'String'>
    readonly created_at: FieldRef<"CategoryList", 'DateTime'>
    readonly updated_at: FieldRef<"CategoryList", 'DateTime'>
    readonly user_id: FieldRef<"CategoryList", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CategoryList findUnique
   */
  export type CategoryListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * Filter, which CategoryList to fetch.
     */
    where: CategoryListWhereUniqueInput
  }

  /**
   * CategoryList findUniqueOrThrow
   */
  export type CategoryListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * Filter, which CategoryList to fetch.
     */
    where: CategoryListWhereUniqueInput
  }

  /**
   * CategoryList findFirst
   */
  export type CategoryListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * Filter, which CategoryList to fetch.
     */
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     */
    orderBy?: CategoryListOrderByWithRelationInput | CategoryListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryLists.
     */
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryLists.
     */
    distinct?: CategoryListScalarFieldEnum | CategoryListScalarFieldEnum[]
  }

  /**
   * CategoryList findFirstOrThrow
   */
  export type CategoryListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * Filter, which CategoryList to fetch.
     */
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     */
    orderBy?: CategoryListOrderByWithRelationInput | CategoryListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryLists.
     */
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryLists.
     */
    distinct?: CategoryListScalarFieldEnum | CategoryListScalarFieldEnum[]
  }

  /**
   * CategoryList findMany
   */
  export type CategoryListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * Filter, which CategoryLists to fetch.
     */
    where?: CategoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryLists to fetch.
     */
    orderBy?: CategoryListOrderByWithRelationInput | CategoryListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryLists.
     */
    cursor?: CategoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryLists.
     */
    skip?: number
    distinct?: CategoryListScalarFieldEnum | CategoryListScalarFieldEnum[]
  }

  /**
   * CategoryList create
   */
  export type CategoryListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryList.
     */
    data: XOR<CategoryListCreateInput, CategoryListUncheckedCreateInput>
  }

  /**
   * CategoryList createMany
   */
  export type CategoryListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryLists.
     */
    data: CategoryListCreateManyInput | CategoryListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryList createManyAndReturn
   */
  export type CategoryListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * The data used to create many CategoryLists.
     */
    data: CategoryListCreateManyInput | CategoryListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryList update
   */
  export type CategoryListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryList.
     */
    data: XOR<CategoryListUpdateInput, CategoryListUncheckedUpdateInput>
    /**
     * Choose, which CategoryList to update.
     */
    where: CategoryListWhereUniqueInput
  }

  /**
   * CategoryList updateMany
   */
  export type CategoryListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryLists.
     */
    data: XOR<CategoryListUpdateManyMutationInput, CategoryListUncheckedUpdateManyInput>
    /**
     * Filter which CategoryLists to update
     */
    where?: CategoryListWhereInput
    /**
     * Limit how many CategoryLists to update.
     */
    limit?: number
  }

  /**
   * CategoryList updateManyAndReturn
   */
  export type CategoryListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * The data used to update CategoryLists.
     */
    data: XOR<CategoryListUpdateManyMutationInput, CategoryListUncheckedUpdateManyInput>
    /**
     * Filter which CategoryLists to update
     */
    where?: CategoryListWhereInput
    /**
     * Limit how many CategoryLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryList upsert
   */
  export type CategoryListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryList to update in case it exists.
     */
    where: CategoryListWhereUniqueInput
    /**
     * In case the CategoryList found by the `where` argument doesn't exist, create a new CategoryList with this data.
     */
    create: XOR<CategoryListCreateInput, CategoryListUncheckedCreateInput>
    /**
     * In case the CategoryList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryListUpdateInput, CategoryListUncheckedUpdateInput>
  }

  /**
   * CategoryList delete
   */
  export type CategoryListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    /**
     * Filter which CategoryList to delete.
     */
    where: CategoryListWhereUniqueInput
  }

  /**
   * CategoryList deleteMany
   */
  export type CategoryListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryLists to delete
     */
    where?: CategoryListWhereInput
    /**
     * Limit how many CategoryLists to delete.
     */
    limit?: number
  }

  /**
   * CategoryList.user
   */
  export type CategoryList$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * CategoryList without action
   */
  export type CategoryListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
  }


  /**
   * Model FileList
   */

  export type AggregateFileList = {
    _count: FileListCountAggregateOutputType | null
    _avg: FileListAvgAggregateOutputType | null
    _sum: FileListSumAggregateOutputType | null
    _min: FileListMinAggregateOutputType | null
    _max: FileListMaxAggregateOutputType | null
  }

  export type FileListAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type FileListSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type FileListMinAggregateOutputType = {
    id: number | null
    category: string | null
    title: string | null
    note: string | null
    content_format: string | null
    doc1: string | null
    entry_date: string | null
    entry_date_real: Date | null
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    parsing_status: string | null
    parsing_error: string | null
    parsed_at: Date | null
  }

  export type FileListMaxAggregateOutputType = {
    id: number | null
    category: string | null
    title: string | null
    note: string | null
    content_format: string | null
    doc1: string | null
    entry_date: string | null
    entry_date_real: Date | null
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    parsing_status: string | null
    parsing_error: string | null
    parsed_at: Date | null
  }

  export type FileListCountAggregateOutputType = {
    id: number
    category: number
    title: number
    note: number
    content_format: number
    doc1: number
    entry_date: number
    entry_date_real: number
    created_at: number
    updated_at: number
    user_id: number
    parsing_status: number
    parsing_error: number
    parsed_at: number
    _all: number
  }


  export type FileListAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type FileListSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type FileListMinAggregateInputType = {
    id?: true
    category?: true
    title?: true
    note?: true
    content_format?: true
    doc1?: true
    entry_date?: true
    entry_date_real?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    parsing_status?: true
    parsing_error?: true
    parsed_at?: true
  }

  export type FileListMaxAggregateInputType = {
    id?: true
    category?: true
    title?: true
    note?: true
    content_format?: true
    doc1?: true
    entry_date?: true
    entry_date_real?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    parsing_status?: true
    parsing_error?: true
    parsed_at?: true
  }

  export type FileListCountAggregateInputType = {
    id?: true
    category?: true
    title?: true
    note?: true
    content_format?: true
    doc1?: true
    entry_date?: true
    entry_date_real?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    parsing_status?: true
    parsing_error?: true
    parsed_at?: true
    _all?: true
  }

  export type FileListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileList to aggregate.
     */
    where?: FileListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileLists to fetch.
     */
    orderBy?: FileListOrderByWithRelationInput | FileListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileLists
    **/
    _count?: true | FileListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileListMaxAggregateInputType
  }

  export type GetFileListAggregateType<T extends FileListAggregateArgs> = {
        [P in keyof T & keyof AggregateFileList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileList[P]>
      : GetScalarType<T[P], AggregateFileList[P]>
  }




  export type FileListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileListWhereInput
    orderBy?: FileListOrderByWithAggregationInput | FileListOrderByWithAggregationInput[]
    by: FileListScalarFieldEnum[] | FileListScalarFieldEnum
    having?: FileListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileListCountAggregateInputType | true
    _avg?: FileListAvgAggregateInputType
    _sum?: FileListSumAggregateInputType
    _min?: FileListMinAggregateInputType
    _max?: FileListMaxAggregateInputType
  }

  export type FileListGroupByOutputType = {
    id: number
    category: string
    title: string
    note: string | null
    content_format: string | null
    doc1: string | null
    entry_date: string | null
    entry_date_real: Date | null
    created_at: Date | null
    updated_at: Date | null
    user_id: number | null
    parsing_status: string | null
    parsing_error: string | null
    parsed_at: Date | null
    _count: FileListCountAggregateOutputType | null
    _avg: FileListAvgAggregateOutputType | null
    _sum: FileListSumAggregateOutputType | null
    _min: FileListMinAggregateOutputType | null
    _max: FileListMaxAggregateOutputType | null
  }

  type GetFileListGroupByPayload<T extends FileListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileListGroupByOutputType[P]>
            : GetScalarType<T[P], FileListGroupByOutputType[P]>
        }
      >
    >


  export type FileListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    title?: boolean
    note?: boolean
    content_format?: boolean
    doc1?: boolean
    entry_date?: boolean
    entry_date_real?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    parsing_status?: boolean
    parsing_error?: boolean
    parsed_at?: boolean
    user?: boolean | FileList$userArgs<ExtArgs>
    pages?: boolean | FileList$pagesArgs<ExtArgs>
    chunks?: boolean | FileList$chunksArgs<ExtArgs>
    _count?: boolean | FileListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileList"]>

  export type FileListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    title?: boolean
    note?: boolean
    content_format?: boolean
    doc1?: boolean
    entry_date?: boolean
    entry_date_real?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    parsing_status?: boolean
    parsing_error?: boolean
    parsed_at?: boolean
    user?: boolean | FileList$userArgs<ExtArgs>
  }, ExtArgs["result"]["fileList"]>

  export type FileListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    title?: boolean
    note?: boolean
    content_format?: boolean
    doc1?: boolean
    entry_date?: boolean
    entry_date_real?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    parsing_status?: boolean
    parsing_error?: boolean
    parsed_at?: boolean
    user?: boolean | FileList$userArgs<ExtArgs>
  }, ExtArgs["result"]["fileList"]>

  export type FileListSelectScalar = {
    id?: boolean
    category?: boolean
    title?: boolean
    note?: boolean
    content_format?: boolean
    doc1?: boolean
    entry_date?: boolean
    entry_date_real?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    parsing_status?: boolean
    parsing_error?: boolean
    parsed_at?: boolean
  }

  export type FileListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "title" | "note" | "content_format" | "doc1" | "entry_date" | "entry_date_real" | "created_at" | "updated_at" | "user_id" | "parsing_status" | "parsing_error" | "parsed_at", ExtArgs["result"]["fileList"]>
  export type FileListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FileList$userArgs<ExtArgs>
    pages?: boolean | FileList$pagesArgs<ExtArgs>
    chunks?: boolean | FileList$chunksArgs<ExtArgs>
    _count?: boolean | FileListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FileList$userArgs<ExtArgs>
  }
  export type FileListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | FileList$userArgs<ExtArgs>
  }

  export type $FileListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileList"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      pages: Prisma.$DocumentPagePayload<ExtArgs>[]
      chunks: Prisma.$FileChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: string
      title: string
      note: string | null
      content_format: string | null
      doc1: string | null
      entry_date: string | null
      entry_date_real: Date | null
      created_at: Date | null
      updated_at: Date | null
      user_id: number | null
      parsing_status: string | null
      parsing_error: string | null
      parsed_at: Date | null
    }, ExtArgs["result"]["fileList"]>
    composites: {}
  }

  type FileListGetPayload<S extends boolean | null | undefined | FileListDefaultArgs> = $Result.GetResult<Prisma.$FileListPayload, S>

  type FileListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileListCountAggregateInputType | true
    }

  export interface FileListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileList'], meta: { name: 'FileList' } }
    /**
     * Find zero or one FileList that matches the filter.
     * @param {FileListFindUniqueArgs} args - Arguments to find a FileList
     * @example
     * // Get one FileList
     * const fileList = await prisma.fileList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileListFindUniqueArgs>(args: SelectSubset<T, FileListFindUniqueArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileListFindUniqueOrThrowArgs} args - Arguments to find a FileList
     * @example
     * // Get one FileList
     * const fileList = await prisma.fileList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileListFindUniqueOrThrowArgs>(args: SelectSubset<T, FileListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListFindFirstArgs} args - Arguments to find a FileList
     * @example
     * // Get one FileList
     * const fileList = await prisma.fileList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileListFindFirstArgs>(args?: SelectSubset<T, FileListFindFirstArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListFindFirstOrThrowArgs} args - Arguments to find a FileList
     * @example
     * // Get one FileList
     * const fileList = await prisma.fileList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileListFindFirstOrThrowArgs>(args?: SelectSubset<T, FileListFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileLists
     * const fileLists = await prisma.fileList.findMany()
     * 
     * // Get first 10 FileLists
     * const fileLists = await prisma.fileList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileListWithIdOnly = await prisma.fileList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileListFindManyArgs>(args?: SelectSubset<T, FileListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileList.
     * @param {FileListCreateArgs} args - Arguments to create a FileList.
     * @example
     * // Create one FileList
     * const FileList = await prisma.fileList.create({
     *   data: {
     *     // ... data to create a FileList
     *   }
     * })
     * 
     */
    create<T extends FileListCreateArgs>(args: SelectSubset<T, FileListCreateArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileLists.
     * @param {FileListCreateManyArgs} args - Arguments to create many FileLists.
     * @example
     * // Create many FileLists
     * const fileList = await prisma.fileList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileListCreateManyArgs>(args?: SelectSubset<T, FileListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileLists and returns the data saved in the database.
     * @param {FileListCreateManyAndReturnArgs} args - Arguments to create many FileLists.
     * @example
     * // Create many FileLists
     * const fileList = await prisma.fileList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileLists and only return the `id`
     * const fileListWithIdOnly = await prisma.fileList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileListCreateManyAndReturnArgs>(args?: SelectSubset<T, FileListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileList.
     * @param {FileListDeleteArgs} args - Arguments to delete one FileList.
     * @example
     * // Delete one FileList
     * const FileList = await prisma.fileList.delete({
     *   where: {
     *     // ... filter to delete one FileList
     *   }
     * })
     * 
     */
    delete<T extends FileListDeleteArgs>(args: SelectSubset<T, FileListDeleteArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileList.
     * @param {FileListUpdateArgs} args - Arguments to update one FileList.
     * @example
     * // Update one FileList
     * const fileList = await prisma.fileList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileListUpdateArgs>(args: SelectSubset<T, FileListUpdateArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileLists.
     * @param {FileListDeleteManyArgs} args - Arguments to filter FileLists to delete.
     * @example
     * // Delete a few FileLists
     * const { count } = await prisma.fileList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileListDeleteManyArgs>(args?: SelectSubset<T, FileListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileLists
     * const fileList = await prisma.fileList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileListUpdateManyArgs>(args: SelectSubset<T, FileListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileLists and returns the data updated in the database.
     * @param {FileListUpdateManyAndReturnArgs} args - Arguments to update many FileLists.
     * @example
     * // Update many FileLists
     * const fileList = await prisma.fileList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileLists and only return the `id`
     * const fileListWithIdOnly = await prisma.fileList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileListUpdateManyAndReturnArgs>(args: SelectSubset<T, FileListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileList.
     * @param {FileListUpsertArgs} args - Arguments to update or create a FileList.
     * @example
     * // Update or create a FileList
     * const fileList = await prisma.fileList.upsert({
     *   create: {
     *     // ... data to create a FileList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileList we want to update
     *   }
     * })
     */
    upsert<T extends FileListUpsertArgs>(args: SelectSubset<T, FileListUpsertArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListCountArgs} args - Arguments to filter FileLists to count.
     * @example
     * // Count the number of FileLists
     * const count = await prisma.fileList.count({
     *   where: {
     *     // ... the filter for the FileLists we want to count
     *   }
     * })
    **/
    count<T extends FileListCountArgs>(
      args?: Subset<T, FileListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileListAggregateArgs>(args: Subset<T, FileListAggregateArgs>): Prisma.PrismaPromise<GetFileListAggregateType<T>>

    /**
     * Group by FileList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileListGroupByArgs['orderBy'] }
        : { orderBy?: FileListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileList model
   */
  readonly fields: FileListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends FileList$userArgs<ExtArgs> = {}>(args?: Subset<T, FileList$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pages<T extends FileList$pagesArgs<ExtArgs> = {}>(args?: Subset<T, FileList$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chunks<T extends FileList$chunksArgs<ExtArgs> = {}>(args?: Subset<T, FileList$chunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileList model
   */
  interface FileListFieldRefs {
    readonly id: FieldRef<"FileList", 'Int'>
    readonly category: FieldRef<"FileList", 'String'>
    readonly title: FieldRef<"FileList", 'String'>
    readonly note: FieldRef<"FileList", 'String'>
    readonly content_format: FieldRef<"FileList", 'String'>
    readonly doc1: FieldRef<"FileList", 'String'>
    readonly entry_date: FieldRef<"FileList", 'String'>
    readonly entry_date_real: FieldRef<"FileList", 'DateTime'>
    readonly created_at: FieldRef<"FileList", 'DateTime'>
    readonly updated_at: FieldRef<"FileList", 'DateTime'>
    readonly user_id: FieldRef<"FileList", 'Int'>
    readonly parsing_status: FieldRef<"FileList", 'String'>
    readonly parsing_error: FieldRef<"FileList", 'String'>
    readonly parsed_at: FieldRef<"FileList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileList findUnique
   */
  export type FileListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * Filter, which FileList to fetch.
     */
    where: FileListWhereUniqueInput
  }

  /**
   * FileList findUniqueOrThrow
   */
  export type FileListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * Filter, which FileList to fetch.
     */
    where: FileListWhereUniqueInput
  }

  /**
   * FileList findFirst
   */
  export type FileListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * Filter, which FileList to fetch.
     */
    where?: FileListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileLists to fetch.
     */
    orderBy?: FileListOrderByWithRelationInput | FileListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileLists.
     */
    cursor?: FileListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileLists.
     */
    distinct?: FileListScalarFieldEnum | FileListScalarFieldEnum[]
  }

  /**
   * FileList findFirstOrThrow
   */
  export type FileListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * Filter, which FileList to fetch.
     */
    where?: FileListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileLists to fetch.
     */
    orderBy?: FileListOrderByWithRelationInput | FileListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileLists.
     */
    cursor?: FileListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileLists.
     */
    distinct?: FileListScalarFieldEnum | FileListScalarFieldEnum[]
  }

  /**
   * FileList findMany
   */
  export type FileListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * Filter, which FileLists to fetch.
     */
    where?: FileListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileLists to fetch.
     */
    orderBy?: FileListOrderByWithRelationInput | FileListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileLists.
     */
    cursor?: FileListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileLists.
     */
    skip?: number
    distinct?: FileListScalarFieldEnum | FileListScalarFieldEnum[]
  }

  /**
   * FileList create
   */
  export type FileListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * The data needed to create a FileList.
     */
    data: XOR<FileListCreateInput, FileListUncheckedCreateInput>
  }

  /**
   * FileList createMany
   */
  export type FileListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileLists.
     */
    data: FileListCreateManyInput | FileListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileList createManyAndReturn
   */
  export type FileListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * The data used to create many FileLists.
     */
    data: FileListCreateManyInput | FileListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileList update
   */
  export type FileListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * The data needed to update a FileList.
     */
    data: XOR<FileListUpdateInput, FileListUncheckedUpdateInput>
    /**
     * Choose, which FileList to update.
     */
    where: FileListWhereUniqueInput
  }

  /**
   * FileList updateMany
   */
  export type FileListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileLists.
     */
    data: XOR<FileListUpdateManyMutationInput, FileListUncheckedUpdateManyInput>
    /**
     * Filter which FileLists to update
     */
    where?: FileListWhereInput
    /**
     * Limit how many FileLists to update.
     */
    limit?: number
  }

  /**
   * FileList updateManyAndReturn
   */
  export type FileListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * The data used to update FileLists.
     */
    data: XOR<FileListUpdateManyMutationInput, FileListUncheckedUpdateManyInput>
    /**
     * Filter which FileLists to update
     */
    where?: FileListWhereInput
    /**
     * Limit how many FileLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileList upsert
   */
  export type FileListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * The filter to search for the FileList to update in case it exists.
     */
    where: FileListWhereUniqueInput
    /**
     * In case the FileList found by the `where` argument doesn't exist, create a new FileList with this data.
     */
    create: XOR<FileListCreateInput, FileListUncheckedCreateInput>
    /**
     * In case the FileList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileListUpdateInput, FileListUncheckedUpdateInput>
  }

  /**
   * FileList delete
   */
  export type FileListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    /**
     * Filter which FileList to delete.
     */
    where: FileListWhereUniqueInput
  }

  /**
   * FileList deleteMany
   */
  export type FileListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileLists to delete
     */
    where?: FileListWhereInput
    /**
     * Limit how many FileLists to delete.
     */
    limit?: number
  }

  /**
   * FileList.user
   */
  export type FileList$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * FileList.pages
   */
  export type FileList$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    where?: DocumentPageWhereInput
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    cursor?: DocumentPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * FileList.chunks
   */
  export type FileList$chunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    where?: FileChunkWhereInput
    orderBy?: FileChunkOrderByWithRelationInput | FileChunkOrderByWithRelationInput[]
    cursor?: FileChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileChunkScalarFieldEnum | FileChunkScalarFieldEnum[]
  }

  /**
   * FileList without action
   */
  export type FileListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
  }


  /**
   * Model DocumentPage
   */

  export type AggregateDocumentPage = {
    _count: DocumentPageCountAggregateOutputType | null
    _avg: DocumentPageAvgAggregateOutputType | null
    _sum: DocumentPageSumAggregateOutputType | null
    _min: DocumentPageMinAggregateOutputType | null
    _max: DocumentPageMaxAggregateOutputType | null
  }

  export type DocumentPageAvgAggregateOutputType = {
    id: number | null
    file_id: number | null
    page_number: number | null
    width: number | null
    height: number | null
  }

  export type DocumentPageSumAggregateOutputType = {
    id: number | null
    file_id: number | null
    page_number: number | null
    width: number | null
    height: number | null
  }

  export type DocumentPageMinAggregateOutputType = {
    id: number | null
    file_id: number | null
    page_number: number | null
    image_url: string | null
    width: number | null
    height: number | null
    created_at: Date | null
  }

  export type DocumentPageMaxAggregateOutputType = {
    id: number | null
    file_id: number | null
    page_number: number | null
    image_url: string | null
    width: number | null
    height: number | null
    created_at: Date | null
  }

  export type DocumentPageCountAggregateOutputType = {
    id: number
    file_id: number
    page_number: number
    image_url: number
    width: number
    height: number
    created_at: number
    _all: number
  }


  export type DocumentPageAvgAggregateInputType = {
    id?: true
    file_id?: true
    page_number?: true
    width?: true
    height?: true
  }

  export type DocumentPageSumAggregateInputType = {
    id?: true
    file_id?: true
    page_number?: true
    width?: true
    height?: true
  }

  export type DocumentPageMinAggregateInputType = {
    id?: true
    file_id?: true
    page_number?: true
    image_url?: true
    width?: true
    height?: true
    created_at?: true
  }

  export type DocumentPageMaxAggregateInputType = {
    id?: true
    file_id?: true
    page_number?: true
    image_url?: true
    width?: true
    height?: true
    created_at?: true
  }

  export type DocumentPageCountAggregateInputType = {
    id?: true
    file_id?: true
    page_number?: true
    image_url?: true
    width?: true
    height?: true
    created_at?: true
    _all?: true
  }

  export type DocumentPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPage to aggregate.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentPages
    **/
    _count?: true | DocumentPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentPageMaxAggregateInputType
  }

  export type GetDocumentPageAggregateType<T extends DocumentPageAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentPage[P]>
      : GetScalarType<T[P], AggregateDocumentPage[P]>
  }




  export type DocumentPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPageWhereInput
    orderBy?: DocumentPageOrderByWithAggregationInput | DocumentPageOrderByWithAggregationInput[]
    by: DocumentPageScalarFieldEnum[] | DocumentPageScalarFieldEnum
    having?: DocumentPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentPageCountAggregateInputType | true
    _avg?: DocumentPageAvgAggregateInputType
    _sum?: DocumentPageSumAggregateInputType
    _min?: DocumentPageMinAggregateInputType
    _max?: DocumentPageMaxAggregateInputType
  }

  export type DocumentPageGroupByOutputType = {
    id: number
    file_id: number
    page_number: number
    image_url: string
    width: number | null
    height: number | null
    created_at: Date
    _count: DocumentPageCountAggregateOutputType | null
    _avg: DocumentPageAvgAggregateOutputType | null
    _sum: DocumentPageSumAggregateOutputType | null
    _min: DocumentPageMinAggregateOutputType | null
    _max: DocumentPageMaxAggregateOutputType | null
  }

  type GetDocumentPageGroupByPayload<T extends DocumentPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentPageGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentPageGroupByOutputType[P]>
        }
      >
    >


  export type DocumentPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPage"]>

  export type DocumentPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPage"]>

  export type DocumentPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPage"]>

  export type DocumentPageSelectScalar = {
    id?: boolean
    file_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
  }

  export type DocumentPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "file_id" | "page_number" | "image_url" | "width" | "height" | "created_at", ExtArgs["result"]["documentPage"]>
  export type DocumentPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }
  export type DocumentPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }
  export type DocumentPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }

  export type $DocumentPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentPage"
    objects: {
      file: Prisma.$FileListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file_id: number
      page_number: number
      image_url: string
      width: number | null
      height: number | null
      created_at: Date
    }, ExtArgs["result"]["documentPage"]>
    composites: {}
  }

  type DocumentPageGetPayload<S extends boolean | null | undefined | DocumentPageDefaultArgs> = $Result.GetResult<Prisma.$DocumentPagePayload, S>

  type DocumentPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentPageCountAggregateInputType | true
    }

  export interface DocumentPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentPage'], meta: { name: 'DocumentPage' } }
    /**
     * Find zero or one DocumentPage that matches the filter.
     * @param {DocumentPageFindUniqueArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentPageFindUniqueArgs>(args: SelectSubset<T, DocumentPageFindUniqueArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentPageFindUniqueOrThrowArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentPageFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageFindFirstArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentPageFindFirstArgs>(args?: SelectSubset<T, DocumentPageFindFirstArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageFindFirstOrThrowArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentPageFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentPages
     * const documentPages = await prisma.documentPage.findMany()
     * 
     * // Get first 10 DocumentPages
     * const documentPages = await prisma.documentPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentPageWithIdOnly = await prisma.documentPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentPageFindManyArgs>(args?: SelectSubset<T, DocumentPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentPage.
     * @param {DocumentPageCreateArgs} args - Arguments to create a DocumentPage.
     * @example
     * // Create one DocumentPage
     * const DocumentPage = await prisma.documentPage.create({
     *   data: {
     *     // ... data to create a DocumentPage
     *   }
     * })
     * 
     */
    create<T extends DocumentPageCreateArgs>(args: SelectSubset<T, DocumentPageCreateArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentPages.
     * @param {DocumentPageCreateManyArgs} args - Arguments to create many DocumentPages.
     * @example
     * // Create many DocumentPages
     * const documentPage = await prisma.documentPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentPageCreateManyArgs>(args?: SelectSubset<T, DocumentPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentPages and returns the data saved in the database.
     * @param {DocumentPageCreateManyAndReturnArgs} args - Arguments to create many DocumentPages.
     * @example
     * // Create many DocumentPages
     * const documentPage = await prisma.documentPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentPages and only return the `id`
     * const documentPageWithIdOnly = await prisma.documentPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentPageCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentPage.
     * @param {DocumentPageDeleteArgs} args - Arguments to delete one DocumentPage.
     * @example
     * // Delete one DocumentPage
     * const DocumentPage = await prisma.documentPage.delete({
     *   where: {
     *     // ... filter to delete one DocumentPage
     *   }
     * })
     * 
     */
    delete<T extends DocumentPageDeleteArgs>(args: SelectSubset<T, DocumentPageDeleteArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentPage.
     * @param {DocumentPageUpdateArgs} args - Arguments to update one DocumentPage.
     * @example
     * // Update one DocumentPage
     * const documentPage = await prisma.documentPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentPageUpdateArgs>(args: SelectSubset<T, DocumentPageUpdateArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentPages.
     * @param {DocumentPageDeleteManyArgs} args - Arguments to filter DocumentPages to delete.
     * @example
     * // Delete a few DocumentPages
     * const { count } = await prisma.documentPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentPageDeleteManyArgs>(args?: SelectSubset<T, DocumentPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentPages
     * const documentPage = await prisma.documentPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentPageUpdateManyArgs>(args: SelectSubset<T, DocumentPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPages and returns the data updated in the database.
     * @param {DocumentPageUpdateManyAndReturnArgs} args - Arguments to update many DocumentPages.
     * @example
     * // Update many DocumentPages
     * const documentPage = await prisma.documentPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentPages and only return the `id`
     * const documentPageWithIdOnly = await prisma.documentPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentPageUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentPage.
     * @param {DocumentPageUpsertArgs} args - Arguments to update or create a DocumentPage.
     * @example
     * // Update or create a DocumentPage
     * const documentPage = await prisma.documentPage.upsert({
     *   create: {
     *     // ... data to create a DocumentPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentPage we want to update
     *   }
     * })
     */
    upsert<T extends DocumentPageUpsertArgs>(args: SelectSubset<T, DocumentPageUpsertArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageCountArgs} args - Arguments to filter DocumentPages to count.
     * @example
     * // Count the number of DocumentPages
     * const count = await prisma.documentPage.count({
     *   where: {
     *     // ... the filter for the DocumentPages we want to count
     *   }
     * })
    **/
    count<T extends DocumentPageCountArgs>(
      args?: Subset<T, DocumentPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentPageAggregateArgs>(args: Subset<T, DocumentPageAggregateArgs>): Prisma.PrismaPromise<GetDocumentPageAggregateType<T>>

    /**
     * Group by DocumentPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentPageGroupByArgs['orderBy'] }
        : { orderBy?: DocumentPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentPage model
   */
  readonly fields: DocumentPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FileListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileListDefaultArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentPage model
   */
  interface DocumentPageFieldRefs {
    readonly id: FieldRef<"DocumentPage", 'Int'>
    readonly file_id: FieldRef<"DocumentPage", 'Int'>
    readonly page_number: FieldRef<"DocumentPage", 'Int'>
    readonly image_url: FieldRef<"DocumentPage", 'String'>
    readonly width: FieldRef<"DocumentPage", 'Int'>
    readonly height: FieldRef<"DocumentPage", 'Int'>
    readonly created_at: FieldRef<"DocumentPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentPage findUnique
   */
  export type DocumentPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage findUniqueOrThrow
   */
  export type DocumentPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage findFirst
   */
  export type DocumentPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPages.
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPages.
     */
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * DocumentPage findFirstOrThrow
   */
  export type DocumentPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPages.
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPages.
     */
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * DocumentPage findMany
   */
  export type DocumentPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPages to fetch.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentPages.
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * DocumentPage create
   */
  export type DocumentPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentPage.
     */
    data: XOR<DocumentPageCreateInput, DocumentPageUncheckedCreateInput>
  }

  /**
   * DocumentPage createMany
   */
  export type DocumentPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentPages.
     */
    data: DocumentPageCreateManyInput | DocumentPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentPage createManyAndReturn
   */
  export type DocumentPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentPages.
     */
    data: DocumentPageCreateManyInput | DocumentPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentPage update
   */
  export type DocumentPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentPage.
     */
    data: XOR<DocumentPageUpdateInput, DocumentPageUncheckedUpdateInput>
    /**
     * Choose, which DocumentPage to update.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage updateMany
   */
  export type DocumentPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentPages.
     */
    data: XOR<DocumentPageUpdateManyMutationInput, DocumentPageUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPages to update
     */
    where?: DocumentPageWhereInput
    /**
     * Limit how many DocumentPages to update.
     */
    limit?: number
  }

  /**
   * DocumentPage updateManyAndReturn
   */
  export type DocumentPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * The data used to update DocumentPages.
     */
    data: XOR<DocumentPageUpdateManyMutationInput, DocumentPageUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPages to update
     */
    where?: DocumentPageWhereInput
    /**
     * Limit how many DocumentPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentPage upsert
   */
  export type DocumentPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentPage to update in case it exists.
     */
    where: DocumentPageWhereUniqueInput
    /**
     * In case the DocumentPage found by the `where` argument doesn't exist, create a new DocumentPage with this data.
     */
    create: XOR<DocumentPageCreateInput, DocumentPageUncheckedCreateInput>
    /**
     * In case the DocumentPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentPageUpdateInput, DocumentPageUncheckedUpdateInput>
  }

  /**
   * DocumentPage delete
   */
  export type DocumentPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter which DocumentPage to delete.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage deleteMany
   */
  export type DocumentPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPages to delete
     */
    where?: DocumentPageWhereInput
    /**
     * Limit how many DocumentPages to delete.
     */
    limit?: number
  }

  /**
   * DocumentPage without action
   */
  export type DocumentPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
  }


  /**
   * Model FileChunk
   */

  export type AggregateFileChunk = {
    _count: FileChunkCountAggregateOutputType | null
    _avg: FileChunkAvgAggregateOutputType | null
    _sum: FileChunkSumAggregateOutputType | null
    _min: FileChunkMinAggregateOutputType | null
    _max: FileChunkMaxAggregateOutputType | null
  }

  export type FileChunkAvgAggregateOutputType = {
    id: number | null
    file_id: number | null
    chunk_index: number | null
    page_number: number | null
    token_count: number | null
  }

  export type FileChunkSumAggregateOutputType = {
    id: number | null
    file_id: number | null
    chunk_index: number | null
    page_number: number | null
    token_count: number | null
  }

  export type FileChunkMinAggregateOutputType = {
    id: number | null
    file_id: number | null
    chunk_index: number | null
    content: string | null
    page_number: number | null
    token_count: number | null
    created_at: Date | null
  }

  export type FileChunkMaxAggregateOutputType = {
    id: number | null
    file_id: number | null
    chunk_index: number | null
    content: string | null
    page_number: number | null
    token_count: number | null
    created_at: Date | null
  }

  export type FileChunkCountAggregateOutputType = {
    id: number
    file_id: number
    chunk_index: number
    content: number
    page_number: number
    bbox: number
    token_count: number
    created_at: number
    _all: number
  }


  export type FileChunkAvgAggregateInputType = {
    id?: true
    file_id?: true
    chunk_index?: true
    page_number?: true
    token_count?: true
  }

  export type FileChunkSumAggregateInputType = {
    id?: true
    file_id?: true
    chunk_index?: true
    page_number?: true
    token_count?: true
  }

  export type FileChunkMinAggregateInputType = {
    id?: true
    file_id?: true
    chunk_index?: true
    content?: true
    page_number?: true
    token_count?: true
    created_at?: true
  }

  export type FileChunkMaxAggregateInputType = {
    id?: true
    file_id?: true
    chunk_index?: true
    content?: true
    page_number?: true
    token_count?: true
    created_at?: true
  }

  export type FileChunkCountAggregateInputType = {
    id?: true
    file_id?: true
    chunk_index?: true
    content?: true
    page_number?: true
    bbox?: true
    token_count?: true
    created_at?: true
    _all?: true
  }

  export type FileChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileChunk to aggregate.
     */
    where?: FileChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileChunks to fetch.
     */
    orderBy?: FileChunkOrderByWithRelationInput | FileChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileChunks
    **/
    _count?: true | FileChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileChunkMaxAggregateInputType
  }

  export type GetFileChunkAggregateType<T extends FileChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateFileChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileChunk[P]>
      : GetScalarType<T[P], AggregateFileChunk[P]>
  }




  export type FileChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileChunkWhereInput
    orderBy?: FileChunkOrderByWithAggregationInput | FileChunkOrderByWithAggregationInput[]
    by: FileChunkScalarFieldEnum[] | FileChunkScalarFieldEnum
    having?: FileChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileChunkCountAggregateInputType | true
    _avg?: FileChunkAvgAggregateInputType
    _sum?: FileChunkSumAggregateInputType
    _min?: FileChunkMinAggregateInputType
    _max?: FileChunkMaxAggregateInputType
  }

  export type FileChunkGroupByOutputType = {
    id: number
    file_id: number
    chunk_index: number
    content: string
    page_number: number | null
    bbox: JsonValue | null
    token_count: number | null
    created_at: Date
    _count: FileChunkCountAggregateOutputType | null
    _avg: FileChunkAvgAggregateOutputType | null
    _sum: FileChunkSumAggregateOutputType | null
    _min: FileChunkMinAggregateOutputType | null
    _max: FileChunkMaxAggregateOutputType | null
  }

  type GetFileChunkGroupByPayload<T extends FileChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileChunkGroupByOutputType[P]>
            : GetScalarType<T[P], FileChunkGroupByOutputType[P]>
        }
      >
    >


  export type FileChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    token_count?: boolean
    created_at?: boolean
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileChunk"]>

  export type FileChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    token_count?: boolean
    created_at?: boolean
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileChunk"]>

  export type FileChunkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    token_count?: boolean
    created_at?: boolean
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileChunk"]>

  export type FileChunkSelectScalar = {
    id?: boolean
    file_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    token_count?: boolean
    created_at?: boolean
  }

  export type FileChunkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "file_id" | "chunk_index" | "content" | "page_number" | "bbox" | "token_count" | "created_at", ExtArgs["result"]["fileChunk"]>
  export type FileChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }
  export type FileChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }
  export type FileChunkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileListDefaultArgs<ExtArgs>
  }

  export type $FileChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileChunk"
    objects: {
      file: Prisma.$FileListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file_id: number
      chunk_index: number
      content: string
      page_number: number | null
      bbox: Prisma.JsonValue | null
      token_count: number | null
      created_at: Date
    }, ExtArgs["result"]["fileChunk"]>
    composites: {}
  }

  type FileChunkGetPayload<S extends boolean | null | undefined | FileChunkDefaultArgs> = $Result.GetResult<Prisma.$FileChunkPayload, S>

  type FileChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileChunkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileChunkCountAggregateInputType | true
    }

  export interface FileChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileChunk'], meta: { name: 'FileChunk' } }
    /**
     * Find zero or one FileChunk that matches the filter.
     * @param {FileChunkFindUniqueArgs} args - Arguments to find a FileChunk
     * @example
     * // Get one FileChunk
     * const fileChunk = await prisma.fileChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileChunkFindUniqueArgs>(args: SelectSubset<T, FileChunkFindUniqueArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileChunk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileChunkFindUniqueOrThrowArgs} args - Arguments to find a FileChunk
     * @example
     * // Get one FileChunk
     * const fileChunk = await prisma.fileChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, FileChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkFindFirstArgs} args - Arguments to find a FileChunk
     * @example
     * // Get one FileChunk
     * const fileChunk = await prisma.fileChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileChunkFindFirstArgs>(args?: SelectSubset<T, FileChunkFindFirstArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkFindFirstOrThrowArgs} args - Arguments to find a FileChunk
     * @example
     * // Get one FileChunk
     * const fileChunk = await prisma.fileChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, FileChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileChunks
     * const fileChunks = await prisma.fileChunk.findMany()
     * 
     * // Get first 10 FileChunks
     * const fileChunks = await prisma.fileChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileChunkWithIdOnly = await prisma.fileChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileChunkFindManyArgs>(args?: SelectSubset<T, FileChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileChunk.
     * @param {FileChunkCreateArgs} args - Arguments to create a FileChunk.
     * @example
     * // Create one FileChunk
     * const FileChunk = await prisma.fileChunk.create({
     *   data: {
     *     // ... data to create a FileChunk
     *   }
     * })
     * 
     */
    create<T extends FileChunkCreateArgs>(args: SelectSubset<T, FileChunkCreateArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileChunks.
     * @param {FileChunkCreateManyArgs} args - Arguments to create many FileChunks.
     * @example
     * // Create many FileChunks
     * const fileChunk = await prisma.fileChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileChunkCreateManyArgs>(args?: SelectSubset<T, FileChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileChunks and returns the data saved in the database.
     * @param {FileChunkCreateManyAndReturnArgs} args - Arguments to create many FileChunks.
     * @example
     * // Create many FileChunks
     * const fileChunk = await prisma.fileChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileChunks and only return the `id`
     * const fileChunkWithIdOnly = await prisma.fileChunk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, FileChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileChunk.
     * @param {FileChunkDeleteArgs} args - Arguments to delete one FileChunk.
     * @example
     * // Delete one FileChunk
     * const FileChunk = await prisma.fileChunk.delete({
     *   where: {
     *     // ... filter to delete one FileChunk
     *   }
     * })
     * 
     */
    delete<T extends FileChunkDeleteArgs>(args: SelectSubset<T, FileChunkDeleteArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileChunk.
     * @param {FileChunkUpdateArgs} args - Arguments to update one FileChunk.
     * @example
     * // Update one FileChunk
     * const fileChunk = await prisma.fileChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileChunkUpdateArgs>(args: SelectSubset<T, FileChunkUpdateArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileChunks.
     * @param {FileChunkDeleteManyArgs} args - Arguments to filter FileChunks to delete.
     * @example
     * // Delete a few FileChunks
     * const { count } = await prisma.fileChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileChunkDeleteManyArgs>(args?: SelectSubset<T, FileChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileChunks
     * const fileChunk = await prisma.fileChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileChunkUpdateManyArgs>(args: SelectSubset<T, FileChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileChunks and returns the data updated in the database.
     * @param {FileChunkUpdateManyAndReturnArgs} args - Arguments to update many FileChunks.
     * @example
     * // Update many FileChunks
     * const fileChunk = await prisma.fileChunk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileChunks and only return the `id`
     * const fileChunkWithIdOnly = await prisma.fileChunk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileChunkUpdateManyAndReturnArgs>(args: SelectSubset<T, FileChunkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileChunk.
     * @param {FileChunkUpsertArgs} args - Arguments to update or create a FileChunk.
     * @example
     * // Update or create a FileChunk
     * const fileChunk = await prisma.fileChunk.upsert({
     *   create: {
     *     // ... data to create a FileChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileChunk we want to update
     *   }
     * })
     */
    upsert<T extends FileChunkUpsertArgs>(args: SelectSubset<T, FileChunkUpsertArgs<ExtArgs>>): Prisma__FileChunkClient<$Result.GetResult<Prisma.$FileChunkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkCountArgs} args - Arguments to filter FileChunks to count.
     * @example
     * // Count the number of FileChunks
     * const count = await prisma.fileChunk.count({
     *   where: {
     *     // ... the filter for the FileChunks we want to count
     *   }
     * })
    **/
    count<T extends FileChunkCountArgs>(
      args?: Subset<T, FileChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileChunkAggregateArgs>(args: Subset<T, FileChunkAggregateArgs>): Prisma.PrismaPromise<GetFileChunkAggregateType<T>>

    /**
     * Group by FileChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileChunkGroupByArgs['orderBy'] }
        : { orderBy?: FileChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileChunk model
   */
  readonly fields: FileChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FileListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileListDefaultArgs<ExtArgs>>): Prisma__FileListClient<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileChunk model
   */
  interface FileChunkFieldRefs {
    readonly id: FieldRef<"FileChunk", 'Int'>
    readonly file_id: FieldRef<"FileChunk", 'Int'>
    readonly chunk_index: FieldRef<"FileChunk", 'Int'>
    readonly content: FieldRef<"FileChunk", 'String'>
    readonly page_number: FieldRef<"FileChunk", 'Int'>
    readonly bbox: FieldRef<"FileChunk", 'Json'>
    readonly token_count: FieldRef<"FileChunk", 'Int'>
    readonly created_at: FieldRef<"FileChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileChunk findUnique
   */
  export type FileChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * Filter, which FileChunk to fetch.
     */
    where: FileChunkWhereUniqueInput
  }

  /**
   * FileChunk findUniqueOrThrow
   */
  export type FileChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * Filter, which FileChunk to fetch.
     */
    where: FileChunkWhereUniqueInput
  }

  /**
   * FileChunk findFirst
   */
  export type FileChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * Filter, which FileChunk to fetch.
     */
    where?: FileChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileChunks to fetch.
     */
    orderBy?: FileChunkOrderByWithRelationInput | FileChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileChunks.
     */
    cursor?: FileChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileChunks.
     */
    distinct?: FileChunkScalarFieldEnum | FileChunkScalarFieldEnum[]
  }

  /**
   * FileChunk findFirstOrThrow
   */
  export type FileChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * Filter, which FileChunk to fetch.
     */
    where?: FileChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileChunks to fetch.
     */
    orderBy?: FileChunkOrderByWithRelationInput | FileChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileChunks.
     */
    cursor?: FileChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileChunks.
     */
    distinct?: FileChunkScalarFieldEnum | FileChunkScalarFieldEnum[]
  }

  /**
   * FileChunk findMany
   */
  export type FileChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * Filter, which FileChunks to fetch.
     */
    where?: FileChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileChunks to fetch.
     */
    orderBy?: FileChunkOrderByWithRelationInput | FileChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileChunks.
     */
    cursor?: FileChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileChunks.
     */
    skip?: number
    distinct?: FileChunkScalarFieldEnum | FileChunkScalarFieldEnum[]
  }

  /**
   * FileChunk create
   */
  export type FileChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a FileChunk.
     */
    data: XOR<FileChunkCreateInput, FileChunkUncheckedCreateInput>
  }

  /**
   * FileChunk createMany
   */
  export type FileChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileChunks.
     */
    data: FileChunkCreateManyInput | FileChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileChunk createManyAndReturn
   */
  export type FileChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * The data used to create many FileChunks.
     */
    data: FileChunkCreateManyInput | FileChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileChunk update
   */
  export type FileChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a FileChunk.
     */
    data: XOR<FileChunkUpdateInput, FileChunkUncheckedUpdateInput>
    /**
     * Choose, which FileChunk to update.
     */
    where: FileChunkWhereUniqueInput
  }

  /**
   * FileChunk updateMany
   */
  export type FileChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileChunks.
     */
    data: XOR<FileChunkUpdateManyMutationInput, FileChunkUncheckedUpdateManyInput>
    /**
     * Filter which FileChunks to update
     */
    where?: FileChunkWhereInput
    /**
     * Limit how many FileChunks to update.
     */
    limit?: number
  }

  /**
   * FileChunk updateManyAndReturn
   */
  export type FileChunkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * The data used to update FileChunks.
     */
    data: XOR<FileChunkUpdateManyMutationInput, FileChunkUncheckedUpdateManyInput>
    /**
     * Filter which FileChunks to update
     */
    where?: FileChunkWhereInput
    /**
     * Limit how many FileChunks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileChunk upsert
   */
  export type FileChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the FileChunk to update in case it exists.
     */
    where: FileChunkWhereUniqueInput
    /**
     * In case the FileChunk found by the `where` argument doesn't exist, create a new FileChunk with this data.
     */
    create: XOR<FileChunkCreateInput, FileChunkUncheckedCreateInput>
    /**
     * In case the FileChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileChunkUpdateInput, FileChunkUncheckedUpdateInput>
  }

  /**
   * FileChunk delete
   */
  export type FileChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
    /**
     * Filter which FileChunk to delete.
     */
    where: FileChunkWhereUniqueInput
  }

  /**
   * FileChunk deleteMany
   */
  export type FileChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileChunks to delete
     */
    where?: FileChunkWhereInput
    /**
     * Limit how many FileChunks to delete.
     */
    limit?: number
  }

  /**
   * FileChunk without action
   */
  export type FileChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileChunk
     */
    select?: FileChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileChunk
     */
    omit?: FileChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileChunkInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password_hash: string | null
    role: $Enums.UserRole | null
    is_active: boolean | null
    last_login: Date | null
    created_at: Date | null
    email: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password_hash: string | null
    role: $Enums.UserRole | null
    is_active: boolean | null
    last_login: Date | null
    created_at: Date | null
    email: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password_hash: number
    role: number
    is_active: number
    last_login: number
    created_at: number
    email: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    created_at?: true
    email?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    created_at?: true
    email?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    created_at?: true
    email?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password_hash: string | null
    role: $Enums.UserRole
    is_active: boolean | null
    last_login: Date | null
    created_at: Date | null
    email: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
    categories?: boolean | user$categoriesArgs<ExtArgs>
    conversations?: boolean | user$conversationsArgs<ExtArgs>
    files?: boolean | user$filesArgs<ExtArgs>
    usage_tracking?: boolean | user$usage_trackingArgs<ExtArgs>
    subscription?: boolean | user$subscriptionArgs<ExtArgs>
    profile?: boolean | user$profileArgs<ExtArgs>
    quizzes?: boolean | user$quizzesArgs<ExtArgs>
    points?: boolean | user$pointsArgs<ExtArgs>
    badges?: boolean | user$badgesArgs<ExtArgs>
    learning_sessions?: boolean | user$learning_sessionsArgs<ExtArgs>
    created_battles?: boolean | user$created_battlesArgs<ExtArgs>
    battle_participations?: boolean | user$battle_participationsArgs<ExtArgs>
    textbooks_created?: boolean | user$textbooks_createdArgs<ExtArgs>
    enrollments?: boolean | user$enrollmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password_hash" | "role" | "is_active" | "last_login" | "created_at" | "email", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | user$categoriesArgs<ExtArgs>
    conversations?: boolean | user$conversationsArgs<ExtArgs>
    files?: boolean | user$filesArgs<ExtArgs>
    usage_tracking?: boolean | user$usage_trackingArgs<ExtArgs>
    subscription?: boolean | user$subscriptionArgs<ExtArgs>
    profile?: boolean | user$profileArgs<ExtArgs>
    quizzes?: boolean | user$quizzesArgs<ExtArgs>
    points?: boolean | user$pointsArgs<ExtArgs>
    badges?: boolean | user$badgesArgs<ExtArgs>
    learning_sessions?: boolean | user$learning_sessionsArgs<ExtArgs>
    created_battles?: boolean | user$created_battlesArgs<ExtArgs>
    battle_participations?: boolean | user$battle_participationsArgs<ExtArgs>
    textbooks_created?: boolean | user$textbooks_createdArgs<ExtArgs>
    enrollments?: boolean | user$enrollmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      categories: Prisma.$CategoryListPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      files: Prisma.$FileListPayload<ExtArgs>[]
      usage_tracking: Prisma.$UsageTrackingPayload<ExtArgs>[]
      subscription: Prisma.$UserSubscriptionPayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      points: Prisma.$UserPointsPayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      learning_sessions: Prisma.$LearningSessionPayload<ExtArgs>[]
      created_battles: Prisma.$BattlePayload<ExtArgs>[]
      battle_participations: Prisma.$BattleParticipantPayload<ExtArgs>[]
      textbooks_created: Prisma.$TextbookPayload<ExtArgs>[]
      enrollments: Prisma.$UserEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password_hash: string | null
      role: $Enums.UserRole
      is_active: boolean | null
      last_login: Date | null
      created_at: Date | null
      email: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends user$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, user$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends user$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, user$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends user$filesArgs<ExtArgs> = {}>(args?: Subset<T, user$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usage_tracking<T extends user$usage_trackingArgs<ExtArgs> = {}>(args?: Subset<T, user$usage_trackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends user$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, user$subscriptionArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends user$profileArgs<ExtArgs> = {}>(args?: Subset<T, user$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quizzes<T extends user$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, user$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    points<T extends user$pointsArgs<ExtArgs> = {}>(args?: Subset<T, user$pointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends user$badgesArgs<ExtArgs> = {}>(args?: Subset<T, user$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learning_sessions<T extends user$learning_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, user$learning_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    created_battles<T extends user$created_battlesArgs<ExtArgs> = {}>(args?: Subset<T, user$created_battlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    battle_participations<T extends user$battle_participationsArgs<ExtArgs> = {}>(args?: Subset<T, user$battle_participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    textbooks_created<T extends user$textbooks_createdArgs<ExtArgs> = {}>(args?: Subset<T, user$textbooks_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends user$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, user$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly username: FieldRef<"user", 'String'>
    readonly password_hash: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'UserRole'>
    readonly is_active: FieldRef<"user", 'Boolean'>
    readonly last_login: FieldRef<"user", 'DateTime'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly email: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.categories
   */
  export type user$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryList
     */
    select?: CategoryListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryList
     */
    omit?: CategoryListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryListInclude<ExtArgs> | null
    where?: CategoryListWhereInput
    orderBy?: CategoryListOrderByWithRelationInput | CategoryListOrderByWithRelationInput[]
    cursor?: CategoryListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryListScalarFieldEnum | CategoryListScalarFieldEnum[]
  }

  /**
   * user.conversations
   */
  export type user$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * user.files
   */
  export type user$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileList
     */
    select?: FileListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileList
     */
    omit?: FileListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileListInclude<ExtArgs> | null
    where?: FileListWhereInput
    orderBy?: FileListOrderByWithRelationInput | FileListOrderByWithRelationInput[]
    cursor?: FileListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileListScalarFieldEnum | FileListScalarFieldEnum[]
  }

  /**
   * user.usage_tracking
   */
  export type user$usage_trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    where?: UsageTrackingWhereInput
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    cursor?: UsageTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * user.subscription
   */
  export type user$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
  }

  /**
   * user.profile
   */
  export type user$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * user.quizzes
   */
  export type user$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * user.points
   */
  export type user$pointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    where?: UserPointsWhereInput
    orderBy?: UserPointsOrderByWithRelationInput | UserPointsOrderByWithRelationInput[]
    cursor?: UserPointsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPointsScalarFieldEnum | UserPointsScalarFieldEnum[]
  }

  /**
   * user.badges
   */
  export type user$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * user.learning_sessions
   */
  export type user$learning_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    cursor?: LearningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * user.created_battles
   */
  export type user$created_battlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * user.battle_participations
   */
  export type user$battle_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    where?: BattleParticipantWhereInput
    orderBy?: BattleParticipantOrderByWithRelationInput | BattleParticipantOrderByWithRelationInput[]
    cursor?: BattleParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleParticipantScalarFieldEnum | BattleParticipantScalarFieldEnum[]
  }

  /**
   * user.textbooks_created
   */
  export type user$textbooks_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    where?: TextbookWhereInput
    orderBy?: TextbookOrderByWithRelationInput | TextbookOrderByWithRelationInput[]
    cursor?: TextbookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextbookScalarFieldEnum | TextbookScalarFieldEnum[]
  }

  /**
   * user.enrollments
   */
  export type user$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    where?: UserEnrollmentWhereInput
    orderBy?: UserEnrollmentOrderByWithRelationInput | UserEnrollmentOrderByWithRelationInput[]
    cursor?: UserEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEnrollmentScalarFieldEnum | UserEnrollmentScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model UserEnrollment
   */

  export type AggregateUserEnrollment = {
    _count: UserEnrollmentCountAggregateOutputType | null
    _avg: UserEnrollmentAvgAggregateOutputType | null
    _sum: UserEnrollmentSumAggregateOutputType | null
    _min: UserEnrollmentMinAggregateOutputType | null
    _max: UserEnrollmentMaxAggregateOutputType | null
  }

  export type UserEnrollmentAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    textbook_id: number | null
    progress: number | null
  }

  export type UserEnrollmentSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    textbook_id: number | null
    progress: number | null
  }

  export type UserEnrollmentMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    textbook_id: number | null
    status: string | null
    progress: number | null
    last_accessed_at: Date | null
    enrolled_at: Date | null
    completed_at: Date | null
  }

  export type UserEnrollmentMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    textbook_id: number | null
    status: string | null
    progress: number | null
    last_accessed_at: Date | null
    enrolled_at: Date | null
    completed_at: Date | null
  }

  export type UserEnrollmentCountAggregateOutputType = {
    id: number
    user_id: number
    textbook_id: number
    status: number
    progress: number
    last_accessed_at: number
    enrolled_at: number
    completed_at: number
    _all: number
  }


  export type UserEnrollmentAvgAggregateInputType = {
    id?: true
    user_id?: true
    textbook_id?: true
    progress?: true
  }

  export type UserEnrollmentSumAggregateInputType = {
    id?: true
    user_id?: true
    textbook_id?: true
    progress?: true
  }

  export type UserEnrollmentMinAggregateInputType = {
    id?: true
    user_id?: true
    textbook_id?: true
    status?: true
    progress?: true
    last_accessed_at?: true
    enrolled_at?: true
    completed_at?: true
  }

  export type UserEnrollmentMaxAggregateInputType = {
    id?: true
    user_id?: true
    textbook_id?: true
    status?: true
    progress?: true
    last_accessed_at?: true
    enrolled_at?: true
    completed_at?: true
  }

  export type UserEnrollmentCountAggregateInputType = {
    id?: true
    user_id?: true
    textbook_id?: true
    status?: true
    progress?: true
    last_accessed_at?: true
    enrolled_at?: true
    completed_at?: true
    _all?: true
  }

  export type UserEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEnrollment to aggregate.
     */
    where?: UserEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnrollments to fetch.
     */
    orderBy?: UserEnrollmentOrderByWithRelationInput | UserEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEnrollments
    **/
    _count?: true | UserEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEnrollmentMaxAggregateInputType
  }

  export type GetUserEnrollmentAggregateType<T extends UserEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEnrollment[P]>
      : GetScalarType<T[P], AggregateUserEnrollment[P]>
  }




  export type UserEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEnrollmentWhereInput
    orderBy?: UserEnrollmentOrderByWithAggregationInput | UserEnrollmentOrderByWithAggregationInput[]
    by: UserEnrollmentScalarFieldEnum[] | UserEnrollmentScalarFieldEnum
    having?: UserEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEnrollmentCountAggregateInputType | true
    _avg?: UserEnrollmentAvgAggregateInputType
    _sum?: UserEnrollmentSumAggregateInputType
    _min?: UserEnrollmentMinAggregateInputType
    _max?: UserEnrollmentMaxAggregateInputType
  }

  export type UserEnrollmentGroupByOutputType = {
    id: number
    user_id: number
    textbook_id: number
    status: string
    progress: number
    last_accessed_at: Date | null
    enrolled_at: Date
    completed_at: Date | null
    _count: UserEnrollmentCountAggregateOutputType | null
    _avg: UserEnrollmentAvgAggregateOutputType | null
    _sum: UserEnrollmentSumAggregateOutputType | null
    _min: UserEnrollmentMinAggregateOutputType | null
    _max: UserEnrollmentMaxAggregateOutputType | null
  }

  type GetUserEnrollmentGroupByPayload<T extends UserEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], UserEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type UserEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    textbook_id?: boolean
    status?: boolean
    progress?: boolean
    last_accessed_at?: boolean
    enrolled_at?: boolean
    completed_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEnrollment"]>

  export type UserEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    textbook_id?: boolean
    status?: boolean
    progress?: boolean
    last_accessed_at?: boolean
    enrolled_at?: boolean
    completed_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEnrollment"]>

  export type UserEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    textbook_id?: boolean
    status?: boolean
    progress?: boolean
    last_accessed_at?: boolean
    enrolled_at?: boolean
    completed_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEnrollment"]>

  export type UserEnrollmentSelectScalar = {
    id?: boolean
    user_id?: boolean
    textbook_id?: boolean
    status?: boolean
    progress?: boolean
    last_accessed_at?: boolean
    enrolled_at?: boolean
    completed_at?: boolean
  }

  export type UserEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "textbook_id" | "status" | "progress" | "last_accessed_at" | "enrolled_at" | "completed_at", ExtArgs["result"]["userEnrollment"]>
  export type UserEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }
  export type UserEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }
  export type UserEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }

  export type $UserEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEnrollment"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      textbook: Prisma.$TextbookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      textbook_id: number
      status: string
      progress: number
      last_accessed_at: Date | null
      enrolled_at: Date
      completed_at: Date | null
    }, ExtArgs["result"]["userEnrollment"]>
    composites: {}
  }

  type UserEnrollmentGetPayload<S extends boolean | null | undefined | UserEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$UserEnrollmentPayload, S>

  type UserEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserEnrollmentCountAggregateInputType | true
    }

  export interface UserEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEnrollment'], meta: { name: 'UserEnrollment' } }
    /**
     * Find zero or one UserEnrollment that matches the filter.
     * @param {UserEnrollmentFindUniqueArgs} args - Arguments to find a UserEnrollment
     * @example
     * // Get one UserEnrollment
     * const userEnrollment = await prisma.userEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEnrollmentFindUniqueArgs>(args: SelectSubset<T, UserEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a UserEnrollment
     * @example
     * // Get one UserEnrollment
     * const userEnrollment = await prisma.userEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentFindFirstArgs} args - Arguments to find a UserEnrollment
     * @example
     * // Get one UserEnrollment
     * const userEnrollment = await prisma.userEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEnrollmentFindFirstArgs>(args?: SelectSubset<T, UserEnrollmentFindFirstArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentFindFirstOrThrowArgs} args - Arguments to find a UserEnrollment
     * @example
     * // Get one UserEnrollment
     * const userEnrollment = await prisma.userEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEnrollments
     * const userEnrollments = await prisma.userEnrollment.findMany()
     * 
     * // Get first 10 UserEnrollments
     * const userEnrollments = await prisma.userEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEnrollmentWithIdOnly = await prisma.userEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserEnrollmentFindManyArgs>(args?: SelectSubset<T, UserEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserEnrollment.
     * @param {UserEnrollmentCreateArgs} args - Arguments to create a UserEnrollment.
     * @example
     * // Create one UserEnrollment
     * const UserEnrollment = await prisma.userEnrollment.create({
     *   data: {
     *     // ... data to create a UserEnrollment
     *   }
     * })
     * 
     */
    create<T extends UserEnrollmentCreateArgs>(args: SelectSubset<T, UserEnrollmentCreateArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserEnrollments.
     * @param {UserEnrollmentCreateManyArgs} args - Arguments to create many UserEnrollments.
     * @example
     * // Create many UserEnrollments
     * const userEnrollment = await prisma.userEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEnrollmentCreateManyArgs>(args?: SelectSubset<T, UserEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEnrollments and returns the data saved in the database.
     * @param {UserEnrollmentCreateManyAndReturnArgs} args - Arguments to create many UserEnrollments.
     * @example
     * // Create many UserEnrollments
     * const userEnrollment = await prisma.userEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEnrollments and only return the `id`
     * const userEnrollmentWithIdOnly = await prisma.userEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserEnrollment.
     * @param {UserEnrollmentDeleteArgs} args - Arguments to delete one UserEnrollment.
     * @example
     * // Delete one UserEnrollment
     * const UserEnrollment = await prisma.userEnrollment.delete({
     *   where: {
     *     // ... filter to delete one UserEnrollment
     *   }
     * })
     * 
     */
    delete<T extends UserEnrollmentDeleteArgs>(args: SelectSubset<T, UserEnrollmentDeleteArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserEnrollment.
     * @param {UserEnrollmentUpdateArgs} args - Arguments to update one UserEnrollment.
     * @example
     * // Update one UserEnrollment
     * const userEnrollment = await prisma.userEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEnrollmentUpdateArgs>(args: SelectSubset<T, UserEnrollmentUpdateArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserEnrollments.
     * @param {UserEnrollmentDeleteManyArgs} args - Arguments to filter UserEnrollments to delete.
     * @example
     * // Delete a few UserEnrollments
     * const { count } = await prisma.userEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEnrollmentDeleteManyArgs>(args?: SelectSubset<T, UserEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEnrollments
     * const userEnrollment = await prisma.userEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEnrollmentUpdateManyArgs>(args: SelectSubset<T, UserEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEnrollments and returns the data updated in the database.
     * @param {UserEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many UserEnrollments.
     * @example
     * // Update many UserEnrollments
     * const userEnrollment = await prisma.userEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserEnrollments and only return the `id`
     * const userEnrollmentWithIdOnly = await prisma.userEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserEnrollment.
     * @param {UserEnrollmentUpsertArgs} args - Arguments to update or create a UserEnrollment.
     * @example
     * // Update or create a UserEnrollment
     * const userEnrollment = await prisma.userEnrollment.upsert({
     *   create: {
     *     // ... data to create a UserEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends UserEnrollmentUpsertArgs>(args: SelectSubset<T, UserEnrollmentUpsertArgs<ExtArgs>>): Prisma__UserEnrollmentClient<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentCountArgs} args - Arguments to filter UserEnrollments to count.
     * @example
     * // Count the number of UserEnrollments
     * const count = await prisma.userEnrollment.count({
     *   where: {
     *     // ... the filter for the UserEnrollments we want to count
     *   }
     * })
    **/
    count<T extends UserEnrollmentCountArgs>(
      args?: Subset<T, UserEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEnrollmentAggregateArgs>(args: Subset<T, UserEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetUserEnrollmentAggregateType<T>>

    /**
     * Group by UserEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: UserEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEnrollment model
   */
  readonly fields: UserEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    textbook<T extends TextbookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TextbookDefaultArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEnrollment model
   */
  interface UserEnrollmentFieldRefs {
    readonly id: FieldRef<"UserEnrollment", 'Int'>
    readonly user_id: FieldRef<"UserEnrollment", 'Int'>
    readonly textbook_id: FieldRef<"UserEnrollment", 'Int'>
    readonly status: FieldRef<"UserEnrollment", 'String'>
    readonly progress: FieldRef<"UserEnrollment", 'Int'>
    readonly last_accessed_at: FieldRef<"UserEnrollment", 'DateTime'>
    readonly enrolled_at: FieldRef<"UserEnrollment", 'DateTime'>
    readonly completed_at: FieldRef<"UserEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEnrollment findUnique
   */
  export type UserEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserEnrollment to fetch.
     */
    where: UserEnrollmentWhereUniqueInput
  }

  /**
   * UserEnrollment findUniqueOrThrow
   */
  export type UserEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserEnrollment to fetch.
     */
    where: UserEnrollmentWhereUniqueInput
  }

  /**
   * UserEnrollment findFirst
   */
  export type UserEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserEnrollment to fetch.
     */
    where?: UserEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnrollments to fetch.
     */
    orderBy?: UserEnrollmentOrderByWithRelationInput | UserEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEnrollments.
     */
    cursor?: UserEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEnrollments.
     */
    distinct?: UserEnrollmentScalarFieldEnum | UserEnrollmentScalarFieldEnum[]
  }

  /**
   * UserEnrollment findFirstOrThrow
   */
  export type UserEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserEnrollment to fetch.
     */
    where?: UserEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnrollments to fetch.
     */
    orderBy?: UserEnrollmentOrderByWithRelationInput | UserEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEnrollments.
     */
    cursor?: UserEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEnrollments.
     */
    distinct?: UserEnrollmentScalarFieldEnum | UserEnrollmentScalarFieldEnum[]
  }

  /**
   * UserEnrollment findMany
   */
  export type UserEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserEnrollments to fetch.
     */
    where?: UserEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnrollments to fetch.
     */
    orderBy?: UserEnrollmentOrderByWithRelationInput | UserEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEnrollments.
     */
    cursor?: UserEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnrollments.
     */
    skip?: number
    distinct?: UserEnrollmentScalarFieldEnum | UserEnrollmentScalarFieldEnum[]
  }

  /**
   * UserEnrollment create
   */
  export type UserEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEnrollment.
     */
    data: XOR<UserEnrollmentCreateInput, UserEnrollmentUncheckedCreateInput>
  }

  /**
   * UserEnrollment createMany
   */
  export type UserEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEnrollments.
     */
    data: UserEnrollmentCreateManyInput | UserEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEnrollment createManyAndReturn
   */
  export type UserEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many UserEnrollments.
     */
    data: UserEnrollmentCreateManyInput | UserEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEnrollment update
   */
  export type UserEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEnrollment.
     */
    data: XOR<UserEnrollmentUpdateInput, UserEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which UserEnrollment to update.
     */
    where: UserEnrollmentWhereUniqueInput
  }

  /**
   * UserEnrollment updateMany
   */
  export type UserEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEnrollments.
     */
    data: XOR<UserEnrollmentUpdateManyMutationInput, UserEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which UserEnrollments to update
     */
    where?: UserEnrollmentWhereInput
    /**
     * Limit how many UserEnrollments to update.
     */
    limit?: number
  }

  /**
   * UserEnrollment updateManyAndReturn
   */
  export type UserEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update UserEnrollments.
     */
    data: XOR<UserEnrollmentUpdateManyMutationInput, UserEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which UserEnrollments to update
     */
    where?: UserEnrollmentWhereInput
    /**
     * Limit how many UserEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEnrollment upsert
   */
  export type UserEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEnrollment to update in case it exists.
     */
    where: UserEnrollmentWhereUniqueInput
    /**
     * In case the UserEnrollment found by the `where` argument doesn't exist, create a new UserEnrollment with this data.
     */
    create: XOR<UserEnrollmentCreateInput, UserEnrollmentUncheckedCreateInput>
    /**
     * In case the UserEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEnrollmentUpdateInput, UserEnrollmentUncheckedUpdateInput>
  }

  /**
   * UserEnrollment delete
   */
  export type UserEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which UserEnrollment to delete.
     */
    where: UserEnrollmentWhereUniqueInput
  }

  /**
   * UserEnrollment deleteMany
   */
  export type UserEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEnrollments to delete
     */
    where?: UserEnrollmentWhereInput
    /**
     * Limit how many UserEnrollments to delete.
     */
    limit?: number
  }

  /**
   * UserEnrollment without action
   */
  export type UserEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    message_count: number | null
    subject_id: number | null
    chapter_id: number | null
  }

  export type ConversationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    message_count: number | null
    subject_id: number | null
    chapter_id: bigint | null
  }

  export type ConversationMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    created_at: Date | null
    updated_at: Date | null
    last_message_at: Date | null
    message_count: number | null
    is_pinned: boolean | null
    is_archived: boolean | null
    subject_id: number | null
    chapter_id: bigint | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    created_at: Date | null
    updated_at: Date | null
    last_message_at: Date | null
    message_count: number | null
    is_pinned: boolean | null
    is_archived: boolean | null
    subject_id: number | null
    chapter_id: bigint | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    created_at: number
    updated_at: number
    last_message_at: number
    message_count: number
    is_pinned: number
    is_archived: number
    subject_id: number
    chapter_id: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    id?: true
    user_id?: true
    message_count?: true
    subject_id?: true
    chapter_id?: true
  }

  export type ConversationSumAggregateInputType = {
    id?: true
    user_id?: true
    message_count?: true
    subject_id?: true
    chapter_id?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    created_at?: true
    updated_at?: true
    last_message_at?: true
    message_count?: true
    is_pinned?: true
    is_archived?: true
    subject_id?: true
    chapter_id?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    created_at?: true
    updated_at?: true
    last_message_at?: true
    message_count?: true
    is_pinned?: true
    is_archived?: true
    subject_id?: true
    chapter_id?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    created_at?: true
    updated_at?: true
    last_message_at?: true
    message_count?: true
    is_pinned?: true
    is_archived?: true
    subject_id?: true
    chapter_id?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: number
    user_id: number
    title: string
    created_at: Date
    updated_at: Date
    last_message_at: Date | null
    message_count: number
    is_pinned: boolean
    is_archived: boolean
    subject_id: number | null
    chapter_id: bigint | null
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_message_at?: boolean
    message_count?: boolean
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | Conversation$subjectArgs<ExtArgs>
    chapter?: boolean | Conversation$chapterArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_message_at?: boolean
    message_count?: boolean
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | Conversation$subjectArgs<ExtArgs>
    chapter?: boolean | Conversation$chapterArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_message_at?: boolean
    message_count?: boolean
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | Conversation$subjectArgs<ExtArgs>
    chapter?: boolean | Conversation$chapterArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    updated_at?: boolean
    last_message_at?: boolean
    message_count?: boolean
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: boolean
    chapter_id?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "created_at" | "updated_at" | "last_message_at" | "message_count" | "is_pinned" | "is_archived" | "subject_id" | "chapter_id", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | Conversation$subjectArgs<ExtArgs>
    chapter?: boolean | Conversation$chapterArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | Conversation$subjectArgs<ExtArgs>
    chapter?: boolean | Conversation$chapterArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | Conversation$subjectArgs<ExtArgs>
    chapter?: boolean | Conversation$chapterArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      messages: Prisma.$ConversationMessagePayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      chapter: Prisma.$ChapterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      title: string
      created_at: Date
      updated_at: Date
      last_message_at: Date | null
      message_count: number
      is_pinned: boolean
      is_archived: boolean
      subject_id: number | null
      chapter_id: bigint | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends Conversation$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chapter<T extends Conversation$chapterArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$chapterArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'Int'>
    readonly user_id: FieldRef<"Conversation", 'Int'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly created_at: FieldRef<"Conversation", 'DateTime'>
    readonly updated_at: FieldRef<"Conversation", 'DateTime'>
    readonly last_message_at: FieldRef<"Conversation", 'DateTime'>
    readonly message_count: FieldRef<"Conversation", 'Int'>
    readonly is_pinned: FieldRef<"Conversation", 'Boolean'>
    readonly is_archived: FieldRef<"Conversation", 'Boolean'>
    readonly subject_id: FieldRef<"Conversation", 'Int'>
    readonly chapter_id: FieldRef<"Conversation", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    cursor?: ConversationMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * Conversation.subject
   */
  export type Conversation$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Conversation.chapter
   */
  export type Conversation$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationMessage
   */

  export type AggregateConversationMessage = {
    _count: ConversationMessageCountAggregateOutputType | null
    _avg: ConversationMessageAvgAggregateOutputType | null
    _sum: ConversationMessageSumAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  export type ConversationMessageAvgAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type ConversationMessageSumAggregateOutputType = {
    id: number | null
    conversation_id: number | null
  }

  export type ConversationMessageMinAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    role: $Enums.MessageRole | null
    content: string | null
    created_at: Date | null
  }

  export type ConversationMessageMaxAggregateOutputType = {
    id: number | null
    conversation_id: number | null
    role: $Enums.MessageRole | null
    content: string | null
    created_at: Date | null
  }

  export type ConversationMessageCountAggregateOutputType = {
    id: number
    conversation_id: number
    role: number
    content: number
    sources: number
    token_count: number
    metadata: number
    created_at: number
    _all: number
  }


  export type ConversationMessageAvgAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type ConversationMessageSumAggregateInputType = {
    id?: true
    conversation_id?: true
  }

  export type ConversationMessageMinAggregateInputType = {
    id?: true
    conversation_id?: true
    role?: true
    content?: true
    created_at?: true
  }

  export type ConversationMessageMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    role?: true
    content?: true
    created_at?: true
  }

  export type ConversationMessageCountAggregateInputType = {
    id?: true
    conversation_id?: true
    role?: true
    content?: true
    sources?: true
    token_count?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type ConversationMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMessage to aggregate.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationMessages
    **/
    _count?: true | ConversationMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type GetConversationMessageAggregateType<T extends ConversationMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationMessage[P]>
      : GetScalarType<T[P], AggregateConversationMessage[P]>
  }




  export type ConversationMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithAggregationInput | ConversationMessageOrderByWithAggregationInput[]
    by: ConversationMessageScalarFieldEnum[] | ConversationMessageScalarFieldEnum
    having?: ConversationMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationMessageCountAggregateInputType | true
    _avg?: ConversationMessageAvgAggregateInputType
    _sum?: ConversationMessageSumAggregateInputType
    _min?: ConversationMessageMinAggregateInputType
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type ConversationMessageGroupByOutputType = {
    id: number
    conversation_id: number
    role: $Enums.MessageRole
    content: string
    sources: JsonValue | null
    token_count: JsonValue | null
    metadata: JsonValue | null
    created_at: Date
    _count: ConversationMessageCountAggregateOutputType | null
    _avg: ConversationMessageAvgAggregateOutputType | null
    _sum: ConversationMessageSumAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  type GetConversationMessageGroupByPayload<T extends ConversationMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
        }
      >
    >


  export type ConversationMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    role?: boolean
    content?: boolean
    sources?: boolean
    token_count?: boolean
    metadata?: boolean
    created_at?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    role?: boolean
    content?: boolean
    sources?: boolean
    token_count?: boolean
    metadata?: boolean
    created_at?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    role?: boolean
    content?: boolean
    sources?: boolean
    token_count?: boolean
    metadata?: boolean
    created_at?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    role?: boolean
    content?: boolean
    sources?: boolean
    token_count?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type ConversationMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversation_id" | "role" | "content" | "sources" | "token_count" | "metadata" | "created_at", ExtArgs["result"]["conversationMessage"]>
  export type ConversationMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ConversationMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationMessage"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversation_id: number
      role: $Enums.MessageRole
      content: string
      sources: Prisma.JsonValue | null
      token_count: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["conversationMessage"]>
    composites: {}
  }

  type ConversationMessageGetPayload<S extends boolean | null | undefined | ConversationMessageDefaultArgs> = $Result.GetResult<Prisma.$ConversationMessagePayload, S>

  type ConversationMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationMessageCountAggregateInputType | true
    }

  export interface ConversationMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationMessage'], meta: { name: 'ConversationMessage' } }
    /**
     * Find zero or one ConversationMessage that matches the filter.
     * @param {ConversationMessageFindUniqueArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationMessageFindUniqueArgs>(args: SelectSubset<T, ConversationMessageFindUniqueArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationMessageFindUniqueOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationMessageFindFirstArgs>(args?: SelectSubset<T, ConversationMessageFindFirstArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany()
     * 
     * // Get first 10 ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationMessageFindManyArgs>(args?: SelectSubset<T, ConversationMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationMessage.
     * @param {ConversationMessageCreateArgs} args - Arguments to create a ConversationMessage.
     * @example
     * // Create one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.create({
     *   data: {
     *     // ... data to create a ConversationMessage
     *   }
     * })
     * 
     */
    create<T extends ConversationMessageCreateArgs>(args: SelectSubset<T, ConversationMessageCreateArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationMessages.
     * @param {ConversationMessageCreateManyArgs} args - Arguments to create many ConversationMessages.
     * @example
     * // Create many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationMessageCreateManyArgs>(args?: SelectSubset<T, ConversationMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationMessages and returns the data saved in the database.
     * @param {ConversationMessageCreateManyAndReturnArgs} args - Arguments to create many ConversationMessages.
     * @example
     * // Create many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationMessages and only return the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationMessage.
     * @param {ConversationMessageDeleteArgs} args - Arguments to delete one ConversationMessage.
     * @example
     * // Delete one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.delete({
     *   where: {
     *     // ... filter to delete one ConversationMessage
     *   }
     * })
     * 
     */
    delete<T extends ConversationMessageDeleteArgs>(args: SelectSubset<T, ConversationMessageDeleteArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationMessage.
     * @param {ConversationMessageUpdateArgs} args - Arguments to update one ConversationMessage.
     * @example
     * // Update one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationMessageUpdateArgs>(args: SelectSubset<T, ConversationMessageUpdateArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationMessages.
     * @param {ConversationMessageDeleteManyArgs} args - Arguments to filter ConversationMessages to delete.
     * @example
     * // Delete a few ConversationMessages
     * const { count } = await prisma.conversationMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationMessageDeleteManyArgs>(args?: SelectSubset<T, ConversationMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationMessageUpdateManyArgs>(args: SelectSubset<T, ConversationMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages and returns the data updated in the database.
     * @param {ConversationMessageUpdateManyAndReturnArgs} args - Arguments to update many ConversationMessages.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationMessages and only return the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationMessage.
     * @param {ConversationMessageUpsertArgs} args - Arguments to update or create a ConversationMessage.
     * @example
     * // Update or create a ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.upsert({
     *   create: {
     *     // ... data to create a ConversationMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationMessage we want to update
     *   }
     * })
     */
    upsert<T extends ConversationMessageUpsertArgs>(args: SelectSubset<T, ConversationMessageUpsertArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageCountArgs} args - Arguments to filter ConversationMessages to count.
     * @example
     * // Count the number of ConversationMessages
     * const count = await prisma.conversationMessage.count({
     *   where: {
     *     // ... the filter for the ConversationMessages we want to count
     *   }
     * })
    **/
    count<T extends ConversationMessageCountArgs>(
      args?: Subset<T, ConversationMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationMessageAggregateArgs>(args: Subset<T, ConversationMessageAggregateArgs>): Prisma.PrismaPromise<GetConversationMessageAggregateType<T>>

    /**
     * Group by ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationMessageGroupByArgs['orderBy'] }
        : { orderBy?: ConversationMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationMessage model
   */
  readonly fields: ConversationMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationMessage model
   */
  interface ConversationMessageFieldRefs {
    readonly id: FieldRef<"ConversationMessage", 'Int'>
    readonly conversation_id: FieldRef<"ConversationMessage", 'Int'>
    readonly role: FieldRef<"ConversationMessage", 'MessageRole'>
    readonly content: FieldRef<"ConversationMessage", 'String'>
    readonly sources: FieldRef<"ConversationMessage", 'Json'>
    readonly token_count: FieldRef<"ConversationMessage", 'Json'>
    readonly metadata: FieldRef<"ConversationMessage", 'Json'>
    readonly created_at: FieldRef<"ConversationMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationMessage findUnique
   */
  export type ConversationMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage findUniqueOrThrow
   */
  export type ConversationMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage findFirst
   */
  export type ConversationMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     */
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage findFirstOrThrow
   */
  export type ConversationMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     */
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage findMany
   */
  export type ConversationMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessages to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage create
   */
  export type ConversationMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationMessage.
     */
    data: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
  }

  /**
   * ConversationMessage createMany
   */
  export type ConversationMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationMessages.
     */
    data: ConversationMessageCreateManyInput | ConversationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationMessage createManyAndReturn
   */
  export type ConversationMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationMessages.
     */
    data: ConversationMessageCreateManyInput | ConversationMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMessage update
   */
  export type ConversationMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationMessage.
     */
    data: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
    /**
     * Choose, which ConversationMessage to update.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage updateMany
   */
  export type ConversationMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationMessages.
     */
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to update.
     */
    limit?: number
  }

  /**
   * ConversationMessage updateManyAndReturn
   */
  export type ConversationMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * The data used to update ConversationMessages.
     */
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMessage upsert
   */
  export type ConversationMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationMessage to update in case it exists.
     */
    where: ConversationMessageWhereUniqueInput
    /**
     * In case the ConversationMessage found by the `where` argument doesn't exist, create a new ConversationMessage with this data.
     */
    create: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
    /**
     * In case the ConversationMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
  }

  /**
   * ConversationMessage delete
   */
  export type ConversationMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter which ConversationMessage to delete.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage deleteMany
   */
  export type ConversationMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMessages to delete
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to delete.
     */
    limit?: number
  }

  /**
   * ConversationMessage without action
   */
  export type ConversationMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
  }


  /**
   * Model AiApiKey
   */

  export type AggregateAiApiKey = {
    _count: AiApiKeyCountAggregateOutputType | null
    _avg: AiApiKeyAvgAggregateOutputType | null
    _sum: AiApiKeySumAggregateOutputType | null
    _min: AiApiKeyMinAggregateOutputType | null
    _max: AiApiKeyMaxAggregateOutputType | null
  }

  export type AiApiKeyAvgAggregateOutputType = {
    id: number | null
    priority: number | null
    success_count: number | null
    error_count: number | null
  }

  export type AiApiKeySumAggregateOutputType = {
    id: number | null
    priority: number | null
    success_count: number | null
    error_count: number | null
  }

  export type AiApiKeyMinAggregateOutputType = {
    id: number | null
    provider: $Enums.Provider | null
    label: string | null
    api_key_enc: string | null
    active: boolean | null
    priority: number | null
    success_count: number | null
    error_count: number | null
    last_used_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AiApiKeyMaxAggregateOutputType = {
    id: number | null
    provider: $Enums.Provider | null
    label: string | null
    api_key_enc: string | null
    active: boolean | null
    priority: number | null
    success_count: number | null
    error_count: number | null
    last_used_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AiApiKeyCountAggregateOutputType = {
    id: number
    provider: number
    label: number
    api_key_enc: number
    active: number
    priority: number
    success_count: number
    error_count: number
    last_used_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AiApiKeyAvgAggregateInputType = {
    id?: true
    priority?: true
    success_count?: true
    error_count?: true
  }

  export type AiApiKeySumAggregateInputType = {
    id?: true
    priority?: true
    success_count?: true
    error_count?: true
  }

  export type AiApiKeyMinAggregateInputType = {
    id?: true
    provider?: true
    label?: true
    api_key_enc?: true
    active?: true
    priority?: true
    success_count?: true
    error_count?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
  }

  export type AiApiKeyMaxAggregateInputType = {
    id?: true
    provider?: true
    label?: true
    api_key_enc?: true
    active?: true
    priority?: true
    success_count?: true
    error_count?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
  }

  export type AiApiKeyCountAggregateInputType = {
    id?: true
    provider?: true
    label?: true
    api_key_enc?: true
    active?: true
    priority?: true
    success_count?: true
    error_count?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AiApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiApiKey to aggregate.
     */
    where?: AiApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiApiKeys to fetch.
     */
    orderBy?: AiApiKeyOrderByWithRelationInput | AiApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiApiKeys
    **/
    _count?: true | AiApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiApiKeyMaxAggregateInputType
  }

  export type GetAiApiKeyAggregateType<T extends AiApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateAiApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiApiKey[P]>
      : GetScalarType<T[P], AggregateAiApiKey[P]>
  }




  export type AiApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiApiKeyWhereInput
    orderBy?: AiApiKeyOrderByWithAggregationInput | AiApiKeyOrderByWithAggregationInput[]
    by: AiApiKeyScalarFieldEnum[] | AiApiKeyScalarFieldEnum
    having?: AiApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiApiKeyCountAggregateInputType | true
    _avg?: AiApiKeyAvgAggregateInputType
    _sum?: AiApiKeySumAggregateInputType
    _min?: AiApiKeyMinAggregateInputType
    _max?: AiApiKeyMaxAggregateInputType
  }

  export type AiApiKeyGroupByOutputType = {
    id: number
    provider: $Enums.Provider
    label: string
    api_key_enc: string
    active: boolean
    priority: number
    success_count: number
    error_count: number
    last_used_at: Date | null
    created_at: Date
    updated_at: Date
    _count: AiApiKeyCountAggregateOutputType | null
    _avg: AiApiKeyAvgAggregateOutputType | null
    _sum: AiApiKeySumAggregateOutputType | null
    _min: AiApiKeyMinAggregateOutputType | null
    _max: AiApiKeyMaxAggregateOutputType | null
  }

  type GetAiApiKeyGroupByPayload<T extends AiApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], AiApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type AiApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    label?: boolean
    api_key_enc?: boolean
    active?: boolean
    priority?: boolean
    success_count?: boolean
    error_count?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["aiApiKey"]>

  export type AiApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    label?: boolean
    api_key_enc?: boolean
    active?: boolean
    priority?: boolean
    success_count?: boolean
    error_count?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["aiApiKey"]>

  export type AiApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    label?: boolean
    api_key_enc?: boolean
    active?: boolean
    priority?: boolean
    success_count?: boolean
    error_count?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["aiApiKey"]>

  export type AiApiKeySelectScalar = {
    id?: boolean
    provider?: boolean
    label?: boolean
    api_key_enc?: boolean
    active?: boolean
    priority?: boolean
    success_count?: boolean
    error_count?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AiApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "label" | "api_key_enc" | "active" | "priority" | "success_count" | "error_count" | "last_used_at" | "created_at" | "updated_at", ExtArgs["result"]["aiApiKey"]>

  export type $AiApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiApiKey"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      provider: $Enums.Provider
      label: string
      api_key_enc: string
      active: boolean
      priority: number
      success_count: number
      error_count: number
      last_used_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["aiApiKey"]>
    composites: {}
  }

  type AiApiKeyGetPayload<S extends boolean | null | undefined | AiApiKeyDefaultArgs> = $Result.GetResult<Prisma.$AiApiKeyPayload, S>

  type AiApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiApiKeyCountAggregateInputType | true
    }

  export interface AiApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiApiKey'], meta: { name: 'AiApiKey' } }
    /**
     * Find zero or one AiApiKey that matches the filter.
     * @param {AiApiKeyFindUniqueArgs} args - Arguments to find a AiApiKey
     * @example
     * // Get one AiApiKey
     * const aiApiKey = await prisma.aiApiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiApiKeyFindUniqueArgs>(args: SelectSubset<T, AiApiKeyFindUniqueArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiApiKeyFindUniqueOrThrowArgs} args - Arguments to find a AiApiKey
     * @example
     * // Get one AiApiKey
     * const aiApiKey = await prisma.aiApiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, AiApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyFindFirstArgs} args - Arguments to find a AiApiKey
     * @example
     * // Get one AiApiKey
     * const aiApiKey = await prisma.aiApiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiApiKeyFindFirstArgs>(args?: SelectSubset<T, AiApiKeyFindFirstArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyFindFirstOrThrowArgs} args - Arguments to find a AiApiKey
     * @example
     * // Get one AiApiKey
     * const aiApiKey = await prisma.aiApiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, AiApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiApiKeys
     * const aiApiKeys = await prisma.aiApiKey.findMany()
     * 
     * // Get first 10 AiApiKeys
     * const aiApiKeys = await prisma.aiApiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiApiKeyWithIdOnly = await prisma.aiApiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiApiKeyFindManyArgs>(args?: SelectSubset<T, AiApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiApiKey.
     * @param {AiApiKeyCreateArgs} args - Arguments to create a AiApiKey.
     * @example
     * // Create one AiApiKey
     * const AiApiKey = await prisma.aiApiKey.create({
     *   data: {
     *     // ... data to create a AiApiKey
     *   }
     * })
     * 
     */
    create<T extends AiApiKeyCreateArgs>(args: SelectSubset<T, AiApiKeyCreateArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiApiKeys.
     * @param {AiApiKeyCreateManyArgs} args - Arguments to create many AiApiKeys.
     * @example
     * // Create many AiApiKeys
     * const aiApiKey = await prisma.aiApiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiApiKeyCreateManyArgs>(args?: SelectSubset<T, AiApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiApiKeys and returns the data saved in the database.
     * @param {AiApiKeyCreateManyAndReturnArgs} args - Arguments to create many AiApiKeys.
     * @example
     * // Create many AiApiKeys
     * const aiApiKey = await prisma.aiApiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiApiKeys and only return the `id`
     * const aiApiKeyWithIdOnly = await prisma.aiApiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, AiApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiApiKey.
     * @param {AiApiKeyDeleteArgs} args - Arguments to delete one AiApiKey.
     * @example
     * // Delete one AiApiKey
     * const AiApiKey = await prisma.aiApiKey.delete({
     *   where: {
     *     // ... filter to delete one AiApiKey
     *   }
     * })
     * 
     */
    delete<T extends AiApiKeyDeleteArgs>(args: SelectSubset<T, AiApiKeyDeleteArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiApiKey.
     * @param {AiApiKeyUpdateArgs} args - Arguments to update one AiApiKey.
     * @example
     * // Update one AiApiKey
     * const aiApiKey = await prisma.aiApiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiApiKeyUpdateArgs>(args: SelectSubset<T, AiApiKeyUpdateArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiApiKeys.
     * @param {AiApiKeyDeleteManyArgs} args - Arguments to filter AiApiKeys to delete.
     * @example
     * // Delete a few AiApiKeys
     * const { count } = await prisma.aiApiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiApiKeyDeleteManyArgs>(args?: SelectSubset<T, AiApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiApiKeys
     * const aiApiKey = await prisma.aiApiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiApiKeyUpdateManyArgs>(args: SelectSubset<T, AiApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiApiKeys and returns the data updated in the database.
     * @param {AiApiKeyUpdateManyAndReturnArgs} args - Arguments to update many AiApiKeys.
     * @example
     * // Update many AiApiKeys
     * const aiApiKey = await prisma.aiApiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiApiKeys and only return the `id`
     * const aiApiKeyWithIdOnly = await prisma.aiApiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, AiApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiApiKey.
     * @param {AiApiKeyUpsertArgs} args - Arguments to update or create a AiApiKey.
     * @example
     * // Update or create a AiApiKey
     * const aiApiKey = await prisma.aiApiKey.upsert({
     *   create: {
     *     // ... data to create a AiApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiApiKey we want to update
     *   }
     * })
     */
    upsert<T extends AiApiKeyUpsertArgs>(args: SelectSubset<T, AiApiKeyUpsertArgs<ExtArgs>>): Prisma__AiApiKeyClient<$Result.GetResult<Prisma.$AiApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyCountArgs} args - Arguments to filter AiApiKeys to count.
     * @example
     * // Count the number of AiApiKeys
     * const count = await prisma.aiApiKey.count({
     *   where: {
     *     // ... the filter for the AiApiKeys we want to count
     *   }
     * })
    **/
    count<T extends AiApiKeyCountArgs>(
      args?: Subset<T, AiApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiApiKeyAggregateArgs>(args: Subset<T, AiApiKeyAggregateArgs>): Prisma.PrismaPromise<GetAiApiKeyAggregateType<T>>

    /**
     * Group by AiApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: AiApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiApiKey model
   */
  readonly fields: AiApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiApiKey model
   */
  interface AiApiKeyFieldRefs {
    readonly id: FieldRef<"AiApiKey", 'Int'>
    readonly provider: FieldRef<"AiApiKey", 'Provider'>
    readonly label: FieldRef<"AiApiKey", 'String'>
    readonly api_key_enc: FieldRef<"AiApiKey", 'String'>
    readonly active: FieldRef<"AiApiKey", 'Boolean'>
    readonly priority: FieldRef<"AiApiKey", 'Int'>
    readonly success_count: FieldRef<"AiApiKey", 'Int'>
    readonly error_count: FieldRef<"AiApiKey", 'Int'>
    readonly last_used_at: FieldRef<"AiApiKey", 'DateTime'>
    readonly created_at: FieldRef<"AiApiKey", 'DateTime'>
    readonly updated_at: FieldRef<"AiApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiApiKey findUnique
   */
  export type AiApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * Filter, which AiApiKey to fetch.
     */
    where: AiApiKeyWhereUniqueInput
  }

  /**
   * AiApiKey findUniqueOrThrow
   */
  export type AiApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * Filter, which AiApiKey to fetch.
     */
    where: AiApiKeyWhereUniqueInput
  }

  /**
   * AiApiKey findFirst
   */
  export type AiApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * Filter, which AiApiKey to fetch.
     */
    where?: AiApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiApiKeys to fetch.
     */
    orderBy?: AiApiKeyOrderByWithRelationInput | AiApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiApiKeys.
     */
    cursor?: AiApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiApiKeys.
     */
    distinct?: AiApiKeyScalarFieldEnum | AiApiKeyScalarFieldEnum[]
  }

  /**
   * AiApiKey findFirstOrThrow
   */
  export type AiApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * Filter, which AiApiKey to fetch.
     */
    where?: AiApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiApiKeys to fetch.
     */
    orderBy?: AiApiKeyOrderByWithRelationInput | AiApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiApiKeys.
     */
    cursor?: AiApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiApiKeys.
     */
    distinct?: AiApiKeyScalarFieldEnum | AiApiKeyScalarFieldEnum[]
  }

  /**
   * AiApiKey findMany
   */
  export type AiApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * Filter, which AiApiKeys to fetch.
     */
    where?: AiApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiApiKeys to fetch.
     */
    orderBy?: AiApiKeyOrderByWithRelationInput | AiApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiApiKeys.
     */
    cursor?: AiApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiApiKeys.
     */
    skip?: number
    distinct?: AiApiKeyScalarFieldEnum | AiApiKeyScalarFieldEnum[]
  }

  /**
   * AiApiKey create
   */
  export type AiApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * The data needed to create a AiApiKey.
     */
    data: XOR<AiApiKeyCreateInput, AiApiKeyUncheckedCreateInput>
  }

  /**
   * AiApiKey createMany
   */
  export type AiApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiApiKeys.
     */
    data: AiApiKeyCreateManyInput | AiApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiApiKey createManyAndReturn
   */
  export type AiApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many AiApiKeys.
     */
    data: AiApiKeyCreateManyInput | AiApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiApiKey update
   */
  export type AiApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * The data needed to update a AiApiKey.
     */
    data: XOR<AiApiKeyUpdateInput, AiApiKeyUncheckedUpdateInput>
    /**
     * Choose, which AiApiKey to update.
     */
    where: AiApiKeyWhereUniqueInput
  }

  /**
   * AiApiKey updateMany
   */
  export type AiApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiApiKeys.
     */
    data: XOR<AiApiKeyUpdateManyMutationInput, AiApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which AiApiKeys to update
     */
    where?: AiApiKeyWhereInput
    /**
     * Limit how many AiApiKeys to update.
     */
    limit?: number
  }

  /**
   * AiApiKey updateManyAndReturn
   */
  export type AiApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update AiApiKeys.
     */
    data: XOR<AiApiKeyUpdateManyMutationInput, AiApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which AiApiKeys to update
     */
    where?: AiApiKeyWhereInput
    /**
     * Limit how many AiApiKeys to update.
     */
    limit?: number
  }

  /**
   * AiApiKey upsert
   */
  export type AiApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * The filter to search for the AiApiKey to update in case it exists.
     */
    where: AiApiKeyWhereUniqueInput
    /**
     * In case the AiApiKey found by the `where` argument doesn't exist, create a new AiApiKey with this data.
     */
    create: XOR<AiApiKeyCreateInput, AiApiKeyUncheckedCreateInput>
    /**
     * In case the AiApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiApiKeyUpdateInput, AiApiKeyUncheckedUpdateInput>
  }

  /**
   * AiApiKey delete
   */
  export type AiApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
    /**
     * Filter which AiApiKey to delete.
     */
    where: AiApiKeyWhereUniqueInput
  }

  /**
   * AiApiKey deleteMany
   */
  export type AiApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiApiKeys to delete
     */
    where?: AiApiKeyWhereInput
    /**
     * Limit how many AiApiKeys to delete.
     */
    limit?: number
  }

  /**
   * AiApiKey without action
   */
  export type AiApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiApiKey
     */
    select?: AiApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiApiKey
     */
    omit?: AiApiKeyOmit<ExtArgs> | null
  }


  /**
   * Model AiModel
   */

  export type AggregateAiModel = {
    _count: AiModelCountAggregateOutputType | null
    _avg: AiModelAvgAggregateOutputType | null
    _sum: AiModelSumAggregateOutputType | null
    _min: AiModelMinAggregateOutputType | null
    _max: AiModelMaxAggregateOutputType | null
  }

  export type AiModelAvgAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type AiModelSumAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type AiModelMinAggregateOutputType = {
    id: number | null
    provider: $Enums.Provider | null
    name: string | null
    label: string | null
    active: boolean | null
    priority: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AiModelMaxAggregateOutputType = {
    id: number | null
    provider: $Enums.Provider | null
    name: string | null
    label: string | null
    active: boolean | null
    priority: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AiModelCountAggregateOutputType = {
    id: number
    provider: number
    name: number
    label: number
    active: number
    priority: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AiModelAvgAggregateInputType = {
    id?: true
    priority?: true
  }

  export type AiModelSumAggregateInputType = {
    id?: true
    priority?: true
  }

  export type AiModelMinAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    label?: true
    active?: true
    priority?: true
    created_at?: true
    updated_at?: true
  }

  export type AiModelMaxAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    label?: true
    active?: true
    priority?: true
    created_at?: true
    updated_at?: true
  }

  export type AiModelCountAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    label?: true
    active?: true
    priority?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AiModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiModel to aggregate.
     */
    where?: AiModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiModels
    **/
    _count?: true | AiModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiModelMaxAggregateInputType
  }

  export type GetAiModelAggregateType<T extends AiModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAiModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiModel[P]>
      : GetScalarType<T[P], AggregateAiModel[P]>
  }




  export type AiModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiModelWhereInput
    orderBy?: AiModelOrderByWithAggregationInput | AiModelOrderByWithAggregationInput[]
    by: AiModelScalarFieldEnum[] | AiModelScalarFieldEnum
    having?: AiModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiModelCountAggregateInputType | true
    _avg?: AiModelAvgAggregateInputType
    _sum?: AiModelSumAggregateInputType
    _min?: AiModelMinAggregateInputType
    _max?: AiModelMaxAggregateInputType
  }

  export type AiModelGroupByOutputType = {
    id: number
    provider: $Enums.Provider
    name: string
    label: string
    active: boolean
    priority: number
    created_at: Date
    updated_at: Date
    _count: AiModelCountAggregateOutputType | null
    _avg: AiModelAvgAggregateOutputType | null
    _sum: AiModelSumAggregateOutputType | null
    _min: AiModelMinAggregateOutputType | null
    _max: AiModelMaxAggregateOutputType | null
  }

  type GetAiModelGroupByPayload<T extends AiModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiModelGroupByOutputType[P]>
            : GetScalarType<T[P], AiModelGroupByOutputType[P]>
        }
      >
    >


  export type AiModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    label?: boolean
    active?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["aiModel"]>

  export type AiModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    label?: boolean
    active?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["aiModel"]>

  export type AiModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    label?: boolean
    active?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["aiModel"]>

  export type AiModelSelectScalar = {
    id?: boolean
    provider?: boolean
    name?: boolean
    label?: boolean
    active?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AiModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "name" | "label" | "active" | "priority" | "created_at" | "updated_at", ExtArgs["result"]["aiModel"]>

  export type $AiModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      provider: $Enums.Provider
      name: string
      label: string
      active: boolean
      priority: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["aiModel"]>
    composites: {}
  }

  type AiModelGetPayload<S extends boolean | null | undefined | AiModelDefaultArgs> = $Result.GetResult<Prisma.$AiModelPayload, S>

  type AiModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiModelCountAggregateInputType | true
    }

  export interface AiModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiModel'], meta: { name: 'AiModel' } }
    /**
     * Find zero or one AiModel that matches the filter.
     * @param {AiModelFindUniqueArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiModelFindUniqueArgs>(args: SelectSubset<T, AiModelFindUniqueArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiModelFindUniqueOrThrowArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiModelFindUniqueOrThrowArgs>(args: SelectSubset<T, AiModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelFindFirstArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiModelFindFirstArgs>(args?: SelectSubset<T, AiModelFindFirstArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelFindFirstOrThrowArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiModelFindFirstOrThrowArgs>(args?: SelectSubset<T, AiModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiModels
     * const aiModels = await prisma.aiModel.findMany()
     * 
     * // Get first 10 AiModels
     * const aiModels = await prisma.aiModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiModelWithIdOnly = await prisma.aiModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiModelFindManyArgs>(args?: SelectSubset<T, AiModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiModel.
     * @param {AiModelCreateArgs} args - Arguments to create a AiModel.
     * @example
     * // Create one AiModel
     * const AiModel = await prisma.aiModel.create({
     *   data: {
     *     // ... data to create a AiModel
     *   }
     * })
     * 
     */
    create<T extends AiModelCreateArgs>(args: SelectSubset<T, AiModelCreateArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiModels.
     * @param {AiModelCreateManyArgs} args - Arguments to create many AiModels.
     * @example
     * // Create many AiModels
     * const aiModel = await prisma.aiModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiModelCreateManyArgs>(args?: SelectSubset<T, AiModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiModels and returns the data saved in the database.
     * @param {AiModelCreateManyAndReturnArgs} args - Arguments to create many AiModels.
     * @example
     * // Create many AiModels
     * const aiModel = await prisma.aiModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiModels and only return the `id`
     * const aiModelWithIdOnly = await prisma.aiModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiModelCreateManyAndReturnArgs>(args?: SelectSubset<T, AiModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiModel.
     * @param {AiModelDeleteArgs} args - Arguments to delete one AiModel.
     * @example
     * // Delete one AiModel
     * const AiModel = await prisma.aiModel.delete({
     *   where: {
     *     // ... filter to delete one AiModel
     *   }
     * })
     * 
     */
    delete<T extends AiModelDeleteArgs>(args: SelectSubset<T, AiModelDeleteArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiModel.
     * @param {AiModelUpdateArgs} args - Arguments to update one AiModel.
     * @example
     * // Update one AiModel
     * const aiModel = await prisma.aiModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiModelUpdateArgs>(args: SelectSubset<T, AiModelUpdateArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiModels.
     * @param {AiModelDeleteManyArgs} args - Arguments to filter AiModels to delete.
     * @example
     * // Delete a few AiModels
     * const { count } = await prisma.aiModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiModelDeleteManyArgs>(args?: SelectSubset<T, AiModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiModels
     * const aiModel = await prisma.aiModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiModelUpdateManyArgs>(args: SelectSubset<T, AiModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiModels and returns the data updated in the database.
     * @param {AiModelUpdateManyAndReturnArgs} args - Arguments to update many AiModels.
     * @example
     * // Update many AiModels
     * const aiModel = await prisma.aiModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiModels and only return the `id`
     * const aiModelWithIdOnly = await prisma.aiModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiModelUpdateManyAndReturnArgs>(args: SelectSubset<T, AiModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiModel.
     * @param {AiModelUpsertArgs} args - Arguments to update or create a AiModel.
     * @example
     * // Update or create a AiModel
     * const aiModel = await prisma.aiModel.upsert({
     *   create: {
     *     // ... data to create a AiModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiModel we want to update
     *   }
     * })
     */
    upsert<T extends AiModelUpsertArgs>(args: SelectSubset<T, AiModelUpsertArgs<ExtArgs>>): Prisma__AiModelClient<$Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelCountArgs} args - Arguments to filter AiModels to count.
     * @example
     * // Count the number of AiModels
     * const count = await prisma.aiModel.count({
     *   where: {
     *     // ... the filter for the AiModels we want to count
     *   }
     * })
    **/
    count<T extends AiModelCountArgs>(
      args?: Subset<T, AiModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiModelAggregateArgs>(args: Subset<T, AiModelAggregateArgs>): Prisma.PrismaPromise<GetAiModelAggregateType<T>>

    /**
     * Group by AiModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiModelGroupByArgs['orderBy'] }
        : { orderBy?: AiModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiModel model
   */
  readonly fields: AiModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiModel model
   */
  interface AiModelFieldRefs {
    readonly id: FieldRef<"AiModel", 'Int'>
    readonly provider: FieldRef<"AiModel", 'Provider'>
    readonly name: FieldRef<"AiModel", 'String'>
    readonly label: FieldRef<"AiModel", 'String'>
    readonly active: FieldRef<"AiModel", 'Boolean'>
    readonly priority: FieldRef<"AiModel", 'Int'>
    readonly created_at: FieldRef<"AiModel", 'DateTime'>
    readonly updated_at: FieldRef<"AiModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiModel findUnique
   */
  export type AiModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * Filter, which AiModel to fetch.
     */
    where: AiModelWhereUniqueInput
  }

  /**
   * AiModel findUniqueOrThrow
   */
  export type AiModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * Filter, which AiModel to fetch.
     */
    where: AiModelWhereUniqueInput
  }

  /**
   * AiModel findFirst
   */
  export type AiModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * Filter, which AiModel to fetch.
     */
    where?: AiModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiModels.
     */
    cursor?: AiModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiModels.
     */
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[]
  }

  /**
   * AiModel findFirstOrThrow
   */
  export type AiModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * Filter, which AiModel to fetch.
     */
    where?: AiModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiModels.
     */
    cursor?: AiModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiModels.
     */
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[]
  }

  /**
   * AiModel findMany
   */
  export type AiModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * Filter, which AiModels to fetch.
     */
    where?: AiModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiModels.
     */
    cursor?: AiModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiModels.
     */
    skip?: number
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[]
  }

  /**
   * AiModel create
   */
  export type AiModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * The data needed to create a AiModel.
     */
    data: XOR<AiModelCreateInput, AiModelUncheckedCreateInput>
  }

  /**
   * AiModel createMany
   */
  export type AiModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiModels.
     */
    data: AiModelCreateManyInput | AiModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiModel createManyAndReturn
   */
  export type AiModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * The data used to create many AiModels.
     */
    data: AiModelCreateManyInput | AiModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiModel update
   */
  export type AiModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * The data needed to update a AiModel.
     */
    data: XOR<AiModelUpdateInput, AiModelUncheckedUpdateInput>
    /**
     * Choose, which AiModel to update.
     */
    where: AiModelWhereUniqueInput
  }

  /**
   * AiModel updateMany
   */
  export type AiModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiModels.
     */
    data: XOR<AiModelUpdateManyMutationInput, AiModelUncheckedUpdateManyInput>
    /**
     * Filter which AiModels to update
     */
    where?: AiModelWhereInput
    /**
     * Limit how many AiModels to update.
     */
    limit?: number
  }

  /**
   * AiModel updateManyAndReturn
   */
  export type AiModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * The data used to update AiModels.
     */
    data: XOR<AiModelUpdateManyMutationInput, AiModelUncheckedUpdateManyInput>
    /**
     * Filter which AiModels to update
     */
    where?: AiModelWhereInput
    /**
     * Limit how many AiModels to update.
     */
    limit?: number
  }

  /**
   * AiModel upsert
   */
  export type AiModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * The filter to search for the AiModel to update in case it exists.
     */
    where: AiModelWhereUniqueInput
    /**
     * In case the AiModel found by the `where` argument doesn't exist, create a new AiModel with this data.
     */
    create: XOR<AiModelCreateInput, AiModelUncheckedCreateInput>
    /**
     * In case the AiModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiModelUpdateInput, AiModelUncheckedUpdateInput>
  }

  /**
   * AiModel delete
   */
  export type AiModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
    /**
     * Filter which AiModel to delete.
     */
    where: AiModelWhereUniqueInput
  }

  /**
   * AiModel deleteMany
   */
  export type AiModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiModels to delete
     */
    where?: AiModelWhereInput
    /**
     * Limit how many AiModels to delete.
     */
    limit?: number
  }

  /**
   * AiModel without action
   */
  export type AiModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null
  }


  /**
   * Model app_settings
   */

  export type AggregateApp_settings = {
    _count: App_settingsCountAggregateOutputType | null
    _min: App_settingsMinAggregateOutputType | null
    _max: App_settingsMaxAggregateOutputType | null
  }

  export type App_settingsMinAggregateOutputType = {
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type App_settingsMaxAggregateOutputType = {
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type App_settingsCountAggregateOutputType = {
    key: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type App_settingsMinAggregateInputType = {
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type App_settingsMaxAggregateInputType = {
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type App_settingsCountAggregateInputType = {
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type App_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_settings to aggregate.
     */
    where?: app_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_settings to fetch.
     */
    orderBy?: app_settingsOrderByWithRelationInput | app_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_settings
    **/
    _count?: true | App_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_settingsMaxAggregateInputType
  }

  export type GetApp_settingsAggregateType<T extends App_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_settings[P]>
      : GetScalarType<T[P], AggregateApp_settings[P]>
  }




  export type app_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_settingsWhereInput
    orderBy?: app_settingsOrderByWithAggregationInput | app_settingsOrderByWithAggregationInput[]
    by: App_settingsScalarFieldEnum[] | App_settingsScalarFieldEnum
    having?: app_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_settingsCountAggregateInputType | true
    _min?: App_settingsMinAggregateInputType
    _max?: App_settingsMaxAggregateInputType
  }

  export type App_settingsGroupByOutputType = {
    key: string
    value: string
    created_at: Date | null
    updated_at: Date | null
    _count: App_settingsCountAggregateOutputType | null
    _min: App_settingsMinAggregateOutputType | null
    _max: App_settingsMaxAggregateOutputType | null
  }

  type GetApp_settingsGroupByPayload<T extends app_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], App_settingsGroupByOutputType[P]>
        }
      >
    >


  export type app_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["app_settings"]>

  export type app_settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["app_settings"]>

  export type app_settingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["app_settings"]>

  export type app_settingsSelectScalar = {
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type app_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "created_at" | "updated_at", ExtArgs["result"]["app_settings"]>

  export type $app_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["app_settings"]>
    composites: {}
  }

  type app_settingsGetPayload<S extends boolean | null | undefined | app_settingsDefaultArgs> = $Result.GetResult<Prisma.$app_settingsPayload, S>

  type app_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<app_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: App_settingsCountAggregateInputType | true
    }

  export interface app_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_settings'], meta: { name: 'app_settings' } }
    /**
     * Find zero or one App_settings that matches the filter.
     * @param {app_settingsFindUniqueArgs} args - Arguments to find a App_settings
     * @example
     * // Get one App_settings
     * const app_settings = await prisma.app_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_settingsFindUniqueArgs>(args: SelectSubset<T, app_settingsFindUniqueArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one App_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {app_settingsFindUniqueOrThrowArgs} args - Arguments to find a App_settings
     * @example
     * // Get one App_settings
     * const app_settings = await prisma.app_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, app_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_settingsFindFirstArgs} args - Arguments to find a App_settings
     * @example
     * // Get one App_settings
     * const app_settings = await prisma.app_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_settingsFindFirstArgs>(args?: SelectSubset<T, app_settingsFindFirstArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_settingsFindFirstOrThrowArgs} args - Arguments to find a App_settings
     * @example
     * // Get one App_settings
     * const app_settings = await prisma.app_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, app_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more App_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_settings
     * const app_settings = await prisma.app_settings.findMany()
     * 
     * // Get first 10 App_settings
     * const app_settings = await prisma.app_settings.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const app_settingsWithKeyOnly = await prisma.app_settings.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends app_settingsFindManyArgs>(args?: SelectSubset<T, app_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a App_settings.
     * @param {app_settingsCreateArgs} args - Arguments to create a App_settings.
     * @example
     * // Create one App_settings
     * const App_settings = await prisma.app_settings.create({
     *   data: {
     *     // ... data to create a App_settings
     *   }
     * })
     * 
     */
    create<T extends app_settingsCreateArgs>(args: SelectSubset<T, app_settingsCreateArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many App_settings.
     * @param {app_settingsCreateManyArgs} args - Arguments to create many App_settings.
     * @example
     * // Create many App_settings
     * const app_settings = await prisma.app_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_settingsCreateManyArgs>(args?: SelectSubset<T, app_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_settings and returns the data saved in the database.
     * @param {app_settingsCreateManyAndReturnArgs} args - Arguments to create many App_settings.
     * @example
     * // Create many App_settings
     * const app_settings = await prisma.app_settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_settings and only return the `key`
     * const app_settingsWithKeyOnly = await prisma.app_settings.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, app_settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a App_settings.
     * @param {app_settingsDeleteArgs} args - Arguments to delete one App_settings.
     * @example
     * // Delete one App_settings
     * const App_settings = await prisma.app_settings.delete({
     *   where: {
     *     // ... filter to delete one App_settings
     *   }
     * })
     * 
     */
    delete<T extends app_settingsDeleteArgs>(args: SelectSubset<T, app_settingsDeleteArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one App_settings.
     * @param {app_settingsUpdateArgs} args - Arguments to update one App_settings.
     * @example
     * // Update one App_settings
     * const app_settings = await prisma.app_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_settingsUpdateArgs>(args: SelectSubset<T, app_settingsUpdateArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more App_settings.
     * @param {app_settingsDeleteManyArgs} args - Arguments to filter App_settings to delete.
     * @example
     * // Delete a few App_settings
     * const { count } = await prisma.app_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_settingsDeleteManyArgs>(args?: SelectSubset<T, app_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_settings
     * const app_settings = await prisma.app_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_settingsUpdateManyArgs>(args: SelectSubset<T, app_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_settings and returns the data updated in the database.
     * @param {app_settingsUpdateManyAndReturnArgs} args - Arguments to update many App_settings.
     * @example
     * // Update many App_settings
     * const app_settings = await prisma.app_settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more App_settings and only return the `key`
     * const app_settingsWithKeyOnly = await prisma.app_settings.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends app_settingsUpdateManyAndReturnArgs>(args: SelectSubset<T, app_settingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one App_settings.
     * @param {app_settingsUpsertArgs} args - Arguments to update or create a App_settings.
     * @example
     * // Update or create a App_settings
     * const app_settings = await prisma.app_settings.upsert({
     *   create: {
     *     // ... data to create a App_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_settings we want to update
     *   }
     * })
     */
    upsert<T extends app_settingsUpsertArgs>(args: SelectSubset<T, app_settingsUpsertArgs<ExtArgs>>): Prisma__app_settingsClient<$Result.GetResult<Prisma.$app_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of App_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_settingsCountArgs} args - Arguments to filter App_settings to count.
     * @example
     * // Count the number of App_settings
     * const count = await prisma.app_settings.count({
     *   where: {
     *     // ... the filter for the App_settings we want to count
     *   }
     * })
    **/
    count<T extends app_settingsCountArgs>(
      args?: Subset<T, app_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_settingsAggregateArgs>(args: Subset<T, App_settingsAggregateArgs>): Prisma.PrismaPromise<GetApp_settingsAggregateType<T>>

    /**
     * Group by App_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_settingsGroupByArgs['orderBy'] }
        : { orderBy?: app_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_settings model
   */
  readonly fields: app_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_settings model
   */
  interface app_settingsFieldRefs {
    readonly key: FieldRef<"app_settings", 'String'>
    readonly value: FieldRef<"app_settings", 'String'>
    readonly created_at: FieldRef<"app_settings", 'DateTime'>
    readonly updated_at: FieldRef<"app_settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_settings findUnique
   */
  export type app_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * Filter, which app_settings to fetch.
     */
    where: app_settingsWhereUniqueInput
  }

  /**
   * app_settings findUniqueOrThrow
   */
  export type app_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * Filter, which app_settings to fetch.
     */
    where: app_settingsWhereUniqueInput
  }

  /**
   * app_settings findFirst
   */
  export type app_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * Filter, which app_settings to fetch.
     */
    where?: app_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_settings to fetch.
     */
    orderBy?: app_settingsOrderByWithRelationInput | app_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_settings.
     */
    cursor?: app_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_settings.
     */
    distinct?: App_settingsScalarFieldEnum | App_settingsScalarFieldEnum[]
  }

  /**
   * app_settings findFirstOrThrow
   */
  export type app_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * Filter, which app_settings to fetch.
     */
    where?: app_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_settings to fetch.
     */
    orderBy?: app_settingsOrderByWithRelationInput | app_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_settings.
     */
    cursor?: app_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_settings.
     */
    distinct?: App_settingsScalarFieldEnum | App_settingsScalarFieldEnum[]
  }

  /**
   * app_settings findMany
   */
  export type app_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * Filter, which app_settings to fetch.
     */
    where?: app_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_settings to fetch.
     */
    orderBy?: app_settingsOrderByWithRelationInput | app_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_settings.
     */
    cursor?: app_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_settings.
     */
    skip?: number
    distinct?: App_settingsScalarFieldEnum | App_settingsScalarFieldEnum[]
  }

  /**
   * app_settings create
   */
  export type app_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * The data needed to create a app_settings.
     */
    data: XOR<app_settingsCreateInput, app_settingsUncheckedCreateInput>
  }

  /**
   * app_settings createMany
   */
  export type app_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_settings.
     */
    data: app_settingsCreateManyInput | app_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_settings createManyAndReturn
   */
  export type app_settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * The data used to create many app_settings.
     */
    data: app_settingsCreateManyInput | app_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_settings update
   */
  export type app_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * The data needed to update a app_settings.
     */
    data: XOR<app_settingsUpdateInput, app_settingsUncheckedUpdateInput>
    /**
     * Choose, which app_settings to update.
     */
    where: app_settingsWhereUniqueInput
  }

  /**
   * app_settings updateMany
   */
  export type app_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_settings.
     */
    data: XOR<app_settingsUpdateManyMutationInput, app_settingsUncheckedUpdateManyInput>
    /**
     * Filter which app_settings to update
     */
    where?: app_settingsWhereInput
    /**
     * Limit how many app_settings to update.
     */
    limit?: number
  }

  /**
   * app_settings updateManyAndReturn
   */
  export type app_settingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * The data used to update app_settings.
     */
    data: XOR<app_settingsUpdateManyMutationInput, app_settingsUncheckedUpdateManyInput>
    /**
     * Filter which app_settings to update
     */
    where?: app_settingsWhereInput
    /**
     * Limit how many app_settings to update.
     */
    limit?: number
  }

  /**
   * app_settings upsert
   */
  export type app_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * The filter to search for the app_settings to update in case it exists.
     */
    where: app_settingsWhereUniqueInput
    /**
     * In case the app_settings found by the `where` argument doesn't exist, create a new app_settings with this data.
     */
    create: XOR<app_settingsCreateInput, app_settingsUncheckedCreateInput>
    /**
     * In case the app_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_settingsUpdateInput, app_settingsUncheckedUpdateInput>
  }

  /**
   * app_settings delete
   */
  export type app_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
    /**
     * Filter which app_settings to delete.
     */
    where: app_settingsWhereUniqueInput
  }

  /**
   * app_settings deleteMany
   */
  export type app_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_settings to delete
     */
    where?: app_settingsWhereInput
    /**
     * Limit how many app_settings to delete.
     */
    limit?: number
  }

  /**
   * app_settings without action
   */
  export type app_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_settings
     */
    select?: app_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_settings
     */
    omit?: app_settingsOmit<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    id: number | null
    price_monthly: Decimal | null
    price_yearly: Decimal | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    id: number | null
    price_monthly: Decimal | null
    price_yearly: Decimal | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    display_name: string | null
    description: string | null
    price_monthly: Decimal | null
    price_yearly: Decimal | null
    razorpay_plan_id_monthly: string | null
    razorpay_plan_id_yearly: string | null
    is_active: boolean | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    display_name: string | null
    description: string | null
    price_monthly: Decimal | null
    price_yearly: Decimal | null
    razorpay_plan_id_monthly: string | null
    razorpay_plan_id_yearly: string | null
    is_active: boolean | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    display_name: number
    description: number
    price_monthly: number
    price_yearly: number
    razorpay_plan_id_monthly: number
    razorpay_plan_id_yearly: number
    features: number
    limits: number
    is_active: number
    is_default: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    id?: true
    price_monthly?: true
    price_yearly?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    id?: true
    price_monthly?: true
    price_yearly?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    description?: true
    price_monthly?: true
    price_yearly?: true
    razorpay_plan_id_monthly?: true
    razorpay_plan_id_yearly?: true
    is_active?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    description?: true
    price_monthly?: true
    price_yearly?: true
    razorpay_plan_id_monthly?: true
    razorpay_plan_id_yearly?: true
    is_active?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    description?: true
    price_monthly?: true
    price_yearly?: true
    razorpay_plan_id_monthly?: true
    razorpay_plan_id_yearly?: true
    features?: true
    limits?: true
    is_active?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: number
    name: string
    display_name: string
    description: string | null
    price_monthly: Decimal
    price_yearly: Decimal | null
    razorpay_plan_id_monthly: string | null
    razorpay_plan_id_yearly: string | null
    features: JsonValue | null
    limits: JsonValue
    is_active: boolean
    is_default: boolean
    created_at: Date
    updated_at: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    display_name?: boolean
    description?: boolean
    price_monthly?: boolean
    price_yearly?: boolean
    razorpay_plan_id_monthly?: boolean
    razorpay_plan_id_yearly?: boolean
    features?: boolean
    limits?: boolean
    is_active?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    display_name?: boolean
    description?: boolean
    price_monthly?: boolean
    price_yearly?: boolean
    razorpay_plan_id_monthly?: boolean
    razorpay_plan_id_yearly?: boolean
    features?: boolean
    limits?: boolean
    is_active?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    display_name?: boolean
    description?: boolean
    price_monthly?: boolean
    price_yearly?: boolean
    razorpay_plan_id_monthly?: boolean
    razorpay_plan_id_yearly?: boolean
    features?: boolean
    limits?: boolean
    is_active?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    display_name?: boolean
    description?: boolean
    price_monthly?: boolean
    price_yearly?: boolean
    razorpay_plan_id_monthly?: boolean
    razorpay_plan_id_yearly?: boolean
    features?: boolean
    limits?: boolean
    is_active?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubscriptionPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "display_name" | "description" | "price_monthly" | "price_yearly" | "razorpay_plan_id_monthly" | "razorpay_plan_id_yearly" | "features" | "limits" | "is_active" | "is_default" | "created_at" | "updated_at", ExtArgs["result"]["subscriptionPlan"]>
  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$UserSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      display_name: string
      description: string | null
      price_monthly: Prisma.Decimal
      price_yearly: Prisma.Decimal | null
      razorpay_plan_id_monthly: string | null
      razorpay_plan_id_yearly: string | null
      features: Prisma.JsonValue | null
      limits: Prisma.JsonValue
      is_active: boolean
      is_default: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'Int'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly display_name: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly price_monthly: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly price_yearly: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly razorpay_plan_id_monthly: FieldRef<"SubscriptionPlan", 'String'>
    readonly razorpay_plan_id_yearly: FieldRef<"SubscriptionPlan", 'String'>
    readonly features: FieldRef<"SubscriptionPlan", 'Json'>
    readonly limits: FieldRef<"SubscriptionPlan", 'Json'>
    readonly is_active: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly is_default: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly created_at: FieldRef<"SubscriptionPlan", 'DateTime'>
    readonly updated_at: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
  }

  export type UserSubscriptionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    razorpay_subscription_id: string | null
    razorpay_customer_id: string | null
    razorpay_order_id: string | null
    status: $Enums.SubscriptionStatus | null
    billing_cycle: $Enums.BillingCycle | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    canceled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    razorpay_subscription_id: string | null
    razorpay_customer_id: string | null
    razorpay_order_id: string | null
    status: $Enums.SubscriptionStatus | null
    billing_cycle: $Enums.BillingCycle | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    canceled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    user_id: number
    plan_id: number
    razorpay_subscription_id: number
    razorpay_customer_id: number
    razorpay_order_id: number
    status: number
    billing_cycle: number
    current_period_start: number
    current_period_end: number
    cancel_at_period_end: number
    canceled_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserSubscriptionAvgAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
  }

  export type UserSubscriptionSumAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
  }

  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    razorpay_subscription_id?: true
    razorpay_customer_id?: true
    razorpay_order_id?: true
    status?: true
    billing_cycle?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    canceled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    razorpay_subscription_id?: true
    razorpay_customer_id?: true
    razorpay_order_id?: true
    status?: true
    billing_cycle?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    canceled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    razorpay_subscription_id?: true
    razorpay_customer_id?: true
    razorpay_order_id?: true
    status?: true
    billing_cycle?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    canceled_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _avg?: UserSubscriptionAvgAggregateInputType
    _sum?: UserSubscriptionSumAggregateInputType
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: number
    user_id: number
    plan_id: number
    razorpay_subscription_id: string | null
    razorpay_customer_id: string | null
    razorpay_order_id: string | null
    status: $Enums.SubscriptionStatus
    billing_cycle: $Enums.BillingCycle
    current_period_start: Date
    current_period_end: Date
    cancel_at_period_end: boolean
    canceled_at: Date | null
    created_at: Date
    updated_at: Date
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    razorpay_subscription_id?: boolean
    razorpay_customer_id?: boolean
    razorpay_order_id?: boolean
    status?: boolean
    billing_cycle?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    razorpay_subscription_id?: boolean
    razorpay_customer_id?: boolean
    razorpay_order_id?: boolean
    status?: boolean
    billing_cycle?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    razorpay_subscription_id?: boolean
    razorpay_customer_id?: boolean
    razorpay_order_id?: boolean
    status?: boolean
    billing_cycle?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    razorpay_subscription_id?: boolean
    razorpay_customer_id?: boolean
    razorpay_order_id?: boolean
    status?: boolean
    billing_cycle?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "plan_id" | "razorpay_subscription_id" | "razorpay_customer_id" | "razorpay_order_id" | "status" | "billing_cycle" | "current_period_start" | "current_period_end" | "cancel_at_period_end" | "canceled_at" | "created_at" | "updated_at", ExtArgs["result"]["userSubscription"]>
  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      plan_id: number
      razorpay_subscription_id: string | null
      razorpay_customer_id: string | null
      razorpay_order_id: string | null
      status: $Enums.SubscriptionStatus
      billing_cycle: $Enums.BillingCycle
      current_period_start: Date
      current_period_end: Date
      cancel_at_period_end: boolean
      canceled_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions and returns the data updated in the database.
     * @param {UserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many UserSubscriptions.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'Int'>
    readonly user_id: FieldRef<"UserSubscription", 'Int'>
    readonly plan_id: FieldRef<"UserSubscription", 'Int'>
    readonly razorpay_subscription_id: FieldRef<"UserSubscription", 'String'>
    readonly razorpay_customer_id: FieldRef<"UserSubscription", 'String'>
    readonly razorpay_order_id: FieldRef<"UserSubscription", 'String'>
    readonly status: FieldRef<"UserSubscription", 'SubscriptionStatus'>
    readonly billing_cycle: FieldRef<"UserSubscription", 'BillingCycle'>
    readonly current_period_start: FieldRef<"UserSubscription", 'DateTime'>
    readonly current_period_end: FieldRef<"UserSubscription", 'DateTime'>
    readonly cancel_at_period_end: FieldRef<"UserSubscription", 'Boolean'>
    readonly canceled_at: FieldRef<"UserSubscription", 'DateTime'>
    readonly created_at: FieldRef<"UserSubscription", 'DateTime'>
    readonly updated_at: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * UserSubscription updateManyAndReturn
   */
  export type UserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UsageTracking
   */

  export type AggregateUsageTracking = {
    _count: UsageTrackingCountAggregateOutputType | null
    _avg: UsageTrackingAvgAggregateOutputType | null
    _sum: UsageTrackingSumAggregateOutputType | null
    _min: UsageTrackingMinAggregateOutputType | null
    _max: UsageTrackingMaxAggregateOutputType | null
  }

  export type UsageTrackingAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    count: number | null
  }

  export type UsageTrackingSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    count: number | null
  }

  export type UsageTrackingMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    usage_type: $Enums.UsageType | null
    count: number | null
    period_start: Date | null
    period_end: Date | null
    created_at: Date | null
  }

  export type UsageTrackingMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    usage_type: $Enums.UsageType | null
    count: number | null
    period_start: Date | null
    period_end: Date | null
    created_at: Date | null
  }

  export type UsageTrackingCountAggregateOutputType = {
    id: number
    user_id: number
    usage_type: number
    count: number
    period_start: number
    period_end: number
    metadata: number
    created_at: number
    _all: number
  }


  export type UsageTrackingAvgAggregateInputType = {
    id?: true
    user_id?: true
    count?: true
  }

  export type UsageTrackingSumAggregateInputType = {
    id?: true
    user_id?: true
    count?: true
  }

  export type UsageTrackingMinAggregateInputType = {
    id?: true
    user_id?: true
    usage_type?: true
    count?: true
    period_start?: true
    period_end?: true
    created_at?: true
  }

  export type UsageTrackingMaxAggregateInputType = {
    id?: true
    user_id?: true
    usage_type?: true
    count?: true
    period_start?: true
    period_end?: true
    created_at?: true
  }

  export type UsageTrackingCountAggregateInputType = {
    id?: true
    user_id?: true
    usage_type?: true
    count?: true
    period_start?: true
    period_end?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type UsageTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageTracking to aggregate.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageTrackings
    **/
    _count?: true | UsageTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageTrackingMaxAggregateInputType
  }

  export type GetUsageTrackingAggregateType<T extends UsageTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageTracking[P]>
      : GetScalarType<T[P], AggregateUsageTracking[P]>
  }




  export type UsageTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageTrackingWhereInput
    orderBy?: UsageTrackingOrderByWithAggregationInput | UsageTrackingOrderByWithAggregationInput[]
    by: UsageTrackingScalarFieldEnum[] | UsageTrackingScalarFieldEnum
    having?: UsageTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageTrackingCountAggregateInputType | true
    _avg?: UsageTrackingAvgAggregateInputType
    _sum?: UsageTrackingSumAggregateInputType
    _min?: UsageTrackingMinAggregateInputType
    _max?: UsageTrackingMaxAggregateInputType
  }

  export type UsageTrackingGroupByOutputType = {
    id: number
    user_id: number
    usage_type: $Enums.UsageType
    count: number
    period_start: Date
    period_end: Date
    metadata: JsonValue | null
    created_at: Date
    _count: UsageTrackingCountAggregateOutputType | null
    _avg: UsageTrackingAvgAggregateOutputType | null
    _sum: UsageTrackingSumAggregateOutputType | null
    _min: UsageTrackingMinAggregateOutputType | null
    _max: UsageTrackingMaxAggregateOutputType | null
  }

  type GetUsageTrackingGroupByPayload<T extends UsageTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], UsageTrackingGroupByOutputType[P]>
        }
      >
    >


  export type UsageTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    usage_type?: boolean
    count?: boolean
    period_start?: boolean
    period_end?: boolean
    metadata?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    usage_type?: boolean
    count?: boolean
    period_start?: boolean
    period_end?: boolean
    metadata?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    usage_type?: boolean
    count?: boolean
    period_start?: boolean
    period_end?: boolean
    metadata?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageTracking"]>

  export type UsageTrackingSelectScalar = {
    id?: boolean
    user_id?: boolean
    usage_type?: boolean
    count?: boolean
    period_start?: boolean
    period_end?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type UsageTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "usage_type" | "count" | "period_start" | "period_end" | "metadata" | "created_at", ExtArgs["result"]["usageTracking"]>
  export type UsageTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UsageTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UsageTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $UsageTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageTracking"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      usage_type: $Enums.UsageType
      count: number
      period_start: Date
      period_end: Date
      metadata: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["usageTracking"]>
    composites: {}
  }

  type UsageTrackingGetPayload<S extends boolean | null | undefined | UsageTrackingDefaultArgs> = $Result.GetResult<Prisma.$UsageTrackingPayload, S>

  type UsageTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageTrackingCountAggregateInputType | true
    }

  export interface UsageTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageTracking'], meta: { name: 'UsageTracking' } }
    /**
     * Find zero or one UsageTracking that matches the filter.
     * @param {UsageTrackingFindUniqueArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageTrackingFindUniqueArgs>(args: SelectSubset<T, UsageTrackingFindUniqueArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageTrackingFindUniqueOrThrowArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindFirstArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageTrackingFindFirstArgs>(args?: SelectSubset<T, UsageTrackingFindFirstArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindFirstOrThrowArgs} args - Arguments to find a UsageTracking
     * @example
     * // Get one UsageTracking
     * const usageTracking = await prisma.usageTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageTrackings
     * const usageTrackings = await prisma.usageTracking.findMany()
     * 
     * // Get first 10 UsageTrackings
     * const usageTrackings = await prisma.usageTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageTrackingFindManyArgs>(args?: SelectSubset<T, UsageTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageTracking.
     * @param {UsageTrackingCreateArgs} args - Arguments to create a UsageTracking.
     * @example
     * // Create one UsageTracking
     * const UsageTracking = await prisma.usageTracking.create({
     *   data: {
     *     // ... data to create a UsageTracking
     *   }
     * })
     * 
     */
    create<T extends UsageTrackingCreateArgs>(args: SelectSubset<T, UsageTrackingCreateArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageTrackings.
     * @param {UsageTrackingCreateManyArgs} args - Arguments to create many UsageTrackings.
     * @example
     * // Create many UsageTrackings
     * const usageTracking = await prisma.usageTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageTrackingCreateManyArgs>(args?: SelectSubset<T, UsageTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageTrackings and returns the data saved in the database.
     * @param {UsageTrackingCreateManyAndReturnArgs} args - Arguments to create many UsageTrackings.
     * @example
     * // Create many UsageTrackings
     * const usageTracking = await prisma.usageTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageTrackings and only return the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageTracking.
     * @param {UsageTrackingDeleteArgs} args - Arguments to delete one UsageTracking.
     * @example
     * // Delete one UsageTracking
     * const UsageTracking = await prisma.usageTracking.delete({
     *   where: {
     *     // ... filter to delete one UsageTracking
     *   }
     * })
     * 
     */
    delete<T extends UsageTrackingDeleteArgs>(args: SelectSubset<T, UsageTrackingDeleteArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageTracking.
     * @param {UsageTrackingUpdateArgs} args - Arguments to update one UsageTracking.
     * @example
     * // Update one UsageTracking
     * const usageTracking = await prisma.usageTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageTrackingUpdateArgs>(args: SelectSubset<T, UsageTrackingUpdateArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageTrackings.
     * @param {UsageTrackingDeleteManyArgs} args - Arguments to filter UsageTrackings to delete.
     * @example
     * // Delete a few UsageTrackings
     * const { count } = await prisma.usageTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageTrackingDeleteManyArgs>(args?: SelectSubset<T, UsageTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageTrackings
     * const usageTracking = await prisma.usageTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageTrackingUpdateManyArgs>(args: SelectSubset<T, UsageTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageTrackings and returns the data updated in the database.
     * @param {UsageTrackingUpdateManyAndReturnArgs} args - Arguments to update many UsageTrackings.
     * @example
     * // Update many UsageTrackings
     * const usageTracking = await prisma.usageTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageTrackings and only return the `id`
     * const usageTrackingWithIdOnly = await prisma.usageTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageTracking.
     * @param {UsageTrackingUpsertArgs} args - Arguments to update or create a UsageTracking.
     * @example
     * // Update or create a UsageTracking
     * const usageTracking = await prisma.usageTracking.upsert({
     *   create: {
     *     // ... data to create a UsageTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageTracking we want to update
     *   }
     * })
     */
    upsert<T extends UsageTrackingUpsertArgs>(args: SelectSubset<T, UsageTrackingUpsertArgs<ExtArgs>>): Prisma__UsageTrackingClient<$Result.GetResult<Prisma.$UsageTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingCountArgs} args - Arguments to filter UsageTrackings to count.
     * @example
     * // Count the number of UsageTrackings
     * const count = await prisma.usageTracking.count({
     *   where: {
     *     // ... the filter for the UsageTrackings we want to count
     *   }
     * })
    **/
    count<T extends UsageTrackingCountArgs>(
      args?: Subset<T, UsageTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageTrackingAggregateArgs>(args: Subset<T, UsageTrackingAggregateArgs>): Prisma.PrismaPromise<GetUsageTrackingAggregateType<T>>

    /**
     * Group by UsageTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageTrackingGroupByArgs['orderBy'] }
        : { orderBy?: UsageTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageTracking model
   */
  readonly fields: UsageTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageTracking model
   */
  interface UsageTrackingFieldRefs {
    readonly id: FieldRef<"UsageTracking", 'Int'>
    readonly user_id: FieldRef<"UsageTracking", 'Int'>
    readonly usage_type: FieldRef<"UsageTracking", 'UsageType'>
    readonly count: FieldRef<"UsageTracking", 'Int'>
    readonly period_start: FieldRef<"UsageTracking", 'DateTime'>
    readonly period_end: FieldRef<"UsageTracking", 'DateTime'>
    readonly metadata: FieldRef<"UsageTracking", 'Json'>
    readonly created_at: FieldRef<"UsageTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageTracking findUnique
   */
  export type UsageTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking findUniqueOrThrow
   */
  export type UsageTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking findFirst
   */
  export type UsageTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageTrackings.
     */
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking findFirstOrThrow
   */
  export type UsageTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTracking to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageTrackings.
     */
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking findMany
   */
  export type UsageTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter, which UsageTrackings to fetch.
     */
    where?: UsageTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageTrackings to fetch.
     */
    orderBy?: UsageTrackingOrderByWithRelationInput | UsageTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageTrackings.
     */
    cursor?: UsageTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageTrackings.
     */
    skip?: number
    distinct?: UsageTrackingScalarFieldEnum | UsageTrackingScalarFieldEnum[]
  }

  /**
   * UsageTracking create
   */
  export type UsageTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageTracking.
     */
    data: XOR<UsageTrackingCreateInput, UsageTrackingUncheckedCreateInput>
  }

  /**
   * UsageTracking createMany
   */
  export type UsageTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageTrackings.
     */
    data: UsageTrackingCreateManyInput | UsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageTracking createManyAndReturn
   */
  export type UsageTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many UsageTrackings.
     */
    data: UsageTrackingCreateManyInput | UsageTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageTracking update
   */
  export type UsageTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageTracking.
     */
    data: XOR<UsageTrackingUpdateInput, UsageTrackingUncheckedUpdateInput>
    /**
     * Choose, which UsageTracking to update.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking updateMany
   */
  export type UsageTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageTrackings.
     */
    data: XOR<UsageTrackingUpdateManyMutationInput, UsageTrackingUncheckedUpdateManyInput>
    /**
     * Filter which UsageTrackings to update
     */
    where?: UsageTrackingWhereInput
    /**
     * Limit how many UsageTrackings to update.
     */
    limit?: number
  }

  /**
   * UsageTracking updateManyAndReturn
   */
  export type UsageTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * The data used to update UsageTrackings.
     */
    data: XOR<UsageTrackingUpdateManyMutationInput, UsageTrackingUncheckedUpdateManyInput>
    /**
     * Filter which UsageTrackings to update
     */
    where?: UsageTrackingWhereInput
    /**
     * Limit how many UsageTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageTracking upsert
   */
  export type UsageTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageTracking to update in case it exists.
     */
    where: UsageTrackingWhereUniqueInput
    /**
     * In case the UsageTracking found by the `where` argument doesn't exist, create a new UsageTracking with this data.
     */
    create: XOR<UsageTrackingCreateInput, UsageTrackingUncheckedCreateInput>
    /**
     * In case the UsageTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageTrackingUpdateInput, UsageTrackingUncheckedUpdateInput>
  }

  /**
   * UsageTracking delete
   */
  export type UsageTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
    /**
     * Filter which UsageTracking to delete.
     */
    where: UsageTrackingWhereUniqueInput
  }

  /**
   * UsageTracking deleteMany
   */
  export type UsageTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageTrackings to delete
     */
    where?: UsageTrackingWhereInput
    /**
     * Limit how many UsageTrackings to delete.
     */
    limit?: number
  }

  /**
   * UsageTracking without action
   */
  export type UsageTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageTracking
     */
    select?: UsageTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageTracking
     */
    omit?: UsageTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageTrackingInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryMinAggregateOutputType = {
    id: string | null
    name: string | null
    currency: string | null
    locale: string | null
    is_active: boolean | null
  }

  export type CountryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    currency: string | null
    locale: string | null
    is_active: boolean | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    currency: number
    locale: number
    is_active: number
    _all: number
  }


  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    locale?: true
    is_active?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    locale?: true
    is_active?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    locale?: true
    is_active?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: string
    name: string
    currency: string
    locale: string
    is_active: boolean
    _count: CountryCountAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    locale?: boolean
    is_active?: boolean
    boards?: boolean | Country$boardsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    locale?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    locale?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    currency?: boolean
    locale?: boolean
    is_active?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "currency" | "locale" | "is_active", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | Country$boardsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      boards: Prisma.$BoardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      currency: string
      locale: string
      is_active: boolean
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boards<T extends Country$boardsArgs<ExtArgs> = {}>(args?: Subset<T, Country$boardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly currency: FieldRef<"Country", 'String'>
    readonly locale: FieldRef<"Country", 'String'>
    readonly is_active: FieldRef<"Country", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.boards
   */
  export type Country$boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    cursor?: BoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardMinAggregateOutputType = {
    id: string | null
    name: string | null
    country_id: string | null
    state: string | null
    type: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BoardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    country_id: string | null
    state: string | null
    type: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    name: number
    country_id: number
    state: number
    type: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BoardMinAggregateInputType = {
    id?: true
    name?: true
    country_id?: true
    state?: true
    type?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    name?: true
    country_id?: true
    state?: true
    type?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    name?: true
    country_id?: true
    state?: true
    type?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: string
    name: string
    country_id: string
    state: string | null
    type: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country_id?: boolean
    state?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    institutions?: boolean | Board$institutionsArgs<ExtArgs>
    programs?: boolean | Board$programsArgs<ExtArgs>
    chunkBoards?: boolean | Board$chunkBoardsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country_id?: boolean
    state?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country_id?: boolean
    state?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    name?: boolean
    country_id?: boolean
    state?: boolean
    type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "country_id" | "state" | "type" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["board"]>
  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    institutions?: boolean | Board$institutionsArgs<ExtArgs>
    programs?: boolean | Board$programsArgs<ExtArgs>
    chunkBoards?: boolean | Board$chunkBoardsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type BoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      institutions: Prisma.$InstitutionPayload<ExtArgs>[]
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      chunkBoards: Prisma.$ChapterChunkBoardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      country_id: string
      state: string | null
      type: string
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards and returns the data updated in the database.
     * @param {BoardUpdateManyAndReturnArgs} args - Arguments to update many Boards.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institutions<T extends Board$institutionsArgs<ExtArgs> = {}>(args?: Subset<T, Board$institutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programs<T extends Board$programsArgs<ExtArgs> = {}>(args?: Subset<T, Board$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chunkBoards<T extends Board$chunkBoardsArgs<ExtArgs> = {}>(args?: Subset<T, Board$chunkBoardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'String'>
    readonly name: FieldRef<"Board", 'String'>
    readonly country_id: FieldRef<"Board", 'String'>
    readonly state: FieldRef<"Board", 'String'>
    readonly type: FieldRef<"Board", 'String'>
    readonly is_active: FieldRef<"Board", 'Boolean'>
    readonly created_at: FieldRef<"Board", 'DateTime'>
    readonly updated_at: FieldRef<"Board", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board updateManyAndReturn
   */
  export type BoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to delete.
     */
    limit?: number
  }

  /**
   * Board.institutions
   */
  export type Board$institutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    cursor?: InstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Board.programs
   */
  export type Board$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Board.chunkBoards
   */
  export type Board$chunkBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    where?: ChapterChunkBoardWhereInput
    orderBy?: ChapterChunkBoardOrderByWithRelationInput | ChapterChunkBoardOrderByWithRelationInput[]
    cursor?: ChapterChunkBoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterChunkBoardScalarFieldEnum | ChapterChunkBoardScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model Institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _avg: InstitutionAvgAggregateOutputType | null
    _sum: InstitutionSumAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionAvgAggregateOutputType = {
    id: number | null
  }

  export type InstitutionSumAggregateOutputType = {
    id: bigint | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: bigint | null
    board_id: string | null
    name: string | null
    type: string | null
    district: string | null
    state: string | null
    license_expiry: Date | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: bigint | null
    board_id: string | null
    name: string | null
    type: string | null
    district: string | null
    state: string | null
    license_expiry: Date | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    board_id: number
    name: number
    type: number
    district: number
    state: number
    license_expiry: number
    is_active: number
    created_at: number
    _all: number
  }


  export type InstitutionAvgAggregateInputType = {
    id?: true
  }

  export type InstitutionSumAggregateInputType = {
    id?: true
  }

  export type InstitutionMinAggregateInputType = {
    id?: true
    board_id?: true
    name?: true
    type?: true
    district?: true
    state?: true
    license_expiry?: true
    is_active?: true
    created_at?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    board_id?: true
    name?: true
    type?: true
    district?: true
    state?: true
    license_expiry?: true
    is_active?: true
    created_at?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    board_id?: true
    name?: true
    type?: true
    district?: true
    state?: true
    license_expiry?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institution to aggregate.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type InstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithAggregationInput | InstitutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: InstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _avg?: InstitutionAvgAggregateInputType
    _sum?: InstitutionSumAggregateInputType
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: bigint
    board_id: string
    name: string
    type: string
    district: string | null
    state: string | null
    license_expiry: Date | null
    is_active: boolean
    created_at: Date
    _count: InstitutionCountAggregateOutputType | null
    _avg: InstitutionAvgAggregateOutputType | null
    _sum: InstitutionSumAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends InstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    name?: boolean
    type?: boolean
    district?: boolean
    state?: boolean
    license_expiry?: boolean
    is_active?: boolean
    created_at?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    programs?: boolean | Institution$programsArgs<ExtArgs>
    profiles?: boolean | Institution$profilesArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    name?: boolean
    type?: boolean
    district?: boolean
    state?: boolean
    license_expiry?: boolean
    is_active?: boolean
    created_at?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    name?: boolean
    type?: boolean
    district?: boolean
    state?: boolean
    license_expiry?: boolean
    is_active?: boolean
    created_at?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>

  export type InstitutionSelectScalar = {
    id?: boolean
    board_id?: boolean
    name?: boolean
    type?: boolean
    district?: boolean
    state?: boolean
    license_expiry?: boolean
    is_active?: boolean
    created_at?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "board_id" | "name" | "type" | "district" | "state" | "license_expiry" | "is_active" | "created_at", ExtArgs["result"]["institution"]>
  export type InstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    programs?: boolean | Institution$programsArgs<ExtArgs>
    profiles?: boolean | Institution$profilesArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstitutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type InstitutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $InstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institution"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      board_id: string
      name: string
      type: string
      district: string | null
      state: string | null
      license_expiry: Date | null
      is_active: boolean
      created_at: Date
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>

  type InstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface InstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institution'], meta: { name: 'Institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {InstitutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionFindUniqueArgs>(args: SelectSubset<T, InstitutionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionFindFirstArgs>(args?: SelectSubset<T, InstitutionFindFirstArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionFindManyArgs>(args?: SelectSubset<T, InstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {InstitutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends InstitutionCreateArgs>(args: SelectSubset<T, InstitutionCreateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {InstitutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionCreateManyArgs>(args?: SelectSubset<T, InstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutions and returns the data saved in the database.
     * @param {InstitutionCreateManyAndReturnArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, InstitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Institution.
     * @param {InstitutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends InstitutionDeleteArgs>(args: SelectSubset<T, InstitutionDeleteArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {InstitutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionUpdateArgs>(args: SelectSubset<T, InstitutionUpdateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {InstitutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionDeleteManyArgs>(args?: SelectSubset<T, InstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionUpdateManyArgs>(args: SelectSubset<T, InstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions and returns the data updated in the database.
     * @param {InstitutionUpdateManyAndReturnArgs} args - Arguments to update many Institutions.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Institutions and only return the `id`
     * const institutionWithIdOnly = await prisma.institution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstitutionUpdateManyAndReturnArgs>(args: SelectSubset<T, InstitutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Institution.
     * @param {InstitutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionUpsertArgs>(args: SelectSubset<T, InstitutionUpsertArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionCountArgs>(
      args?: Subset<T, InstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institution model
   */
  readonly fields: InstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    programs<T extends Institution$programsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profiles<T extends Institution$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'BigInt'>
    readonly board_id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly type: FieldRef<"Institution", 'String'>
    readonly district: FieldRef<"Institution", 'String'>
    readonly state: FieldRef<"Institution", 'String'>
    readonly license_expiry: FieldRef<"Institution", 'DateTime'>
    readonly is_active: FieldRef<"Institution", 'Boolean'>
    readonly created_at: FieldRef<"Institution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Institution findUnique
   */
  export type InstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findUniqueOrThrow
   */
  export type InstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findFirst
   */
  export type InstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findFirstOrThrow
   */
  export type InstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findMany
   */
  export type InstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institutions to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution create
   */
  export type InstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Institution.
     */
    data: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
  }

  /**
   * Institution createMany
   */
  export type InstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institution createManyAndReturn
   */
  export type InstitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Institution update
   */
  export type InstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Institution.
     */
    data: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
    /**
     * Choose, which Institution to update.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution updateMany
   */
  export type InstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution updateManyAndReturn
   */
  export type InstitutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Institution upsert
   */
  export type InstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Institution to update in case it exists.
     */
    where: InstitutionWhereUniqueInput
    /**
     * In case the Institution found by the `where` argument doesn't exist, create a new Institution with this data.
     */
    create: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
    /**
     * In case the Institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
  }

  /**
   * Institution delete
   */
  export type InstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter which Institution to delete.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution deleteMany
   */
  export type InstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutions to delete
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to delete.
     */
    limit?: number
  }

  /**
   * Institution.programs
   */
  export type Institution$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Institution.profiles
   */
  export type Institution$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    id: number | null
    institution_id: number | null
    duration_years: number | null
  }

  export type ProgramSumAggregateOutputType = {
    id: number | null
    institution_id: bigint | null
    duration_years: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: number | null
    board_id: string | null
    institution_id: bigint | null
    name: string | null
    code: string | null
    level: string | null
    duration_years: number | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: number | null
    board_id: string | null
    institution_id: bigint | null
    name: string | null
    code: string | null
    level: string | null
    duration_years: number | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    board_id: number
    institution_id: number
    name: number
    code: number
    level: number
    duration_years: number
    is_active: number
    created_at: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    id?: true
    institution_id?: true
    duration_years?: true
  }

  export type ProgramSumAggregateInputType = {
    id?: true
    institution_id?: true
    duration_years?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    board_id?: true
    institution_id?: true
    name?: true
    code?: true
    level?: true
    duration_years?: true
    is_active?: true
    created_at?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    board_id?: true
    institution_id?: true
    name?: true
    code?: true
    level?: true
    duration_years?: true
    is_active?: true
    created_at?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    board_id?: true
    institution_id?: true
    name?: true
    code?: true
    level?: true
    duration_years?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: number
    board_id: string
    institution_id: bigint | null
    name: string
    code: string | null
    level: string | null
    duration_years: number | null
    is_active: boolean
    created_at: Date
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    institution_id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    duration_years?: boolean
    is_active?: boolean
    created_at?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    institution?: boolean | Program$institutionArgs<ExtArgs>
    subjects?: boolean | Program$subjectsArgs<ExtArgs>
    profiles?: boolean | Program$profilesArgs<ExtArgs>
    exams?: boolean | Program$examsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    institution_id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    duration_years?: boolean
    is_active?: boolean
    created_at?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    institution?: boolean | Program$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    institution_id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    duration_years?: boolean
    is_active?: boolean
    created_at?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    institution?: boolean | Program$institutionArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    board_id?: boolean
    institution_id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    duration_years?: boolean
    is_active?: boolean
    created_at?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "board_id" | "institution_id" | "name" | "code" | "level" | "duration_years" | "is_active" | "created_at", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    institution?: boolean | Program$institutionArgs<ExtArgs>
    subjects?: boolean | Program$subjectsArgs<ExtArgs>
    profiles?: boolean | Program$profilesArgs<ExtArgs>
    exams?: boolean | Program$examsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    institution?: boolean | Program$institutionArgs<ExtArgs>
  }
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    institution?: boolean | Program$institutionArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      board_id: string
      institution_id: bigint | null
      name: string
      code: string | null
      level: string | null
      duration_years: number | null
      is_active: boolean
      created_at: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends Program$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Program$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Program$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Program$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profiles<T extends Program$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Program$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends Program$examsArgs<ExtArgs> = {}>(args?: Subset<T, Program$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'Int'>
    readonly board_id: FieldRef<"Program", 'String'>
    readonly institution_id: FieldRef<"Program", 'BigInt'>
    readonly name: FieldRef<"Program", 'String'>
    readonly code: FieldRef<"Program", 'String'>
    readonly level: FieldRef<"Program", 'String'>
    readonly duration_years: FieldRef<"Program", 'Int'>
    readonly is_active: FieldRef<"Program", 'Boolean'>
    readonly created_at: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program.institution
   */
  export type Program$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * Program.subjects
   */
  export type Program$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Program.profiles
   */
  export type Program$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Program.exams
   */
  export type Program$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: number | null
    program_id: number | null
    last_sync_at: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: bigint | null
    program_id: number | null
    last_sync_at: bigint | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: bigint | null
    program_id: number | null
    is_premium: boolean | null
    last_sync_at: bigint | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    institution_id: bigint | null
    program_id: number | null
    is_premium: boolean | null
    last_sync_at: bigint | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    user_id: number
    institution_id: number
    program_id: number
    is_premium: number
    last_sync_at: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    program_id?: true
    last_sync_at?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    program_id?: true
    last_sync_at?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    program_id?: true
    is_premium?: true
    last_sync_at?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    program_id?: true
    is_premium?: true
    last_sync_at?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    user_id?: true
    institution_id?: true
    program_id?: true
    is_premium?: true
    last_sync_at?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: number
    user_id: number
    institution_id: bigint | null
    program_id: number | null
    is_premium: boolean
    last_sync_at: bigint | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution_id?: boolean
    program_id?: boolean
    is_premium?: boolean
    last_sync_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | Profile$institutionArgs<ExtArgs>
    program?: boolean | Profile$programArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution_id?: boolean
    program_id?: boolean
    is_premium?: boolean
    last_sync_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | Profile$institutionArgs<ExtArgs>
    program?: boolean | Profile$programArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    institution_id?: boolean
    program_id?: boolean
    is_premium?: boolean
    last_sync_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | Profile$institutionArgs<ExtArgs>
    program?: boolean | Profile$programArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    user_id?: boolean
    institution_id?: boolean
    program_id?: boolean
    is_premium?: boolean
    last_sync_at?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "institution_id" | "program_id" | "is_premium" | "last_sync_at", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | Profile$institutionArgs<ExtArgs>
    program?: boolean | Profile$programArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | Profile$institutionArgs<ExtArgs>
    program?: boolean | Profile$programArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    institution?: boolean | Profile$institutionArgs<ExtArgs>
    program?: boolean | Profile$programArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      program: Prisma.$ProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      institution_id: bigint | null
      program_id: number | null
      is_premium: boolean
      last_sync_at: bigint | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends Profile$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Profile$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    program<T extends Profile$programArgs<ExtArgs> = {}>(args?: Subset<T, Profile$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'Int'>
    readonly user_id: FieldRef<"Profile", 'Int'>
    readonly institution_id: FieldRef<"Profile", 'BigInt'>
    readonly program_id: FieldRef<"Profile", 'Int'>
    readonly is_premium: FieldRef<"Profile", 'Boolean'>
    readonly last_sync_at: FieldRef<"Profile", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.institution
   */
  export type Profile$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * Profile.program
   */
  export type Profile$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    id: number | null
    program_id: number | null
  }

  export type SubjectSumAggregateOutputType = {
    id: number | null
    program_id: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: number | null
    program_id: number | null
    name: string | null
    code: string | null
    is_active: boolean | null
    created_at: Date | null
    term: string | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: number | null
    program_id: number | null
    name: string | null
    code: string | null
    is_active: boolean | null
    created_at: Date | null
    term: string | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    program_id: number
    name: number
    code: number
    is_active: number
    created_at: number
    term: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    id?: true
    program_id?: true
  }

  export type SubjectSumAggregateInputType = {
    id?: true
    program_id?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    program_id?: true
    name?: true
    code?: true
    is_active?: true
    created_at?: true
    term?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    program_id?: true
    name?: true
    code?: true
    is_active?: true
    created_at?: true
    term?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    program_id?: true
    name?: true
    code?: true
    is_active?: true
    created_at?: true
    term?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: number
    program_id: number
    name: string
    code: string | null
    is_active: boolean
    created_at: Date
    term: string | null
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    program_id?: boolean
    name?: boolean
    code?: boolean
    is_active?: boolean
    created_at?: boolean
    term?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    quizzes?: boolean | Subject$quizzesArgs<ExtArgs>
    conversations?: boolean | Subject$conversationsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    program_id?: boolean
    name?: boolean
    code?: boolean
    is_active?: boolean
    created_at?: boolean
    term?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    program_id?: boolean
    name?: boolean
    code?: boolean
    is_active?: boolean
    created_at?: boolean
    term?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    program_id?: boolean
    name?: boolean
    code?: boolean
    is_active?: boolean
    created_at?: boolean
    term?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "program_id" | "name" | "code" | "is_active" | "created_at" | "term", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    quizzes?: boolean | Subject$quizzesArgs<ExtArgs>
    conversations?: boolean | Subject$conversationsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      program_id: number
      name: string
      code: string | null
      is_active: boolean
      created_at: Date
      term: string | null
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapters<T extends Subject$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends Subject$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Subject$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'Int'>
    readonly program_id: FieldRef<"Subject", 'Int'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly is_active: FieldRef<"Subject", 'Boolean'>
    readonly created_at: FieldRef<"Subject", 'DateTime'>
    readonly term: FieldRef<"Subject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.chapters
   */
  export type Subject$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Subject.quizzes
   */
  export type Subject$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Subject.conversations
   */
  export type Subject$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    id: number | null
    subject_id: number | null
    chapter_number: number | null
  }

  export type ChapterSumAggregateOutputType = {
    id: bigint | null
    subject_id: number | null
    chapter_number: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: bigint | null
    subject_id: number | null
    title: string | null
    chapter_number: number | null
    version_id: string | null
    is_global: boolean | null
    is_active: boolean | null
    processing_status: $Enums.ChapterStatus | null
    error_message: string | null
    processed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    parsed_at: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: bigint | null
    subject_id: number | null
    title: string | null
    chapter_number: number | null
    version_id: string | null
    is_global: boolean | null
    is_active: boolean | null
    processing_status: $Enums.ChapterStatus | null
    error_message: string | null
    processed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    parsed_at: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    subject_id: number
    title: number
    chapter_number: number
    content_json: number
    version_id: number
    accessible_boards: number
    is_global: number
    is_active: number
    processing_status: number
    error_message: number
    processed_at: number
    created_at: number
    updated_at: number
    parsed_at: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    id?: true
    subject_id?: true
    chapter_number?: true
  }

  export type ChapterSumAggregateInputType = {
    id?: true
    subject_id?: true
    chapter_number?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    subject_id?: true
    title?: true
    chapter_number?: true
    version_id?: true
    is_global?: true
    is_active?: true
    processing_status?: true
    error_message?: true
    processed_at?: true
    created_at?: true
    updated_at?: true
    parsed_at?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    subject_id?: true
    title?: true
    chapter_number?: true
    version_id?: true
    is_global?: true
    is_active?: true
    processing_status?: true
    error_message?: true
    processed_at?: true
    created_at?: true
    updated_at?: true
    parsed_at?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    subject_id?: true
    title?: true
    chapter_number?: true
    content_json?: true
    version_id?: true
    accessible_boards?: true
    is_global?: true
    is_active?: true
    processing_status?: true
    error_message?: true
    processed_at?: true
    created_at?: true
    updated_at?: true
    parsed_at?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: bigint
    subject_id: number
    title: string
    chapter_number: number | null
    content_json: JsonValue
    version_id: string
    accessible_boards: string[]
    is_global: boolean
    is_active: boolean
    processing_status: $Enums.ChapterStatus
    error_message: string | null
    processed_at: Date | null
    created_at: Date
    updated_at: Date
    parsed_at: Date | null
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject_id?: boolean
    title?: boolean
    chapter_number?: boolean
    content_json?: boolean
    version_id?: boolean
    accessible_boards?: boolean
    is_global?: boolean
    is_active?: boolean
    processing_status?: boolean
    error_message?: boolean
    processed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    parsed_at?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chunks?: boolean | Chapter$chunksArgs<ExtArgs>
    pages?: boolean | Chapter$pagesArgs<ExtArgs>
    quizzes?: boolean | Chapter$quizzesArgs<ExtArgs>
    study_materials?: boolean | Chapter$study_materialsArgs<ExtArgs>
    learning_sessions?: boolean | Chapter$learning_sessionsArgs<ExtArgs>
    conversations?: boolean | Chapter$conversationsArgs<ExtArgs>
    questions?: boolean | Chapter$questionsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject_id?: boolean
    title?: boolean
    chapter_number?: boolean
    content_json?: boolean
    version_id?: boolean
    accessible_boards?: boolean
    is_global?: boolean
    is_active?: boolean
    processing_status?: boolean
    error_message?: boolean
    processed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    parsed_at?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject_id?: boolean
    title?: boolean
    chapter_number?: boolean
    content_json?: boolean
    version_id?: boolean
    accessible_boards?: boolean
    is_global?: boolean
    is_active?: boolean
    processing_status?: boolean
    error_message?: boolean
    processed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    parsed_at?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    subject_id?: boolean
    title?: boolean
    chapter_number?: boolean
    content_json?: boolean
    version_id?: boolean
    accessible_boards?: boolean
    is_global?: boolean
    is_active?: boolean
    processing_status?: boolean
    error_message?: boolean
    processed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    parsed_at?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject_id" | "title" | "chapter_number" | "content_json" | "version_id" | "accessible_boards" | "is_global" | "is_active" | "processing_status" | "error_message" | "processed_at" | "created_at" | "updated_at" | "parsed_at", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chunks?: boolean | Chapter$chunksArgs<ExtArgs>
    pages?: boolean | Chapter$pagesArgs<ExtArgs>
    quizzes?: boolean | Chapter$quizzesArgs<ExtArgs>
    study_materials?: boolean | Chapter$study_materialsArgs<ExtArgs>
    learning_sessions?: boolean | Chapter$learning_sessionsArgs<ExtArgs>
    conversations?: boolean | Chapter$conversationsArgs<ExtArgs>
    questions?: boolean | Chapter$questionsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
      chunks: Prisma.$ChapterChunkPayload<ExtArgs>[]
      pages: Prisma.$ChapterPagePayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      study_materials: Prisma.$StudyMaterialPayload<ExtArgs> | null
      learning_sessions: Prisma.$LearningSessionPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      questions: Prisma.$QuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      subject_id: number
      title: string
      chapter_number: number | null
      content_json: Prisma.JsonValue
      version_id: string
      accessible_boards: string[]
      is_global: boolean
      is_active: boolean
      processing_status: $Enums.ChapterStatus
      error_message: string | null
      processed_at: Date | null
      created_at: Date
      updated_at: Date
      parsed_at: Date | null
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chunks<T extends Chapter$chunksArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$chunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends Chapter$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends Chapter$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    study_materials<T extends Chapter$study_materialsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$study_materialsArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    learning_sessions<T extends Chapter$learning_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$learning_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Chapter$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends Chapter$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'BigInt'>
    readonly subject_id: FieldRef<"Chapter", 'Int'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly chapter_number: FieldRef<"Chapter", 'Int'>
    readonly content_json: FieldRef<"Chapter", 'Json'>
    readonly version_id: FieldRef<"Chapter", 'String'>
    readonly accessible_boards: FieldRef<"Chapter", 'String[]'>
    readonly is_global: FieldRef<"Chapter", 'Boolean'>
    readonly is_active: FieldRef<"Chapter", 'Boolean'>
    readonly processing_status: FieldRef<"Chapter", 'ChapterStatus'>
    readonly error_message: FieldRef<"Chapter", 'String'>
    readonly processed_at: FieldRef<"Chapter", 'DateTime'>
    readonly created_at: FieldRef<"Chapter", 'DateTime'>
    readonly updated_at: FieldRef<"Chapter", 'DateTime'>
    readonly parsed_at: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter.chunks
   */
  export type Chapter$chunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    where?: ChapterChunkWhereInput
    orderBy?: ChapterChunkOrderByWithRelationInput | ChapterChunkOrderByWithRelationInput[]
    cursor?: ChapterChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterChunkScalarFieldEnum | ChapterChunkScalarFieldEnum[]
  }

  /**
   * Chapter.pages
   */
  export type Chapter$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    where?: ChapterPageWhereInput
    orderBy?: ChapterPageOrderByWithRelationInput | ChapterPageOrderByWithRelationInput[]
    cursor?: ChapterPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterPageScalarFieldEnum | ChapterPageScalarFieldEnum[]
  }

  /**
   * Chapter.quizzes
   */
  export type Chapter$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Chapter.study_materials
   */
  export type Chapter$study_materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    where?: StudyMaterialWhereInput
  }

  /**
   * Chapter.learning_sessions
   */
  export type Chapter$learning_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    cursor?: LearningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * Chapter.conversations
   */
  export type Chapter$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Chapter.questions
   */
  export type Chapter$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model ChapterChunk
   */

  export type AggregateChapterChunk = {
    _count: ChapterChunkCountAggregateOutputType | null
    _avg: ChapterChunkAvgAggregateOutputType | null
    _sum: ChapterChunkSumAggregateOutputType | null
    _min: ChapterChunkMinAggregateOutputType | null
    _max: ChapterChunkMaxAggregateOutputType | null
  }

  export type ChapterChunkAvgAggregateOutputType = {
    id: number | null
    chapter_id: number | null
    chunk_index: number | null
    page_number: number | null
    subject_id: number | null
  }

  export type ChapterChunkSumAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    chunk_index: number | null
    page_number: number | null
    subject_id: number | null
  }

  export type ChapterChunkMinAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    chunk_index: number | null
    content: string | null
    page_number: number | null
    subject_id: number | null
    created_at: Date | null
  }

  export type ChapterChunkMaxAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    chunk_index: number | null
    content: string | null
    page_number: number | null
    subject_id: number | null
    created_at: Date | null
  }

  export type ChapterChunkCountAggregateOutputType = {
    id: number
    chapter_id: number
    chunk_index: number
    content: number
    page_number: number
    bbox: number
    subject_id: number
    created_at: number
    _all: number
  }


  export type ChapterChunkAvgAggregateInputType = {
    id?: true
    chapter_id?: true
    chunk_index?: true
    page_number?: true
    subject_id?: true
  }

  export type ChapterChunkSumAggregateInputType = {
    id?: true
    chapter_id?: true
    chunk_index?: true
    page_number?: true
    subject_id?: true
  }

  export type ChapterChunkMinAggregateInputType = {
    id?: true
    chapter_id?: true
    chunk_index?: true
    content?: true
    page_number?: true
    subject_id?: true
    created_at?: true
  }

  export type ChapterChunkMaxAggregateInputType = {
    id?: true
    chapter_id?: true
    chunk_index?: true
    content?: true
    page_number?: true
    subject_id?: true
    created_at?: true
  }

  export type ChapterChunkCountAggregateInputType = {
    id?: true
    chapter_id?: true
    chunk_index?: true
    content?: true
    page_number?: true
    bbox?: true
    subject_id?: true
    created_at?: true
    _all?: true
  }

  export type ChapterChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterChunk to aggregate.
     */
    where?: ChapterChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunks to fetch.
     */
    orderBy?: ChapterChunkOrderByWithRelationInput | ChapterChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterChunks
    **/
    _count?: true | ChapterChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterChunkMaxAggregateInputType
  }

  export type GetChapterChunkAggregateType<T extends ChapterChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterChunk[P]>
      : GetScalarType<T[P], AggregateChapterChunk[P]>
  }




  export type ChapterChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChunkWhereInput
    orderBy?: ChapterChunkOrderByWithAggregationInput | ChapterChunkOrderByWithAggregationInput[]
    by: ChapterChunkScalarFieldEnum[] | ChapterChunkScalarFieldEnum
    having?: ChapterChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterChunkCountAggregateInputType | true
    _avg?: ChapterChunkAvgAggregateInputType
    _sum?: ChapterChunkSumAggregateInputType
    _min?: ChapterChunkMinAggregateInputType
    _max?: ChapterChunkMaxAggregateInputType
  }

  export type ChapterChunkGroupByOutputType = {
    id: bigint
    chapter_id: bigint
    chunk_index: number
    content: string
    page_number: number | null
    bbox: JsonValue | null
    subject_id: number | null
    created_at: Date
    _count: ChapterChunkCountAggregateOutputType | null
    _avg: ChapterChunkAvgAggregateOutputType | null
    _sum: ChapterChunkSumAggregateOutputType | null
    _min: ChapterChunkMinAggregateOutputType | null
    _max: ChapterChunkMaxAggregateOutputType | null
  }

  type GetChapterChunkGroupByPayload<T extends ChapterChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterChunkGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterChunkGroupByOutputType[P]>
        }
      >
    >


  export type ChapterChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    subject_id?: boolean
    created_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    chunkBoards?: boolean | ChapterChunk$chunkBoardsArgs<ExtArgs>
    _count?: boolean | ChapterChunkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChunk"]>

  export type ChapterChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    subject_id?: boolean
    created_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChunk"]>

  export type ChapterChunkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    subject_id?: boolean
    created_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChunk"]>

  export type ChapterChunkSelectScalar = {
    id?: boolean
    chapter_id?: boolean
    chunk_index?: boolean
    content?: boolean
    page_number?: boolean
    bbox?: boolean
    subject_id?: boolean
    created_at?: boolean
  }

  export type ChapterChunkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapter_id" | "chunk_index" | "content" | "page_number" | "bbox" | "subject_id" | "created_at", ExtArgs["result"]["chapterChunk"]>
  export type ChapterChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    chunkBoards?: boolean | ChapterChunk$chunkBoardsArgs<ExtArgs>
    _count?: boolean | ChapterChunkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ChapterChunkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $ChapterChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterChunk"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
      chunkBoards: Prisma.$ChapterChunkBoardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      chapter_id: bigint
      chunk_index: number
      content: string
      page_number: number | null
      bbox: Prisma.JsonValue | null
      subject_id: number | null
      created_at: Date
    }, ExtArgs["result"]["chapterChunk"]>
    composites: {}
  }

  type ChapterChunkGetPayload<S extends boolean | null | undefined | ChapterChunkDefaultArgs> = $Result.GetResult<Prisma.$ChapterChunkPayload, S>

  type ChapterChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterChunkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterChunkCountAggregateInputType | true
    }

  export interface ChapterChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterChunk'], meta: { name: 'ChapterChunk' } }
    /**
     * Find zero or one ChapterChunk that matches the filter.
     * @param {ChapterChunkFindUniqueArgs} args - Arguments to find a ChapterChunk
     * @example
     * // Get one ChapterChunk
     * const chapterChunk = await prisma.chapterChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterChunkFindUniqueArgs>(args: SelectSubset<T, ChapterChunkFindUniqueArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChapterChunk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterChunkFindUniqueOrThrowArgs} args - Arguments to find a ChapterChunk
     * @example
     * // Get one ChapterChunk
     * const chapterChunk = await prisma.chapterChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkFindFirstArgs} args - Arguments to find a ChapterChunk
     * @example
     * // Get one ChapterChunk
     * const chapterChunk = await prisma.chapterChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterChunkFindFirstArgs>(args?: SelectSubset<T, ChapterChunkFindFirstArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkFindFirstOrThrowArgs} args - Arguments to find a ChapterChunk
     * @example
     * // Get one ChapterChunk
     * const chapterChunk = await prisma.chapterChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChapterChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterChunks
     * const chapterChunks = await prisma.chapterChunk.findMany()
     * 
     * // Get first 10 ChapterChunks
     * const chapterChunks = await prisma.chapterChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterChunkWithIdOnly = await prisma.chapterChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterChunkFindManyArgs>(args?: SelectSubset<T, ChapterChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChapterChunk.
     * @param {ChapterChunkCreateArgs} args - Arguments to create a ChapterChunk.
     * @example
     * // Create one ChapterChunk
     * const ChapterChunk = await prisma.chapterChunk.create({
     *   data: {
     *     // ... data to create a ChapterChunk
     *   }
     * })
     * 
     */
    create<T extends ChapterChunkCreateArgs>(args: SelectSubset<T, ChapterChunkCreateArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChapterChunks.
     * @param {ChapterChunkCreateManyArgs} args - Arguments to create many ChapterChunks.
     * @example
     * // Create many ChapterChunks
     * const chapterChunk = await prisma.chapterChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterChunkCreateManyArgs>(args?: SelectSubset<T, ChapterChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterChunks and returns the data saved in the database.
     * @param {ChapterChunkCreateManyAndReturnArgs} args - Arguments to create many ChapterChunks.
     * @example
     * // Create many ChapterChunks
     * const chapterChunk = await prisma.chapterChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterChunks and only return the `id`
     * const chapterChunkWithIdOnly = await prisma.chapterChunk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChapterChunk.
     * @param {ChapterChunkDeleteArgs} args - Arguments to delete one ChapterChunk.
     * @example
     * // Delete one ChapterChunk
     * const ChapterChunk = await prisma.chapterChunk.delete({
     *   where: {
     *     // ... filter to delete one ChapterChunk
     *   }
     * })
     * 
     */
    delete<T extends ChapterChunkDeleteArgs>(args: SelectSubset<T, ChapterChunkDeleteArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChapterChunk.
     * @param {ChapterChunkUpdateArgs} args - Arguments to update one ChapterChunk.
     * @example
     * // Update one ChapterChunk
     * const chapterChunk = await prisma.chapterChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterChunkUpdateArgs>(args: SelectSubset<T, ChapterChunkUpdateArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChapterChunks.
     * @param {ChapterChunkDeleteManyArgs} args - Arguments to filter ChapterChunks to delete.
     * @example
     * // Delete a few ChapterChunks
     * const { count } = await prisma.chapterChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterChunkDeleteManyArgs>(args?: SelectSubset<T, ChapterChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterChunks
     * const chapterChunk = await prisma.chapterChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterChunkUpdateManyArgs>(args: SelectSubset<T, ChapterChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterChunks and returns the data updated in the database.
     * @param {ChapterChunkUpdateManyAndReturnArgs} args - Arguments to update many ChapterChunks.
     * @example
     * // Update many ChapterChunks
     * const chapterChunk = await prisma.chapterChunk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChapterChunks and only return the `id`
     * const chapterChunkWithIdOnly = await prisma.chapterChunk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterChunkUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterChunkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChapterChunk.
     * @param {ChapterChunkUpsertArgs} args - Arguments to update or create a ChapterChunk.
     * @example
     * // Update or create a ChapterChunk
     * const chapterChunk = await prisma.chapterChunk.upsert({
     *   create: {
     *     // ... data to create a ChapterChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterChunk we want to update
     *   }
     * })
     */
    upsert<T extends ChapterChunkUpsertArgs>(args: SelectSubset<T, ChapterChunkUpsertArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChapterChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkCountArgs} args - Arguments to filter ChapterChunks to count.
     * @example
     * // Count the number of ChapterChunks
     * const count = await prisma.chapterChunk.count({
     *   where: {
     *     // ... the filter for the ChapterChunks we want to count
     *   }
     * })
    **/
    count<T extends ChapterChunkCountArgs>(
      args?: Subset<T, ChapterChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterChunkAggregateArgs>(args: Subset<T, ChapterChunkAggregateArgs>): Prisma.PrismaPromise<GetChapterChunkAggregateType<T>>

    /**
     * Group by ChapterChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterChunkGroupByArgs['orderBy'] }
        : { orderBy?: ChapterChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterChunk model
   */
  readonly fields: ChapterChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chunkBoards<T extends ChapterChunk$chunkBoardsArgs<ExtArgs> = {}>(args?: Subset<T, ChapterChunk$chunkBoardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterChunk model
   */
  interface ChapterChunkFieldRefs {
    readonly id: FieldRef<"ChapterChunk", 'BigInt'>
    readonly chapter_id: FieldRef<"ChapterChunk", 'BigInt'>
    readonly chunk_index: FieldRef<"ChapterChunk", 'Int'>
    readonly content: FieldRef<"ChapterChunk", 'String'>
    readonly page_number: FieldRef<"ChapterChunk", 'Int'>
    readonly bbox: FieldRef<"ChapterChunk", 'Json'>
    readonly subject_id: FieldRef<"ChapterChunk", 'Int'>
    readonly created_at: FieldRef<"ChapterChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterChunk findUnique
   */
  export type ChapterChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunk to fetch.
     */
    where: ChapterChunkWhereUniqueInput
  }

  /**
   * ChapterChunk findUniqueOrThrow
   */
  export type ChapterChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunk to fetch.
     */
    where: ChapterChunkWhereUniqueInput
  }

  /**
   * ChapterChunk findFirst
   */
  export type ChapterChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunk to fetch.
     */
    where?: ChapterChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunks to fetch.
     */
    orderBy?: ChapterChunkOrderByWithRelationInput | ChapterChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterChunks.
     */
    cursor?: ChapterChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterChunks.
     */
    distinct?: ChapterChunkScalarFieldEnum | ChapterChunkScalarFieldEnum[]
  }

  /**
   * ChapterChunk findFirstOrThrow
   */
  export type ChapterChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunk to fetch.
     */
    where?: ChapterChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunks to fetch.
     */
    orderBy?: ChapterChunkOrderByWithRelationInput | ChapterChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterChunks.
     */
    cursor?: ChapterChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterChunks.
     */
    distinct?: ChapterChunkScalarFieldEnum | ChapterChunkScalarFieldEnum[]
  }

  /**
   * ChapterChunk findMany
   */
  export type ChapterChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunks to fetch.
     */
    where?: ChapterChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunks to fetch.
     */
    orderBy?: ChapterChunkOrderByWithRelationInput | ChapterChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterChunks.
     */
    cursor?: ChapterChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunks.
     */
    skip?: number
    distinct?: ChapterChunkScalarFieldEnum | ChapterChunkScalarFieldEnum[]
  }

  /**
   * ChapterChunk create
   */
  export type ChapterChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterChunk.
     */
    data: XOR<ChapterChunkCreateInput, ChapterChunkUncheckedCreateInput>
  }

  /**
   * ChapterChunk createMany
   */
  export type ChapterChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterChunks.
     */
    data: ChapterChunkCreateManyInput | ChapterChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterChunk createManyAndReturn
   */
  export type ChapterChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * The data used to create many ChapterChunks.
     */
    data: ChapterChunkCreateManyInput | ChapterChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterChunk update
   */
  export type ChapterChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterChunk.
     */
    data: XOR<ChapterChunkUpdateInput, ChapterChunkUncheckedUpdateInput>
    /**
     * Choose, which ChapterChunk to update.
     */
    where: ChapterChunkWhereUniqueInput
  }

  /**
   * ChapterChunk updateMany
   */
  export type ChapterChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterChunks.
     */
    data: XOR<ChapterChunkUpdateManyMutationInput, ChapterChunkUncheckedUpdateManyInput>
    /**
     * Filter which ChapterChunks to update
     */
    where?: ChapterChunkWhereInput
    /**
     * Limit how many ChapterChunks to update.
     */
    limit?: number
  }

  /**
   * ChapterChunk updateManyAndReturn
   */
  export type ChapterChunkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * The data used to update ChapterChunks.
     */
    data: XOR<ChapterChunkUpdateManyMutationInput, ChapterChunkUncheckedUpdateManyInput>
    /**
     * Filter which ChapterChunks to update
     */
    where?: ChapterChunkWhereInput
    /**
     * Limit how many ChapterChunks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterChunk upsert
   */
  export type ChapterChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterChunk to update in case it exists.
     */
    where: ChapterChunkWhereUniqueInput
    /**
     * In case the ChapterChunk found by the `where` argument doesn't exist, create a new ChapterChunk with this data.
     */
    create: XOR<ChapterChunkCreateInput, ChapterChunkUncheckedCreateInput>
    /**
     * In case the ChapterChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterChunkUpdateInput, ChapterChunkUncheckedUpdateInput>
  }

  /**
   * ChapterChunk delete
   */
  export type ChapterChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
    /**
     * Filter which ChapterChunk to delete.
     */
    where: ChapterChunkWhereUniqueInput
  }

  /**
   * ChapterChunk deleteMany
   */
  export type ChapterChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterChunks to delete
     */
    where?: ChapterChunkWhereInput
    /**
     * Limit how many ChapterChunks to delete.
     */
    limit?: number
  }

  /**
   * ChapterChunk.chunkBoards
   */
  export type ChapterChunk$chunkBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    where?: ChapterChunkBoardWhereInput
    orderBy?: ChapterChunkBoardOrderByWithRelationInput | ChapterChunkBoardOrderByWithRelationInput[]
    cursor?: ChapterChunkBoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterChunkBoardScalarFieldEnum | ChapterChunkBoardScalarFieldEnum[]
  }

  /**
   * ChapterChunk without action
   */
  export type ChapterChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunk
     */
    select?: ChapterChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunk
     */
    omit?: ChapterChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkInclude<ExtArgs> | null
  }


  /**
   * Model ChapterChunkBoard
   */

  export type AggregateChapterChunkBoard = {
    _count: ChapterChunkBoardCountAggregateOutputType | null
    _avg: ChapterChunkBoardAvgAggregateOutputType | null
    _sum: ChapterChunkBoardSumAggregateOutputType | null
    _min: ChapterChunkBoardMinAggregateOutputType | null
    _max: ChapterChunkBoardMaxAggregateOutputType | null
  }

  export type ChapterChunkBoardAvgAggregateOutputType = {
    chunk_id: number | null
  }

  export type ChapterChunkBoardSumAggregateOutputType = {
    chunk_id: bigint | null
  }

  export type ChapterChunkBoardMinAggregateOutputType = {
    chunk_id: bigint | null
    board_id: string | null
  }

  export type ChapterChunkBoardMaxAggregateOutputType = {
    chunk_id: bigint | null
    board_id: string | null
  }

  export type ChapterChunkBoardCountAggregateOutputType = {
    chunk_id: number
    board_id: number
    _all: number
  }


  export type ChapterChunkBoardAvgAggregateInputType = {
    chunk_id?: true
  }

  export type ChapterChunkBoardSumAggregateInputType = {
    chunk_id?: true
  }

  export type ChapterChunkBoardMinAggregateInputType = {
    chunk_id?: true
    board_id?: true
  }

  export type ChapterChunkBoardMaxAggregateInputType = {
    chunk_id?: true
    board_id?: true
  }

  export type ChapterChunkBoardCountAggregateInputType = {
    chunk_id?: true
    board_id?: true
    _all?: true
  }

  export type ChapterChunkBoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterChunkBoard to aggregate.
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunkBoards to fetch.
     */
    orderBy?: ChapterChunkBoardOrderByWithRelationInput | ChapterChunkBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterChunkBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunkBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunkBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterChunkBoards
    **/
    _count?: true | ChapterChunkBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterChunkBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterChunkBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterChunkBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterChunkBoardMaxAggregateInputType
  }

  export type GetChapterChunkBoardAggregateType<T extends ChapterChunkBoardAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterChunkBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterChunkBoard[P]>
      : GetScalarType<T[P], AggregateChapterChunkBoard[P]>
  }




  export type ChapterChunkBoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterChunkBoardWhereInput
    orderBy?: ChapterChunkBoardOrderByWithAggregationInput | ChapterChunkBoardOrderByWithAggregationInput[]
    by: ChapterChunkBoardScalarFieldEnum[] | ChapterChunkBoardScalarFieldEnum
    having?: ChapterChunkBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterChunkBoardCountAggregateInputType | true
    _avg?: ChapterChunkBoardAvgAggregateInputType
    _sum?: ChapterChunkBoardSumAggregateInputType
    _min?: ChapterChunkBoardMinAggregateInputType
    _max?: ChapterChunkBoardMaxAggregateInputType
  }

  export type ChapterChunkBoardGroupByOutputType = {
    chunk_id: bigint
    board_id: string
    _count: ChapterChunkBoardCountAggregateOutputType | null
    _avg: ChapterChunkBoardAvgAggregateOutputType | null
    _sum: ChapterChunkBoardSumAggregateOutputType | null
    _min: ChapterChunkBoardMinAggregateOutputType | null
    _max: ChapterChunkBoardMaxAggregateOutputType | null
  }

  type GetChapterChunkBoardGroupByPayload<T extends ChapterChunkBoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterChunkBoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterChunkBoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterChunkBoardGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterChunkBoardGroupByOutputType[P]>
        }
      >
    >


  export type ChapterChunkBoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chunk_id?: boolean
    board_id?: boolean
    chunk?: boolean | ChapterChunkDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChunkBoard"]>

  export type ChapterChunkBoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chunk_id?: boolean
    board_id?: boolean
    chunk?: boolean | ChapterChunkDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChunkBoard"]>

  export type ChapterChunkBoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chunk_id?: boolean
    board_id?: boolean
    chunk?: boolean | ChapterChunkDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterChunkBoard"]>

  export type ChapterChunkBoardSelectScalar = {
    chunk_id?: boolean
    board_id?: boolean
  }

  export type ChapterChunkBoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chunk_id" | "board_id", ExtArgs["result"]["chapterChunkBoard"]>
  export type ChapterChunkBoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunk?: boolean | ChapterChunkDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type ChapterChunkBoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunk?: boolean | ChapterChunkDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type ChapterChunkBoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunk?: boolean | ChapterChunkDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $ChapterChunkBoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterChunkBoard"
    objects: {
      chunk: Prisma.$ChapterChunkPayload<ExtArgs>
      board: Prisma.$BoardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      chunk_id: bigint
      board_id: string
    }, ExtArgs["result"]["chapterChunkBoard"]>
    composites: {}
  }

  type ChapterChunkBoardGetPayload<S extends boolean | null | undefined | ChapterChunkBoardDefaultArgs> = $Result.GetResult<Prisma.$ChapterChunkBoardPayload, S>

  type ChapterChunkBoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterChunkBoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterChunkBoardCountAggregateInputType | true
    }

  export interface ChapterChunkBoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterChunkBoard'], meta: { name: 'ChapterChunkBoard' } }
    /**
     * Find zero or one ChapterChunkBoard that matches the filter.
     * @param {ChapterChunkBoardFindUniqueArgs} args - Arguments to find a ChapterChunkBoard
     * @example
     * // Get one ChapterChunkBoard
     * const chapterChunkBoard = await prisma.chapterChunkBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterChunkBoardFindUniqueArgs>(args: SelectSubset<T, ChapterChunkBoardFindUniqueArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChapterChunkBoard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterChunkBoardFindUniqueOrThrowArgs} args - Arguments to find a ChapterChunkBoard
     * @example
     * // Get one ChapterChunkBoard
     * const chapterChunkBoard = await prisma.chapterChunkBoard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterChunkBoardFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterChunkBoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterChunkBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardFindFirstArgs} args - Arguments to find a ChapterChunkBoard
     * @example
     * // Get one ChapterChunkBoard
     * const chapterChunkBoard = await prisma.chapterChunkBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterChunkBoardFindFirstArgs>(args?: SelectSubset<T, ChapterChunkBoardFindFirstArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterChunkBoard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardFindFirstOrThrowArgs} args - Arguments to find a ChapterChunkBoard
     * @example
     * // Get one ChapterChunkBoard
     * const chapterChunkBoard = await prisma.chapterChunkBoard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterChunkBoardFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterChunkBoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChapterChunkBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterChunkBoards
     * const chapterChunkBoards = await prisma.chapterChunkBoard.findMany()
     * 
     * // Get first 10 ChapterChunkBoards
     * const chapterChunkBoards = await prisma.chapterChunkBoard.findMany({ take: 10 })
     * 
     * // Only select the `chunk_id`
     * const chapterChunkBoardWithChunk_idOnly = await prisma.chapterChunkBoard.findMany({ select: { chunk_id: true } })
     * 
     */
    findMany<T extends ChapterChunkBoardFindManyArgs>(args?: SelectSubset<T, ChapterChunkBoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChapterChunkBoard.
     * @param {ChapterChunkBoardCreateArgs} args - Arguments to create a ChapterChunkBoard.
     * @example
     * // Create one ChapterChunkBoard
     * const ChapterChunkBoard = await prisma.chapterChunkBoard.create({
     *   data: {
     *     // ... data to create a ChapterChunkBoard
     *   }
     * })
     * 
     */
    create<T extends ChapterChunkBoardCreateArgs>(args: SelectSubset<T, ChapterChunkBoardCreateArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChapterChunkBoards.
     * @param {ChapterChunkBoardCreateManyArgs} args - Arguments to create many ChapterChunkBoards.
     * @example
     * // Create many ChapterChunkBoards
     * const chapterChunkBoard = await prisma.chapterChunkBoard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterChunkBoardCreateManyArgs>(args?: SelectSubset<T, ChapterChunkBoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterChunkBoards and returns the data saved in the database.
     * @param {ChapterChunkBoardCreateManyAndReturnArgs} args - Arguments to create many ChapterChunkBoards.
     * @example
     * // Create many ChapterChunkBoards
     * const chapterChunkBoard = await prisma.chapterChunkBoard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterChunkBoards and only return the `chunk_id`
     * const chapterChunkBoardWithChunk_idOnly = await prisma.chapterChunkBoard.createManyAndReturn({
     *   select: { chunk_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterChunkBoardCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterChunkBoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChapterChunkBoard.
     * @param {ChapterChunkBoardDeleteArgs} args - Arguments to delete one ChapterChunkBoard.
     * @example
     * // Delete one ChapterChunkBoard
     * const ChapterChunkBoard = await prisma.chapterChunkBoard.delete({
     *   where: {
     *     // ... filter to delete one ChapterChunkBoard
     *   }
     * })
     * 
     */
    delete<T extends ChapterChunkBoardDeleteArgs>(args: SelectSubset<T, ChapterChunkBoardDeleteArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChapterChunkBoard.
     * @param {ChapterChunkBoardUpdateArgs} args - Arguments to update one ChapterChunkBoard.
     * @example
     * // Update one ChapterChunkBoard
     * const chapterChunkBoard = await prisma.chapterChunkBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterChunkBoardUpdateArgs>(args: SelectSubset<T, ChapterChunkBoardUpdateArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChapterChunkBoards.
     * @param {ChapterChunkBoardDeleteManyArgs} args - Arguments to filter ChapterChunkBoards to delete.
     * @example
     * // Delete a few ChapterChunkBoards
     * const { count } = await prisma.chapterChunkBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterChunkBoardDeleteManyArgs>(args?: SelectSubset<T, ChapterChunkBoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterChunkBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterChunkBoards
     * const chapterChunkBoard = await prisma.chapterChunkBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterChunkBoardUpdateManyArgs>(args: SelectSubset<T, ChapterChunkBoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterChunkBoards and returns the data updated in the database.
     * @param {ChapterChunkBoardUpdateManyAndReturnArgs} args - Arguments to update many ChapterChunkBoards.
     * @example
     * // Update many ChapterChunkBoards
     * const chapterChunkBoard = await prisma.chapterChunkBoard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChapterChunkBoards and only return the `chunk_id`
     * const chapterChunkBoardWithChunk_idOnly = await prisma.chapterChunkBoard.updateManyAndReturn({
     *   select: { chunk_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterChunkBoardUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterChunkBoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChapterChunkBoard.
     * @param {ChapterChunkBoardUpsertArgs} args - Arguments to update or create a ChapterChunkBoard.
     * @example
     * // Update or create a ChapterChunkBoard
     * const chapterChunkBoard = await prisma.chapterChunkBoard.upsert({
     *   create: {
     *     // ... data to create a ChapterChunkBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterChunkBoard we want to update
     *   }
     * })
     */
    upsert<T extends ChapterChunkBoardUpsertArgs>(args: SelectSubset<T, ChapterChunkBoardUpsertArgs<ExtArgs>>): Prisma__ChapterChunkBoardClient<$Result.GetResult<Prisma.$ChapterChunkBoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChapterChunkBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardCountArgs} args - Arguments to filter ChapterChunkBoards to count.
     * @example
     * // Count the number of ChapterChunkBoards
     * const count = await prisma.chapterChunkBoard.count({
     *   where: {
     *     // ... the filter for the ChapterChunkBoards we want to count
     *   }
     * })
    **/
    count<T extends ChapterChunkBoardCountArgs>(
      args?: Subset<T, ChapterChunkBoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterChunkBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterChunkBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterChunkBoardAggregateArgs>(args: Subset<T, ChapterChunkBoardAggregateArgs>): Prisma.PrismaPromise<GetChapterChunkBoardAggregateType<T>>

    /**
     * Group by ChapterChunkBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterChunkBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterChunkBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterChunkBoardGroupByArgs['orderBy'] }
        : { orderBy?: ChapterChunkBoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterChunkBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterChunkBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterChunkBoard model
   */
  readonly fields: ChapterChunkBoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterChunkBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterChunkBoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chunk<T extends ChapterChunkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterChunkDefaultArgs<ExtArgs>>): Prisma__ChapterChunkClient<$Result.GetResult<Prisma.$ChapterChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterChunkBoard model
   */
  interface ChapterChunkBoardFieldRefs {
    readonly chunk_id: FieldRef<"ChapterChunkBoard", 'BigInt'>
    readonly board_id: FieldRef<"ChapterChunkBoard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChapterChunkBoard findUnique
   */
  export type ChapterChunkBoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunkBoard to fetch.
     */
    where: ChapterChunkBoardWhereUniqueInput
  }

  /**
   * ChapterChunkBoard findUniqueOrThrow
   */
  export type ChapterChunkBoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunkBoard to fetch.
     */
    where: ChapterChunkBoardWhereUniqueInput
  }

  /**
   * ChapterChunkBoard findFirst
   */
  export type ChapterChunkBoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunkBoard to fetch.
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunkBoards to fetch.
     */
    orderBy?: ChapterChunkBoardOrderByWithRelationInput | ChapterChunkBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterChunkBoards.
     */
    cursor?: ChapterChunkBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunkBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunkBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterChunkBoards.
     */
    distinct?: ChapterChunkBoardScalarFieldEnum | ChapterChunkBoardScalarFieldEnum[]
  }

  /**
   * ChapterChunkBoard findFirstOrThrow
   */
  export type ChapterChunkBoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunkBoard to fetch.
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunkBoards to fetch.
     */
    orderBy?: ChapterChunkBoardOrderByWithRelationInput | ChapterChunkBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterChunkBoards.
     */
    cursor?: ChapterChunkBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunkBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunkBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterChunkBoards.
     */
    distinct?: ChapterChunkBoardScalarFieldEnum | ChapterChunkBoardScalarFieldEnum[]
  }

  /**
   * ChapterChunkBoard findMany
   */
  export type ChapterChunkBoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * Filter, which ChapterChunkBoards to fetch.
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterChunkBoards to fetch.
     */
    orderBy?: ChapterChunkBoardOrderByWithRelationInput | ChapterChunkBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterChunkBoards.
     */
    cursor?: ChapterChunkBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterChunkBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterChunkBoards.
     */
    skip?: number
    distinct?: ChapterChunkBoardScalarFieldEnum | ChapterChunkBoardScalarFieldEnum[]
  }

  /**
   * ChapterChunkBoard create
   */
  export type ChapterChunkBoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterChunkBoard.
     */
    data: XOR<ChapterChunkBoardCreateInput, ChapterChunkBoardUncheckedCreateInput>
  }

  /**
   * ChapterChunkBoard createMany
   */
  export type ChapterChunkBoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterChunkBoards.
     */
    data: ChapterChunkBoardCreateManyInput | ChapterChunkBoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterChunkBoard createManyAndReturn
   */
  export type ChapterChunkBoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * The data used to create many ChapterChunkBoards.
     */
    data: ChapterChunkBoardCreateManyInput | ChapterChunkBoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterChunkBoard update
   */
  export type ChapterChunkBoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterChunkBoard.
     */
    data: XOR<ChapterChunkBoardUpdateInput, ChapterChunkBoardUncheckedUpdateInput>
    /**
     * Choose, which ChapterChunkBoard to update.
     */
    where: ChapterChunkBoardWhereUniqueInput
  }

  /**
   * ChapterChunkBoard updateMany
   */
  export type ChapterChunkBoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterChunkBoards.
     */
    data: XOR<ChapterChunkBoardUpdateManyMutationInput, ChapterChunkBoardUncheckedUpdateManyInput>
    /**
     * Filter which ChapterChunkBoards to update
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * Limit how many ChapterChunkBoards to update.
     */
    limit?: number
  }

  /**
   * ChapterChunkBoard updateManyAndReturn
   */
  export type ChapterChunkBoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * The data used to update ChapterChunkBoards.
     */
    data: XOR<ChapterChunkBoardUpdateManyMutationInput, ChapterChunkBoardUncheckedUpdateManyInput>
    /**
     * Filter which ChapterChunkBoards to update
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * Limit how many ChapterChunkBoards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterChunkBoard upsert
   */
  export type ChapterChunkBoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterChunkBoard to update in case it exists.
     */
    where: ChapterChunkBoardWhereUniqueInput
    /**
     * In case the ChapterChunkBoard found by the `where` argument doesn't exist, create a new ChapterChunkBoard with this data.
     */
    create: XOR<ChapterChunkBoardCreateInput, ChapterChunkBoardUncheckedCreateInput>
    /**
     * In case the ChapterChunkBoard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterChunkBoardUpdateInput, ChapterChunkBoardUncheckedUpdateInput>
  }

  /**
   * ChapterChunkBoard delete
   */
  export type ChapterChunkBoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
    /**
     * Filter which ChapterChunkBoard to delete.
     */
    where: ChapterChunkBoardWhereUniqueInput
  }

  /**
   * ChapterChunkBoard deleteMany
   */
  export type ChapterChunkBoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterChunkBoards to delete
     */
    where?: ChapterChunkBoardWhereInput
    /**
     * Limit how many ChapterChunkBoards to delete.
     */
    limit?: number
  }

  /**
   * ChapterChunkBoard without action
   */
  export type ChapterChunkBoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterChunkBoard
     */
    select?: ChapterChunkBoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterChunkBoard
     */
    omit?: ChapterChunkBoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterChunkBoardInclude<ExtArgs> | null
  }


  /**
   * Model ChapterPage
   */

  export type AggregateChapterPage = {
    _count: ChapterPageCountAggregateOutputType | null
    _avg: ChapterPageAvgAggregateOutputType | null
    _sum: ChapterPageSumAggregateOutputType | null
    _min: ChapterPageMinAggregateOutputType | null
    _max: ChapterPageMaxAggregateOutputType | null
  }

  export type ChapterPageAvgAggregateOutputType = {
    id: number | null
    chapter_id: number | null
    page_number: number | null
    width: number | null
    height: number | null
  }

  export type ChapterPageSumAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    page_number: number | null
    width: number | null
    height: number | null
  }

  export type ChapterPageMinAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    page_number: number | null
    image_url: string | null
    width: number | null
    height: number | null
    created_at: Date | null
  }

  export type ChapterPageMaxAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    page_number: number | null
    image_url: string | null
    width: number | null
    height: number | null
    created_at: Date | null
  }

  export type ChapterPageCountAggregateOutputType = {
    id: number
    chapter_id: number
    page_number: number
    image_url: number
    width: number
    height: number
    created_at: number
    _all: number
  }


  export type ChapterPageAvgAggregateInputType = {
    id?: true
    chapter_id?: true
    page_number?: true
    width?: true
    height?: true
  }

  export type ChapterPageSumAggregateInputType = {
    id?: true
    chapter_id?: true
    page_number?: true
    width?: true
    height?: true
  }

  export type ChapterPageMinAggregateInputType = {
    id?: true
    chapter_id?: true
    page_number?: true
    image_url?: true
    width?: true
    height?: true
    created_at?: true
  }

  export type ChapterPageMaxAggregateInputType = {
    id?: true
    chapter_id?: true
    page_number?: true
    image_url?: true
    width?: true
    height?: true
    created_at?: true
  }

  export type ChapterPageCountAggregateInputType = {
    id?: true
    chapter_id?: true
    page_number?: true
    image_url?: true
    width?: true
    height?: true
    created_at?: true
    _all?: true
  }

  export type ChapterPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterPage to aggregate.
     */
    where?: ChapterPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterPages to fetch.
     */
    orderBy?: ChapterPageOrderByWithRelationInput | ChapterPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterPages
    **/
    _count?: true | ChapterPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterPageMaxAggregateInputType
  }

  export type GetChapterPageAggregateType<T extends ChapterPageAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterPage[P]>
      : GetScalarType<T[P], AggregateChapterPage[P]>
  }




  export type ChapterPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterPageWhereInput
    orderBy?: ChapterPageOrderByWithAggregationInput | ChapterPageOrderByWithAggregationInput[]
    by: ChapterPageScalarFieldEnum[] | ChapterPageScalarFieldEnum
    having?: ChapterPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterPageCountAggregateInputType | true
    _avg?: ChapterPageAvgAggregateInputType
    _sum?: ChapterPageSumAggregateInputType
    _min?: ChapterPageMinAggregateInputType
    _max?: ChapterPageMaxAggregateInputType
  }

  export type ChapterPageGroupByOutputType = {
    id: bigint
    chapter_id: bigint
    page_number: number
    image_url: string
    width: number | null
    height: number | null
    created_at: Date
    _count: ChapterPageCountAggregateOutputType | null
    _avg: ChapterPageAvgAggregateOutputType | null
    _sum: ChapterPageSumAggregateOutputType | null
    _min: ChapterPageMinAggregateOutputType | null
    _max: ChapterPageMaxAggregateOutputType | null
  }

  type GetChapterPageGroupByPayload<T extends ChapterPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterPageGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterPageGroupByOutputType[P]>
        }
      >
    >


  export type ChapterPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterPage"]>

  export type ChapterPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterPage"]>

  export type ChapterPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterPage"]>

  export type ChapterPageSelectScalar = {
    id?: boolean
    chapter_id?: boolean
    page_number?: boolean
    image_url?: boolean
    width?: boolean
    height?: boolean
    created_at?: boolean
  }

  export type ChapterPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapter_id" | "page_number" | "image_url" | "width" | "height" | "created_at", ExtArgs["result"]["chapterPage"]>
  export type ChapterPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ChapterPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ChapterPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $ChapterPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterPage"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      chapter_id: bigint
      page_number: number
      image_url: string
      width: number | null
      height: number | null
      created_at: Date
    }, ExtArgs["result"]["chapterPage"]>
    composites: {}
  }

  type ChapterPageGetPayload<S extends boolean | null | undefined | ChapterPageDefaultArgs> = $Result.GetResult<Prisma.$ChapterPagePayload, S>

  type ChapterPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterPageCountAggregateInputType | true
    }

  export interface ChapterPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterPage'], meta: { name: 'ChapterPage' } }
    /**
     * Find zero or one ChapterPage that matches the filter.
     * @param {ChapterPageFindUniqueArgs} args - Arguments to find a ChapterPage
     * @example
     * // Get one ChapterPage
     * const chapterPage = await prisma.chapterPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterPageFindUniqueArgs>(args: SelectSubset<T, ChapterPageFindUniqueArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChapterPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterPageFindUniqueOrThrowArgs} args - Arguments to find a ChapterPage
     * @example
     * // Get one ChapterPage
     * const chapterPage = await prisma.chapterPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterPageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageFindFirstArgs} args - Arguments to find a ChapterPage
     * @example
     * // Get one ChapterPage
     * const chapterPage = await prisma.chapterPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterPageFindFirstArgs>(args?: SelectSubset<T, ChapterPageFindFirstArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageFindFirstOrThrowArgs} args - Arguments to find a ChapterPage
     * @example
     * // Get one ChapterPage
     * const chapterPage = await prisma.chapterPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterPageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChapterPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterPages
     * const chapterPages = await prisma.chapterPage.findMany()
     * 
     * // Get first 10 ChapterPages
     * const chapterPages = await prisma.chapterPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterPageWithIdOnly = await prisma.chapterPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterPageFindManyArgs>(args?: SelectSubset<T, ChapterPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChapterPage.
     * @param {ChapterPageCreateArgs} args - Arguments to create a ChapterPage.
     * @example
     * // Create one ChapterPage
     * const ChapterPage = await prisma.chapterPage.create({
     *   data: {
     *     // ... data to create a ChapterPage
     *   }
     * })
     * 
     */
    create<T extends ChapterPageCreateArgs>(args: SelectSubset<T, ChapterPageCreateArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChapterPages.
     * @param {ChapterPageCreateManyArgs} args - Arguments to create many ChapterPages.
     * @example
     * // Create many ChapterPages
     * const chapterPage = await prisma.chapterPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterPageCreateManyArgs>(args?: SelectSubset<T, ChapterPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterPages and returns the data saved in the database.
     * @param {ChapterPageCreateManyAndReturnArgs} args - Arguments to create many ChapterPages.
     * @example
     * // Create many ChapterPages
     * const chapterPage = await prisma.chapterPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterPages and only return the `id`
     * const chapterPageWithIdOnly = await prisma.chapterPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterPageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChapterPage.
     * @param {ChapterPageDeleteArgs} args - Arguments to delete one ChapterPage.
     * @example
     * // Delete one ChapterPage
     * const ChapterPage = await prisma.chapterPage.delete({
     *   where: {
     *     // ... filter to delete one ChapterPage
     *   }
     * })
     * 
     */
    delete<T extends ChapterPageDeleteArgs>(args: SelectSubset<T, ChapterPageDeleteArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChapterPage.
     * @param {ChapterPageUpdateArgs} args - Arguments to update one ChapterPage.
     * @example
     * // Update one ChapterPage
     * const chapterPage = await prisma.chapterPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterPageUpdateArgs>(args: SelectSubset<T, ChapterPageUpdateArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChapterPages.
     * @param {ChapterPageDeleteManyArgs} args - Arguments to filter ChapterPages to delete.
     * @example
     * // Delete a few ChapterPages
     * const { count } = await prisma.chapterPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterPageDeleteManyArgs>(args?: SelectSubset<T, ChapterPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterPages
     * const chapterPage = await prisma.chapterPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterPageUpdateManyArgs>(args: SelectSubset<T, ChapterPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterPages and returns the data updated in the database.
     * @param {ChapterPageUpdateManyAndReturnArgs} args - Arguments to update many ChapterPages.
     * @example
     * // Update many ChapterPages
     * const chapterPage = await prisma.chapterPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChapterPages and only return the `id`
     * const chapterPageWithIdOnly = await prisma.chapterPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterPageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChapterPage.
     * @param {ChapterPageUpsertArgs} args - Arguments to update or create a ChapterPage.
     * @example
     * // Update or create a ChapterPage
     * const chapterPage = await prisma.chapterPage.upsert({
     *   create: {
     *     // ... data to create a ChapterPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterPage we want to update
     *   }
     * })
     */
    upsert<T extends ChapterPageUpsertArgs>(args: SelectSubset<T, ChapterPageUpsertArgs<ExtArgs>>): Prisma__ChapterPageClient<$Result.GetResult<Prisma.$ChapterPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChapterPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageCountArgs} args - Arguments to filter ChapterPages to count.
     * @example
     * // Count the number of ChapterPages
     * const count = await prisma.chapterPage.count({
     *   where: {
     *     // ... the filter for the ChapterPages we want to count
     *   }
     * })
    **/
    count<T extends ChapterPageCountArgs>(
      args?: Subset<T, ChapterPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterPageAggregateArgs>(args: Subset<T, ChapterPageAggregateArgs>): Prisma.PrismaPromise<GetChapterPageAggregateType<T>>

    /**
     * Group by ChapterPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterPageGroupByArgs['orderBy'] }
        : { orderBy?: ChapterPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterPage model
   */
  readonly fields: ChapterPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterPage model
   */
  interface ChapterPageFieldRefs {
    readonly id: FieldRef<"ChapterPage", 'BigInt'>
    readonly chapter_id: FieldRef<"ChapterPage", 'BigInt'>
    readonly page_number: FieldRef<"ChapterPage", 'Int'>
    readonly image_url: FieldRef<"ChapterPage", 'String'>
    readonly width: FieldRef<"ChapterPage", 'Int'>
    readonly height: FieldRef<"ChapterPage", 'Int'>
    readonly created_at: FieldRef<"ChapterPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterPage findUnique
   */
  export type ChapterPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * Filter, which ChapterPage to fetch.
     */
    where: ChapterPageWhereUniqueInput
  }

  /**
   * ChapterPage findUniqueOrThrow
   */
  export type ChapterPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * Filter, which ChapterPage to fetch.
     */
    where: ChapterPageWhereUniqueInput
  }

  /**
   * ChapterPage findFirst
   */
  export type ChapterPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * Filter, which ChapterPage to fetch.
     */
    where?: ChapterPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterPages to fetch.
     */
    orderBy?: ChapterPageOrderByWithRelationInput | ChapterPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterPages.
     */
    cursor?: ChapterPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterPages.
     */
    distinct?: ChapterPageScalarFieldEnum | ChapterPageScalarFieldEnum[]
  }

  /**
   * ChapterPage findFirstOrThrow
   */
  export type ChapterPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * Filter, which ChapterPage to fetch.
     */
    where?: ChapterPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterPages to fetch.
     */
    orderBy?: ChapterPageOrderByWithRelationInput | ChapterPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterPages.
     */
    cursor?: ChapterPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterPages.
     */
    distinct?: ChapterPageScalarFieldEnum | ChapterPageScalarFieldEnum[]
  }

  /**
   * ChapterPage findMany
   */
  export type ChapterPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * Filter, which ChapterPages to fetch.
     */
    where?: ChapterPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterPages to fetch.
     */
    orderBy?: ChapterPageOrderByWithRelationInput | ChapterPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterPages.
     */
    cursor?: ChapterPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterPages.
     */
    skip?: number
    distinct?: ChapterPageScalarFieldEnum | ChapterPageScalarFieldEnum[]
  }

  /**
   * ChapterPage create
   */
  export type ChapterPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterPage.
     */
    data: XOR<ChapterPageCreateInput, ChapterPageUncheckedCreateInput>
  }

  /**
   * ChapterPage createMany
   */
  export type ChapterPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterPages.
     */
    data: ChapterPageCreateManyInput | ChapterPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterPage createManyAndReturn
   */
  export type ChapterPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * The data used to create many ChapterPages.
     */
    data: ChapterPageCreateManyInput | ChapterPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterPage update
   */
  export type ChapterPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterPage.
     */
    data: XOR<ChapterPageUpdateInput, ChapterPageUncheckedUpdateInput>
    /**
     * Choose, which ChapterPage to update.
     */
    where: ChapterPageWhereUniqueInput
  }

  /**
   * ChapterPage updateMany
   */
  export type ChapterPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterPages.
     */
    data: XOR<ChapterPageUpdateManyMutationInput, ChapterPageUncheckedUpdateManyInput>
    /**
     * Filter which ChapterPages to update
     */
    where?: ChapterPageWhereInput
    /**
     * Limit how many ChapterPages to update.
     */
    limit?: number
  }

  /**
   * ChapterPage updateManyAndReturn
   */
  export type ChapterPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * The data used to update ChapterPages.
     */
    data: XOR<ChapterPageUpdateManyMutationInput, ChapterPageUncheckedUpdateManyInput>
    /**
     * Filter which ChapterPages to update
     */
    where?: ChapterPageWhereInput
    /**
     * Limit how many ChapterPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterPage upsert
   */
  export type ChapterPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterPage to update in case it exists.
     */
    where: ChapterPageWhereUniqueInput
    /**
     * In case the ChapterPage found by the `where` argument doesn't exist, create a new ChapterPage with this data.
     */
    create: XOR<ChapterPageCreateInput, ChapterPageUncheckedCreateInput>
    /**
     * In case the ChapterPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterPageUpdateInput, ChapterPageUncheckedUpdateInput>
  }

  /**
   * ChapterPage delete
   */
  export type ChapterPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
    /**
     * Filter which ChapterPage to delete.
     */
    where: ChapterPageWhereUniqueInput
  }

  /**
   * ChapterPage deleteMany
   */
  export type ChapterPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterPages to delete
     */
    where?: ChapterPageWhereInput
    /**
     * Limit how many ChapterPages to delete.
     */
    limit?: number
  }

  /**
   * ChapterPage without action
   */
  export type ChapterPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterPage
     */
    select?: ChapterPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterPage
     */
    omit?: ChapterPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterPageInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingSumAggregateOutputType = {
    id: number | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SystemSettingAvgAggregateInputType = {
    id?: true
  }

  export type SystemSettingSumAggregateInputType = {
    id?: true
  }

  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _avg?: SystemSettingAvgAggregateInputType
    _sum?: SystemSettingSumAggregateInputType
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    type: string
    created_at: Date
    updated_at: Date
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "type" | "created_at" | "updated_at", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'Int'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly type: FieldRef<"SystemSetting", 'String'>
    readonly created_at: FieldRef<"SystemSetting", 'DateTime'>
    readonly updated_at: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    user_id: number | null
    subject_id: number | null
    chapter_id: number | null
    score: number | null
    total_points: number | null
  }

  export type QuizSumAggregateOutputType = {
    user_id: number | null
    subject_id: number | null
    chapter_id: bigint | null
    score: number | null
    total_points: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    subject_id: number | null
    chapter_id: bigint | null
    title: string | null
    description: string | null
    status: $Enums.QuizStatus | null
    score: number | null
    total_points: number | null
    created_at: Date | null
    updated_at: Date | null
    completed_at: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    subject_id: number | null
    chapter_id: bigint | null
    title: string | null
    description: string | null
    status: $Enums.QuizStatus | null
    score: number | null
    total_points: number | null
    created_at: Date | null
    updated_at: Date | null
    completed_at: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    user_id: number
    subject_id: number
    chapter_id: number
    title: number
    description: number
    status: number
    score: number
    total_points: number
    created_at: number
    updated_at: number
    completed_at: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    user_id?: true
    subject_id?: true
    chapter_id?: true
    score?: true
    total_points?: true
  }

  export type QuizSumAggregateInputType = {
    user_id?: true
    subject_id?: true
    chapter_id?: true
    score?: true
    total_points?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    user_id?: true
    subject_id?: true
    chapter_id?: true
    title?: true
    description?: true
    status?: true
    score?: true
    total_points?: true
    created_at?: true
    updated_at?: true
    completed_at?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    user_id?: true
    subject_id?: true
    chapter_id?: true
    title?: true
    description?: true
    status?: true
    score?: true
    total_points?: true
    created_at?: true
    updated_at?: true
    completed_at?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    user_id?: true
    subject_id?: true
    chapter_id?: true
    title?: true
    description?: true
    status?: true
    score?: true
    total_points?: true
    created_at?: true
    updated_at?: true
    completed_at?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    user_id: number
    subject_id: number
    chapter_id: bigint | null
    title: string
    description: string | null
    status: $Enums.QuizStatus
    score: number
    total_points: number
    created_at: Date
    updated_at: Date
    completed_at: Date | null
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    score?: boolean
    total_points?: boolean
    created_at?: boolean
    updated_at?: boolean
    completed_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    battles?: boolean | Quiz$battlesArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    score?: boolean
    total_points?: boolean
    created_at?: boolean
    updated_at?: boolean
    completed_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    score?: boolean
    total_points?: boolean
    created_at?: boolean
    updated_at?: boolean
    completed_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    user_id?: boolean
    subject_id?: boolean
    chapter_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    score?: boolean
    total_points?: boolean
    created_at?: boolean
    updated_at?: boolean
    completed_at?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "subject_id" | "chapter_id" | "title" | "description" | "status" | "score" | "total_points" | "created_at" | "updated_at" | "completed_at", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    battles?: boolean | Quiz$battlesArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | Quiz$chapterArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs> | null
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      battles: Prisma.$BattlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      subject_id: number
      chapter_id: bigint | null
      title: string
      description: string | null
      status: $Enums.QuizStatus
      score: number
      total_points: number
      created_at: Date
      updated_at: Date
      completed_at: Date | null
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends Quiz$chapterArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$chapterArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    battles<T extends Quiz$battlesArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$battlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly user_id: FieldRef<"Quiz", 'Int'>
    readonly subject_id: FieldRef<"Quiz", 'Int'>
    readonly chapter_id: FieldRef<"Quiz", 'BigInt'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly status: FieldRef<"Quiz", 'QuizStatus'>
    readonly score: FieldRef<"Quiz", 'Int'>
    readonly total_points: FieldRef<"Quiz", 'Int'>
    readonly created_at: FieldRef<"Quiz", 'DateTime'>
    readonly updated_at: FieldRef<"Quiz", 'DateTime'>
    readonly completed_at: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.chapter
   */
  export type Quiz$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.battles
   */
  export type Quiz$battlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    cursor?: BattleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    points: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    points: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    quiz_id: string | null
    question_text: string | null
    question_type: $Enums.QuestionType | null
    is_correct: boolean | null
    points: number | null
    explanation: string | null
    feedback: string | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    quiz_id: string | null
    question_text: string | null
    question_type: $Enums.QuestionType | null
    is_correct: boolean | null
    points: number | null
    explanation: string | null
    feedback: string | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    quiz_id: number
    question_text: number
    question_type: number
    options: number
    correct_answer: number
    user_answer: number
    is_correct: number
    points: number
    explanation: number
    feedback: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    points?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    points?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    quiz_id?: true
    question_text?: true
    question_type?: true
    is_correct?: true
    points?: true
    explanation?: true
    feedback?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    quiz_id?: true
    question_text?: true
    question_type?: true
    is_correct?: true
    points?: true
    explanation?: true
    feedback?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    quiz_id?: true
    question_text?: true
    question_type?: true
    options?: true
    correct_answer?: true
    user_answer?: true
    is_correct?: true
    points?: true
    explanation?: true
    feedback?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    quiz_id: string
    question_text: string
    question_type: $Enums.QuestionType
    options: JsonValue | null
    correct_answer: JsonValue
    user_answer: JsonValue | null
    is_correct: boolean | null
    points: number
    explanation: string | null
    feedback: string | null
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    user_answer?: boolean
    is_correct?: boolean
    points?: boolean
    explanation?: boolean
    feedback?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    user_answer?: boolean
    is_correct?: boolean
    points?: boolean
    explanation?: boolean
    feedback?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    user_answer?: boolean
    is_correct?: boolean
    points?: boolean
    explanation?: boolean
    feedback?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    user_answer?: boolean
    is_correct?: boolean
    points?: boolean
    explanation?: boolean
    feedback?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quiz_id" | "question_text" | "question_type" | "options" | "correct_answer" | "user_answer" | "is_correct" | "points" | "explanation" | "feedback", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quiz_id: string
      question_text: string
      question_type: $Enums.QuestionType
      options: Prisma.JsonValue | null
      correct_answer: Prisma.JsonValue
      user_answer: Prisma.JsonValue | null
      is_correct: boolean | null
      points: number
      explanation: string | null
      feedback: string | null
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly quiz_id: FieldRef<"QuizQuestion", 'String'>
    readonly question_text: FieldRef<"QuizQuestion", 'String'>
    readonly question_type: FieldRef<"QuizQuestion", 'QuestionType'>
    readonly options: FieldRef<"QuizQuestion", 'Json'>
    readonly correct_answer: FieldRef<"QuizQuestion", 'Json'>
    readonly user_answer: FieldRef<"QuizQuestion", 'Json'>
    readonly is_correct: FieldRef<"QuizQuestion", 'Boolean'>
    readonly points: FieldRef<"QuizQuestion", 'Int'>
    readonly explanation: FieldRef<"QuizQuestion", 'String'>
    readonly feedback: FieldRef<"QuizQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    chapter_id: number | null
    points: number | null
  }

  export type QuestionSumAggregateOutputType = {
    chapter_id: bigint | null
    points: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    chapter_id: bigint | null
    question_text: string | null
    question_type: $Enums.QuestionType | null
    difficulty: string | null
    explanation: string | null
    points: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    chapter_id: bigint | null
    question_text: string | null
    question_type: $Enums.QuestionType | null
    difficulty: string | null
    explanation: string | null
    points: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    chapter_id: number
    question_text: number
    question_type: number
    difficulty: number
    options: number
    correct_answer: number
    explanation: number
    points: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    chapter_id?: true
    points?: true
  }

  export type QuestionSumAggregateInputType = {
    chapter_id?: true
    points?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    chapter_id?: true
    question_text?: true
    question_type?: true
    difficulty?: true
    explanation?: true
    points?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    chapter_id?: true
    question_text?: true
    question_type?: true
    difficulty?: true
    explanation?: true
    points?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    chapter_id?: true
    question_text?: true
    question_type?: true
    difficulty?: true
    options?: true
    correct_answer?: true
    explanation?: true
    points?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    chapter_id: bigint
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options: JsonValue | null
    correct_answer: JsonValue
    explanation: string | null
    points: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    question_text?: boolean
    question_type?: boolean
    difficulty?: boolean
    options?: boolean
    correct_answer?: boolean
    explanation?: boolean
    points?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    question_text?: boolean
    question_type?: boolean
    difficulty?: boolean
    options?: boolean
    correct_answer?: boolean
    explanation?: boolean
    points?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    question_text?: boolean
    question_type?: boolean
    difficulty?: boolean
    options?: boolean
    correct_answer?: boolean
    explanation?: boolean
    points?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    chapter_id?: boolean
    question_text?: boolean
    question_type?: boolean
    difficulty?: boolean
    options?: boolean
    correct_answer?: boolean
    explanation?: boolean
    points?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapter_id" | "question_text" | "question_type" | "difficulty" | "options" | "correct_answer" | "explanation" | "points" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapter_id: bigint
      question_text: string
      question_type: $Enums.QuestionType
      difficulty: string
      options: Prisma.JsonValue | null
      correct_answer: Prisma.JsonValue
      explanation: string | null
      points: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly chapter_id: FieldRef<"Question", 'BigInt'>
    readonly question_text: FieldRef<"Question", 'String'>
    readonly question_type: FieldRef<"Question", 'QuestionType'>
    readonly difficulty: FieldRef<"Question", 'String'>
    readonly options: FieldRef<"Question", 'Json'>
    readonly correct_answer: FieldRef<"Question", 'Json'>
    readonly explanation: FieldRef<"Question", 'String'>
    readonly points: FieldRef<"Question", 'Int'>
    readonly is_active: FieldRef<"Question", 'Boolean'>
    readonly created_at: FieldRef<"Question", 'DateTime'>
    readonly updated_at: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model UserPoints
   */

  export type AggregateUserPoints = {
    _count: UserPointsCountAggregateOutputType | null
    _avg: UserPointsAvgAggregateOutputType | null
    _sum: UserPointsSumAggregateOutputType | null
    _min: UserPointsMinAggregateOutputType | null
    _max: UserPointsMaxAggregateOutputType | null
  }

  export type UserPointsAvgAggregateOutputType = {
    user_id: number | null
    points: number | null
  }

  export type UserPointsSumAggregateOutputType = {
    user_id: number | null
    points: number | null
  }

  export type UserPointsMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    points: number | null
    reason: string | null
    created_at: Date | null
  }

  export type UserPointsMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    points: number | null
    reason: string | null
    created_at: Date | null
  }

  export type UserPointsCountAggregateOutputType = {
    id: number
    user_id: number
    points: number
    reason: number
    metadata: number
    created_at: number
    _all: number
  }


  export type UserPointsAvgAggregateInputType = {
    user_id?: true
    points?: true
  }

  export type UserPointsSumAggregateInputType = {
    user_id?: true
    points?: true
  }

  export type UserPointsMinAggregateInputType = {
    id?: true
    user_id?: true
    points?: true
    reason?: true
    created_at?: true
  }

  export type UserPointsMaxAggregateInputType = {
    id?: true
    user_id?: true
    points?: true
    reason?: true
    created_at?: true
  }

  export type UserPointsCountAggregateInputType = {
    id?: true
    user_id?: true
    points?: true
    reason?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type UserPointsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPoints to aggregate.
     */
    where?: UserPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPoints to fetch.
     */
    orderBy?: UserPointsOrderByWithRelationInput | UserPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPoints
    **/
    _count?: true | UserPointsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPointsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPointsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPointsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPointsMaxAggregateInputType
  }

  export type GetUserPointsAggregateType<T extends UserPointsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPoints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPoints[P]>
      : GetScalarType<T[P], AggregateUserPoints[P]>
  }




  export type UserPointsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPointsWhereInput
    orderBy?: UserPointsOrderByWithAggregationInput | UserPointsOrderByWithAggregationInput[]
    by: UserPointsScalarFieldEnum[] | UserPointsScalarFieldEnum
    having?: UserPointsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPointsCountAggregateInputType | true
    _avg?: UserPointsAvgAggregateInputType
    _sum?: UserPointsSumAggregateInputType
    _min?: UserPointsMinAggregateInputType
    _max?: UserPointsMaxAggregateInputType
  }

  export type UserPointsGroupByOutputType = {
    id: string
    user_id: number
    points: number
    reason: string
    metadata: JsonValue | null
    created_at: Date
    _count: UserPointsCountAggregateOutputType | null
    _avg: UserPointsAvgAggregateOutputType | null
    _sum: UserPointsSumAggregateOutputType | null
    _min: UserPointsMinAggregateOutputType | null
    _max: UserPointsMaxAggregateOutputType | null
  }

  type GetUserPointsGroupByPayload<T extends UserPointsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPointsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPointsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPointsGroupByOutputType[P]>
            : GetScalarType<T[P], UserPointsGroupByOutputType[P]>
        }
      >
    >


  export type UserPointsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPoints"]>

  export type UserPointsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPoints"]>

  export type UserPointsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPoints"]>

  export type UserPointsSelectScalar = {
    id?: boolean
    user_id?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type UserPointsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "points" | "reason" | "metadata" | "created_at", ExtArgs["result"]["userPoints"]>
  export type UserPointsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UserPointsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type UserPointsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $UserPointsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPoints"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      points: number
      reason: string
      metadata: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["userPoints"]>
    composites: {}
  }

  type UserPointsGetPayload<S extends boolean | null | undefined | UserPointsDefaultArgs> = $Result.GetResult<Prisma.$UserPointsPayload, S>

  type UserPointsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPointsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPointsCountAggregateInputType | true
    }

  export interface UserPointsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPoints'], meta: { name: 'UserPoints' } }
    /**
     * Find zero or one UserPoints that matches the filter.
     * @param {UserPointsFindUniqueArgs} args - Arguments to find a UserPoints
     * @example
     * // Get one UserPoints
     * const userPoints = await prisma.userPoints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPointsFindUniqueArgs>(args: SelectSubset<T, UserPointsFindUniqueArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPoints that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPointsFindUniqueOrThrowArgs} args - Arguments to find a UserPoints
     * @example
     * // Get one UserPoints
     * const userPoints = await prisma.userPoints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPointsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPointsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsFindFirstArgs} args - Arguments to find a UserPoints
     * @example
     * // Get one UserPoints
     * const userPoints = await prisma.userPoints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPointsFindFirstArgs>(args?: SelectSubset<T, UserPointsFindFirstArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPoints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsFindFirstOrThrowArgs} args - Arguments to find a UserPoints
     * @example
     * // Get one UserPoints
     * const userPoints = await prisma.userPoints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPointsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPointsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPoints
     * const userPoints = await prisma.userPoints.findMany()
     * 
     * // Get first 10 UserPoints
     * const userPoints = await prisma.userPoints.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPointsWithIdOnly = await prisma.userPoints.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPointsFindManyArgs>(args?: SelectSubset<T, UserPointsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPoints.
     * @param {UserPointsCreateArgs} args - Arguments to create a UserPoints.
     * @example
     * // Create one UserPoints
     * const UserPoints = await prisma.userPoints.create({
     *   data: {
     *     // ... data to create a UserPoints
     *   }
     * })
     * 
     */
    create<T extends UserPointsCreateArgs>(args: SelectSubset<T, UserPointsCreateArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPoints.
     * @param {UserPointsCreateManyArgs} args - Arguments to create many UserPoints.
     * @example
     * // Create many UserPoints
     * const userPoints = await prisma.userPoints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPointsCreateManyArgs>(args?: SelectSubset<T, UserPointsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPoints and returns the data saved in the database.
     * @param {UserPointsCreateManyAndReturnArgs} args - Arguments to create many UserPoints.
     * @example
     * // Create many UserPoints
     * const userPoints = await prisma.userPoints.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPoints and only return the `id`
     * const userPointsWithIdOnly = await prisma.userPoints.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPointsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPointsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPoints.
     * @param {UserPointsDeleteArgs} args - Arguments to delete one UserPoints.
     * @example
     * // Delete one UserPoints
     * const UserPoints = await prisma.userPoints.delete({
     *   where: {
     *     // ... filter to delete one UserPoints
     *   }
     * })
     * 
     */
    delete<T extends UserPointsDeleteArgs>(args: SelectSubset<T, UserPointsDeleteArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPoints.
     * @param {UserPointsUpdateArgs} args - Arguments to update one UserPoints.
     * @example
     * // Update one UserPoints
     * const userPoints = await prisma.userPoints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPointsUpdateArgs>(args: SelectSubset<T, UserPointsUpdateArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPoints.
     * @param {UserPointsDeleteManyArgs} args - Arguments to filter UserPoints to delete.
     * @example
     * // Delete a few UserPoints
     * const { count } = await prisma.userPoints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPointsDeleteManyArgs>(args?: SelectSubset<T, UserPointsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPoints
     * const userPoints = await prisma.userPoints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPointsUpdateManyArgs>(args: SelectSubset<T, UserPointsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPoints and returns the data updated in the database.
     * @param {UserPointsUpdateManyAndReturnArgs} args - Arguments to update many UserPoints.
     * @example
     * // Update many UserPoints
     * const userPoints = await prisma.userPoints.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPoints and only return the `id`
     * const userPointsWithIdOnly = await prisma.userPoints.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPointsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPointsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPoints.
     * @param {UserPointsUpsertArgs} args - Arguments to update or create a UserPoints.
     * @example
     * // Update or create a UserPoints
     * const userPoints = await prisma.userPoints.upsert({
     *   create: {
     *     // ... data to create a UserPoints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPoints we want to update
     *   }
     * })
     */
    upsert<T extends UserPointsUpsertArgs>(args: SelectSubset<T, UserPointsUpsertArgs<ExtArgs>>): Prisma__UserPointsClient<$Result.GetResult<Prisma.$UserPointsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsCountArgs} args - Arguments to filter UserPoints to count.
     * @example
     * // Count the number of UserPoints
     * const count = await prisma.userPoints.count({
     *   where: {
     *     // ... the filter for the UserPoints we want to count
     *   }
     * })
    **/
    count<T extends UserPointsCountArgs>(
      args?: Subset<T, UserPointsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPointsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPointsAggregateArgs>(args: Subset<T, UserPointsAggregateArgs>): Prisma.PrismaPromise<GetUserPointsAggregateType<T>>

    /**
     * Group by UserPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPointsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPointsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPointsGroupByArgs['orderBy'] }
        : { orderBy?: UserPointsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPointsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPointsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPoints model
   */
  readonly fields: UserPointsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPoints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPointsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPoints model
   */
  interface UserPointsFieldRefs {
    readonly id: FieldRef<"UserPoints", 'String'>
    readonly user_id: FieldRef<"UserPoints", 'Int'>
    readonly points: FieldRef<"UserPoints", 'Int'>
    readonly reason: FieldRef<"UserPoints", 'String'>
    readonly metadata: FieldRef<"UserPoints", 'Json'>
    readonly created_at: FieldRef<"UserPoints", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPoints findUnique
   */
  export type UserPointsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * Filter, which UserPoints to fetch.
     */
    where: UserPointsWhereUniqueInput
  }

  /**
   * UserPoints findUniqueOrThrow
   */
  export type UserPointsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * Filter, which UserPoints to fetch.
     */
    where: UserPointsWhereUniqueInput
  }

  /**
   * UserPoints findFirst
   */
  export type UserPointsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * Filter, which UserPoints to fetch.
     */
    where?: UserPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPoints to fetch.
     */
    orderBy?: UserPointsOrderByWithRelationInput | UserPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPoints.
     */
    cursor?: UserPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPoints.
     */
    distinct?: UserPointsScalarFieldEnum | UserPointsScalarFieldEnum[]
  }

  /**
   * UserPoints findFirstOrThrow
   */
  export type UserPointsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * Filter, which UserPoints to fetch.
     */
    where?: UserPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPoints to fetch.
     */
    orderBy?: UserPointsOrderByWithRelationInput | UserPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPoints.
     */
    cursor?: UserPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPoints.
     */
    distinct?: UserPointsScalarFieldEnum | UserPointsScalarFieldEnum[]
  }

  /**
   * UserPoints findMany
   */
  export type UserPointsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * Filter, which UserPoints to fetch.
     */
    where?: UserPointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPoints to fetch.
     */
    orderBy?: UserPointsOrderByWithRelationInput | UserPointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPoints.
     */
    cursor?: UserPointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPoints.
     */
    skip?: number
    distinct?: UserPointsScalarFieldEnum | UserPointsScalarFieldEnum[]
  }

  /**
   * UserPoints create
   */
  export type UserPointsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPoints.
     */
    data: XOR<UserPointsCreateInput, UserPointsUncheckedCreateInput>
  }

  /**
   * UserPoints createMany
   */
  export type UserPointsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPoints.
     */
    data: UserPointsCreateManyInput | UserPointsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPoints createManyAndReturn
   */
  export type UserPointsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * The data used to create many UserPoints.
     */
    data: UserPointsCreateManyInput | UserPointsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPoints update
   */
  export type UserPointsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPoints.
     */
    data: XOR<UserPointsUpdateInput, UserPointsUncheckedUpdateInput>
    /**
     * Choose, which UserPoints to update.
     */
    where: UserPointsWhereUniqueInput
  }

  /**
   * UserPoints updateMany
   */
  export type UserPointsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPoints.
     */
    data: XOR<UserPointsUpdateManyMutationInput, UserPointsUncheckedUpdateManyInput>
    /**
     * Filter which UserPoints to update
     */
    where?: UserPointsWhereInput
    /**
     * Limit how many UserPoints to update.
     */
    limit?: number
  }

  /**
   * UserPoints updateManyAndReturn
   */
  export type UserPointsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * The data used to update UserPoints.
     */
    data: XOR<UserPointsUpdateManyMutationInput, UserPointsUncheckedUpdateManyInput>
    /**
     * Filter which UserPoints to update
     */
    where?: UserPointsWhereInput
    /**
     * Limit how many UserPoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPoints upsert
   */
  export type UserPointsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPoints to update in case it exists.
     */
    where: UserPointsWhereUniqueInput
    /**
     * In case the UserPoints found by the `where` argument doesn't exist, create a new UserPoints with this data.
     */
    create: XOR<UserPointsCreateInput, UserPointsUncheckedCreateInput>
    /**
     * In case the UserPoints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPointsUpdateInput, UserPointsUncheckedUpdateInput>
  }

  /**
   * UserPoints delete
   */
  export type UserPointsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
    /**
     * Filter which UserPoints to delete.
     */
    where: UserPointsWhereUniqueInput
  }

  /**
   * UserPoints deleteMany
   */
  export type UserPointsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPoints to delete
     */
    where?: UserPointsWhereInput
    /**
     * Limit how many UserPoints to delete.
     */
    limit?: number
  }

  /**
   * UserPoints without action
   */
  export type UserPointsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPoints
     */
    select?: UserPointsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPoints
     */
    omit?: UserPointsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPointsInclude<ExtArgs> | null
  }


  /**
   * Model StudyMaterial
   */

  export type AggregateStudyMaterial = {
    _count: StudyMaterialCountAggregateOutputType | null
    _avg: StudyMaterialAvgAggregateOutputType | null
    _sum: StudyMaterialSumAggregateOutputType | null
    _min: StudyMaterialMinAggregateOutputType | null
    _max: StudyMaterialMaxAggregateOutputType | null
  }

  export type StudyMaterialAvgAggregateOutputType = {
    id: number | null
    chapter_id: number | null
  }

  export type StudyMaterialSumAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
  }

  export type StudyMaterialMinAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    mind_map: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StudyMaterialMaxAggregateOutputType = {
    id: bigint | null
    chapter_id: bigint | null
    mind_map: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StudyMaterialCountAggregateOutputType = {
    id: number
    chapter_id: number
    summary: number
    definitions: number
    flashcards: number
    mind_map: number
    video_queries: number
    curated_videos: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StudyMaterialAvgAggregateInputType = {
    id?: true
    chapter_id?: true
  }

  export type StudyMaterialSumAggregateInputType = {
    id?: true
    chapter_id?: true
  }

  export type StudyMaterialMinAggregateInputType = {
    id?: true
    chapter_id?: true
    mind_map?: true
    created_at?: true
    updated_at?: true
  }

  export type StudyMaterialMaxAggregateInputType = {
    id?: true
    chapter_id?: true
    mind_map?: true
    created_at?: true
    updated_at?: true
  }

  export type StudyMaterialCountAggregateInputType = {
    id?: true
    chapter_id?: true
    summary?: true
    definitions?: true
    flashcards?: true
    mind_map?: true
    video_queries?: true
    curated_videos?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StudyMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyMaterial to aggregate.
     */
    where?: StudyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyMaterials to fetch.
     */
    orderBy?: StudyMaterialOrderByWithRelationInput | StudyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyMaterials
    **/
    _count?: true | StudyMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudyMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyMaterialMaxAggregateInputType
  }

  export type GetStudyMaterialAggregateType<T extends StudyMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyMaterial[P]>
      : GetScalarType<T[P], AggregateStudyMaterial[P]>
  }




  export type StudyMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyMaterialWhereInput
    orderBy?: StudyMaterialOrderByWithAggregationInput | StudyMaterialOrderByWithAggregationInput[]
    by: StudyMaterialScalarFieldEnum[] | StudyMaterialScalarFieldEnum
    having?: StudyMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyMaterialCountAggregateInputType | true
    _avg?: StudyMaterialAvgAggregateInputType
    _sum?: StudyMaterialSumAggregateInputType
    _min?: StudyMaterialMinAggregateInputType
    _max?: StudyMaterialMaxAggregateInputType
  }

  export type StudyMaterialGroupByOutputType = {
    id: bigint
    chapter_id: bigint
    summary: JsonValue | null
    definitions: JsonValue | null
    flashcards: JsonValue | null
    mind_map: string | null
    video_queries: string[]
    curated_videos: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: StudyMaterialCountAggregateOutputType | null
    _avg: StudyMaterialAvgAggregateOutputType | null
    _sum: StudyMaterialSumAggregateOutputType | null
    _min: StudyMaterialMinAggregateOutputType | null
    _max: StudyMaterialMaxAggregateOutputType | null
  }

  type GetStudyMaterialGroupByPayload<T extends StudyMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], StudyMaterialGroupByOutputType[P]>
        }
      >
    >


  export type StudyMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    summary?: boolean
    definitions?: boolean
    flashcards?: boolean
    mind_map?: boolean
    video_queries?: boolean
    curated_videos?: boolean
    created_at?: boolean
    updated_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyMaterial"]>

  export type StudyMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    summary?: boolean
    definitions?: boolean
    flashcards?: boolean
    mind_map?: boolean
    video_queries?: boolean
    curated_videos?: boolean
    created_at?: boolean
    updated_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyMaterial"]>

  export type StudyMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    summary?: boolean
    definitions?: boolean
    flashcards?: boolean
    mind_map?: boolean
    video_queries?: boolean
    curated_videos?: boolean
    created_at?: boolean
    updated_at?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyMaterial"]>

  export type StudyMaterialSelectScalar = {
    id?: boolean
    chapter_id?: boolean
    summary?: boolean
    definitions?: boolean
    flashcards?: boolean
    mind_map?: boolean
    video_queries?: boolean
    curated_videos?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StudyMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapter_id" | "summary" | "definitions" | "flashcards" | "mind_map" | "video_queries" | "curated_videos" | "created_at" | "updated_at", ExtArgs["result"]["studyMaterial"]>
  export type StudyMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type StudyMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type StudyMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $StudyMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyMaterial"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      chapter_id: bigint
      summary: Prisma.JsonValue | null
      definitions: Prisma.JsonValue | null
      flashcards: Prisma.JsonValue | null
      mind_map: string | null
      video_queries: string[]
      curated_videos: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["studyMaterial"]>
    composites: {}
  }

  type StudyMaterialGetPayload<S extends boolean | null | undefined | StudyMaterialDefaultArgs> = $Result.GetResult<Prisma.$StudyMaterialPayload, S>

  type StudyMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyMaterialCountAggregateInputType | true
    }

  export interface StudyMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyMaterial'], meta: { name: 'StudyMaterial' } }
    /**
     * Find zero or one StudyMaterial that matches the filter.
     * @param {StudyMaterialFindUniqueArgs} args - Arguments to find a StudyMaterial
     * @example
     * // Get one StudyMaterial
     * const studyMaterial = await prisma.studyMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyMaterialFindUniqueArgs>(args: SelectSubset<T, StudyMaterialFindUniqueArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudyMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyMaterialFindUniqueOrThrowArgs} args - Arguments to find a StudyMaterial
     * @example
     * // Get one StudyMaterial
     * const studyMaterial = await prisma.studyMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialFindFirstArgs} args - Arguments to find a StudyMaterial
     * @example
     * // Get one StudyMaterial
     * const studyMaterial = await prisma.studyMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyMaterialFindFirstArgs>(args?: SelectSubset<T, StudyMaterialFindFirstArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialFindFirstOrThrowArgs} args - Arguments to find a StudyMaterial
     * @example
     * // Get one StudyMaterial
     * const studyMaterial = await prisma.studyMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudyMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyMaterials
     * const studyMaterials = await prisma.studyMaterial.findMany()
     * 
     * // Get first 10 StudyMaterials
     * const studyMaterials = await prisma.studyMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyMaterialWithIdOnly = await prisma.studyMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyMaterialFindManyArgs>(args?: SelectSubset<T, StudyMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudyMaterial.
     * @param {StudyMaterialCreateArgs} args - Arguments to create a StudyMaterial.
     * @example
     * // Create one StudyMaterial
     * const StudyMaterial = await prisma.studyMaterial.create({
     *   data: {
     *     // ... data to create a StudyMaterial
     *   }
     * })
     * 
     */
    create<T extends StudyMaterialCreateArgs>(args: SelectSubset<T, StudyMaterialCreateArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudyMaterials.
     * @param {StudyMaterialCreateManyArgs} args - Arguments to create many StudyMaterials.
     * @example
     * // Create many StudyMaterials
     * const studyMaterial = await prisma.studyMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyMaterialCreateManyArgs>(args?: SelectSubset<T, StudyMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyMaterials and returns the data saved in the database.
     * @param {StudyMaterialCreateManyAndReturnArgs} args - Arguments to create many StudyMaterials.
     * @example
     * // Create many StudyMaterials
     * const studyMaterial = await prisma.studyMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyMaterials and only return the `id`
     * const studyMaterialWithIdOnly = await prisma.studyMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudyMaterial.
     * @param {StudyMaterialDeleteArgs} args - Arguments to delete one StudyMaterial.
     * @example
     * // Delete one StudyMaterial
     * const StudyMaterial = await prisma.studyMaterial.delete({
     *   where: {
     *     // ... filter to delete one StudyMaterial
     *   }
     * })
     * 
     */
    delete<T extends StudyMaterialDeleteArgs>(args: SelectSubset<T, StudyMaterialDeleteArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudyMaterial.
     * @param {StudyMaterialUpdateArgs} args - Arguments to update one StudyMaterial.
     * @example
     * // Update one StudyMaterial
     * const studyMaterial = await prisma.studyMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyMaterialUpdateArgs>(args: SelectSubset<T, StudyMaterialUpdateArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudyMaterials.
     * @param {StudyMaterialDeleteManyArgs} args - Arguments to filter StudyMaterials to delete.
     * @example
     * // Delete a few StudyMaterials
     * const { count } = await prisma.studyMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyMaterialDeleteManyArgs>(args?: SelectSubset<T, StudyMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyMaterials
     * const studyMaterial = await prisma.studyMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyMaterialUpdateManyArgs>(args: SelectSubset<T, StudyMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyMaterials and returns the data updated in the database.
     * @param {StudyMaterialUpdateManyAndReturnArgs} args - Arguments to update many StudyMaterials.
     * @example
     * // Update many StudyMaterials
     * const studyMaterial = await prisma.studyMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudyMaterials and only return the `id`
     * const studyMaterialWithIdOnly = await prisma.studyMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudyMaterial.
     * @param {StudyMaterialUpsertArgs} args - Arguments to update or create a StudyMaterial.
     * @example
     * // Update or create a StudyMaterial
     * const studyMaterial = await prisma.studyMaterial.upsert({
     *   create: {
     *     // ... data to create a StudyMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyMaterial we want to update
     *   }
     * })
     */
    upsert<T extends StudyMaterialUpsertArgs>(args: SelectSubset<T, StudyMaterialUpsertArgs<ExtArgs>>): Prisma__StudyMaterialClient<$Result.GetResult<Prisma.$StudyMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudyMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialCountArgs} args - Arguments to filter StudyMaterials to count.
     * @example
     * // Count the number of StudyMaterials
     * const count = await prisma.studyMaterial.count({
     *   where: {
     *     // ... the filter for the StudyMaterials we want to count
     *   }
     * })
    **/
    count<T extends StudyMaterialCountArgs>(
      args?: Subset<T, StudyMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyMaterialAggregateArgs>(args: Subset<T, StudyMaterialAggregateArgs>): Prisma.PrismaPromise<GetStudyMaterialAggregateType<T>>

    /**
     * Group by StudyMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyMaterialGroupByArgs['orderBy'] }
        : { orderBy?: StudyMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyMaterial model
   */
  readonly fields: StudyMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyMaterial model
   */
  interface StudyMaterialFieldRefs {
    readonly id: FieldRef<"StudyMaterial", 'BigInt'>
    readonly chapter_id: FieldRef<"StudyMaterial", 'BigInt'>
    readonly summary: FieldRef<"StudyMaterial", 'Json'>
    readonly definitions: FieldRef<"StudyMaterial", 'Json'>
    readonly flashcards: FieldRef<"StudyMaterial", 'Json'>
    readonly mind_map: FieldRef<"StudyMaterial", 'String'>
    readonly video_queries: FieldRef<"StudyMaterial", 'String[]'>
    readonly curated_videos: FieldRef<"StudyMaterial", 'Json'>
    readonly created_at: FieldRef<"StudyMaterial", 'DateTime'>
    readonly updated_at: FieldRef<"StudyMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyMaterial findUnique
   */
  export type StudyMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which StudyMaterial to fetch.
     */
    where: StudyMaterialWhereUniqueInput
  }

  /**
   * StudyMaterial findUniqueOrThrow
   */
  export type StudyMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which StudyMaterial to fetch.
     */
    where: StudyMaterialWhereUniqueInput
  }

  /**
   * StudyMaterial findFirst
   */
  export type StudyMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which StudyMaterial to fetch.
     */
    where?: StudyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyMaterials to fetch.
     */
    orderBy?: StudyMaterialOrderByWithRelationInput | StudyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyMaterials.
     */
    cursor?: StudyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyMaterials.
     */
    distinct?: StudyMaterialScalarFieldEnum | StudyMaterialScalarFieldEnum[]
  }

  /**
   * StudyMaterial findFirstOrThrow
   */
  export type StudyMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which StudyMaterial to fetch.
     */
    where?: StudyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyMaterials to fetch.
     */
    orderBy?: StudyMaterialOrderByWithRelationInput | StudyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyMaterials.
     */
    cursor?: StudyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyMaterials.
     */
    distinct?: StudyMaterialScalarFieldEnum | StudyMaterialScalarFieldEnum[]
  }

  /**
   * StudyMaterial findMany
   */
  export type StudyMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * Filter, which StudyMaterials to fetch.
     */
    where?: StudyMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyMaterials to fetch.
     */
    orderBy?: StudyMaterialOrderByWithRelationInput | StudyMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyMaterials.
     */
    cursor?: StudyMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyMaterials.
     */
    skip?: number
    distinct?: StudyMaterialScalarFieldEnum | StudyMaterialScalarFieldEnum[]
  }

  /**
   * StudyMaterial create
   */
  export type StudyMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyMaterial.
     */
    data: XOR<StudyMaterialCreateInput, StudyMaterialUncheckedCreateInput>
  }

  /**
   * StudyMaterial createMany
   */
  export type StudyMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyMaterials.
     */
    data: StudyMaterialCreateManyInput | StudyMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyMaterial createManyAndReturn
   */
  export type StudyMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many StudyMaterials.
     */
    data: StudyMaterialCreateManyInput | StudyMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyMaterial update
   */
  export type StudyMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyMaterial.
     */
    data: XOR<StudyMaterialUpdateInput, StudyMaterialUncheckedUpdateInput>
    /**
     * Choose, which StudyMaterial to update.
     */
    where: StudyMaterialWhereUniqueInput
  }

  /**
   * StudyMaterial updateMany
   */
  export type StudyMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyMaterials.
     */
    data: XOR<StudyMaterialUpdateManyMutationInput, StudyMaterialUncheckedUpdateManyInput>
    /**
     * Filter which StudyMaterials to update
     */
    where?: StudyMaterialWhereInput
    /**
     * Limit how many StudyMaterials to update.
     */
    limit?: number
  }

  /**
   * StudyMaterial updateManyAndReturn
   */
  export type StudyMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * The data used to update StudyMaterials.
     */
    data: XOR<StudyMaterialUpdateManyMutationInput, StudyMaterialUncheckedUpdateManyInput>
    /**
     * Filter which StudyMaterials to update
     */
    where?: StudyMaterialWhereInput
    /**
     * Limit how many StudyMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyMaterial upsert
   */
  export type StudyMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyMaterial to update in case it exists.
     */
    where: StudyMaterialWhereUniqueInput
    /**
     * In case the StudyMaterial found by the `where` argument doesn't exist, create a new StudyMaterial with this data.
     */
    create: XOR<StudyMaterialCreateInput, StudyMaterialUncheckedCreateInput>
    /**
     * In case the StudyMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyMaterialUpdateInput, StudyMaterialUncheckedUpdateInput>
  }

  /**
   * StudyMaterial delete
   */
  export type StudyMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
    /**
     * Filter which StudyMaterial to delete.
     */
    where: StudyMaterialWhereUniqueInput
  }

  /**
   * StudyMaterial deleteMany
   */
  export type StudyMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyMaterials to delete
     */
    where?: StudyMaterialWhereInput
    /**
     * Limit how many StudyMaterials to delete.
     */
    limit?: number
  }

  /**
   * StudyMaterial without action
   */
  export type StudyMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyMaterial
     */
    select?: StudyMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyMaterial
     */
    omit?: StudyMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    program_id: number | null
  }

  export type ExamSumAggregateOutputType = {
    program_id: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    program_id: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    program_id: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    program_id: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    program_id?: true
  }

  export type ExamSumAggregateInputType = {
    program_id?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    program_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    program_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    program_id?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    description: string | null
    date: Date
    program_id: number | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    program_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    program?: boolean | Exam$programArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    program_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    program?: boolean | Exam$programArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    program_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    program?: boolean | Exam$programArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    program_id?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "date" | "program_id" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Exam$programArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Exam$programArgs<ExtArgs>
  }
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Exam$programArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      date: Date
      program_id: number | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends Exam$programArgs<ExtArgs> = {}>(args?: Subset<T, Exam$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly description: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly program_id: FieldRef<"Exam", 'Int'>
    readonly is_active: FieldRef<"Exam", 'Boolean'>
    readonly created_at: FieldRef<"Exam", 'DateTime'>
    readonly updated_at: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.program
   */
  export type Exam$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model StreakBadge
   */

  export type AggregateStreakBadge = {
    _count: StreakBadgeCountAggregateOutputType | null
    _avg: StreakBadgeAvgAggregateOutputType | null
    _sum: StreakBadgeSumAggregateOutputType | null
    _min: StreakBadgeMinAggregateOutputType | null
    _max: StreakBadgeMaxAggregateOutputType | null
  }

  export type StreakBadgeAvgAggregateOutputType = {
    min_streak: number | null
  }

  export type StreakBadgeSumAggregateOutputType = {
    min_streak: number | null
  }

  export type StreakBadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    min_streak: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StreakBadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    min_streak: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StreakBadgeCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    min_streak: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StreakBadgeAvgAggregateInputType = {
    min_streak?: true
  }

  export type StreakBadgeSumAggregateInputType = {
    min_streak?: true
  }

  export type StreakBadgeMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    min_streak?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type StreakBadgeMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    min_streak?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type StreakBadgeCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    min_streak?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StreakBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreakBadge to aggregate.
     */
    where?: StreakBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakBadges to fetch.
     */
    orderBy?: StreakBadgeOrderByWithRelationInput | StreakBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreakBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StreakBadges
    **/
    _count?: true | StreakBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreakBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreakBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreakBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreakBadgeMaxAggregateInputType
  }

  export type GetStreakBadgeAggregateType<T extends StreakBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateStreakBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreakBadge[P]>
      : GetScalarType<T[P], AggregateStreakBadge[P]>
  }




  export type StreakBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreakBadgeWhereInput
    orderBy?: StreakBadgeOrderByWithAggregationInput | StreakBadgeOrderByWithAggregationInput[]
    by: StreakBadgeScalarFieldEnum[] | StreakBadgeScalarFieldEnum
    having?: StreakBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreakBadgeCountAggregateInputType | true
    _avg?: StreakBadgeAvgAggregateInputType
    _sum?: StreakBadgeSumAggregateInputType
    _min?: StreakBadgeMinAggregateInputType
    _max?: StreakBadgeMaxAggregateInputType
  }

  export type StreakBadgeGroupByOutputType = {
    id: string
    name: string
    icon: string
    min_streak: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: StreakBadgeCountAggregateOutputType | null
    _avg: StreakBadgeAvgAggregateOutputType | null
    _sum: StreakBadgeSumAggregateOutputType | null
    _min: StreakBadgeMinAggregateOutputType | null
    _max: StreakBadgeMaxAggregateOutputType | null
  }

  type GetStreakBadgeGroupByPayload<T extends StreakBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreakBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreakBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreakBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], StreakBadgeGroupByOutputType[P]>
        }
      >
    >


  export type StreakBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    min_streak?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_badges?: boolean | StreakBadge$user_badgesArgs<ExtArgs>
    _count?: boolean | StreakBadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streakBadge"]>

  export type StreakBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    min_streak?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["streakBadge"]>

  export type StreakBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    min_streak?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["streakBadge"]>

  export type StreakBadgeSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    min_streak?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StreakBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "min_streak" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["streakBadge"]>
  export type StreakBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_badges?: boolean | StreakBadge$user_badgesArgs<ExtArgs>
    _count?: boolean | StreakBadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StreakBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StreakBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StreakBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StreakBadge"
    objects: {
      user_badges: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      min_streak: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["streakBadge"]>
    composites: {}
  }

  type StreakBadgeGetPayload<S extends boolean | null | undefined | StreakBadgeDefaultArgs> = $Result.GetResult<Prisma.$StreakBadgePayload, S>

  type StreakBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StreakBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StreakBadgeCountAggregateInputType | true
    }

  export interface StreakBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StreakBadge'], meta: { name: 'StreakBadge' } }
    /**
     * Find zero or one StreakBadge that matches the filter.
     * @param {StreakBadgeFindUniqueArgs} args - Arguments to find a StreakBadge
     * @example
     * // Get one StreakBadge
     * const streakBadge = await prisma.streakBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreakBadgeFindUniqueArgs>(args: SelectSubset<T, StreakBadgeFindUniqueArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StreakBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StreakBadgeFindUniqueOrThrowArgs} args - Arguments to find a StreakBadge
     * @example
     * // Get one StreakBadge
     * const streakBadge = await prisma.streakBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreakBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, StreakBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StreakBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeFindFirstArgs} args - Arguments to find a StreakBadge
     * @example
     * // Get one StreakBadge
     * const streakBadge = await prisma.streakBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreakBadgeFindFirstArgs>(args?: SelectSubset<T, StreakBadgeFindFirstArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StreakBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeFindFirstOrThrowArgs} args - Arguments to find a StreakBadge
     * @example
     * // Get one StreakBadge
     * const streakBadge = await prisma.streakBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreakBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, StreakBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StreakBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StreakBadges
     * const streakBadges = await prisma.streakBadge.findMany()
     * 
     * // Get first 10 StreakBadges
     * const streakBadges = await prisma.streakBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streakBadgeWithIdOnly = await prisma.streakBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StreakBadgeFindManyArgs>(args?: SelectSubset<T, StreakBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StreakBadge.
     * @param {StreakBadgeCreateArgs} args - Arguments to create a StreakBadge.
     * @example
     * // Create one StreakBadge
     * const StreakBadge = await prisma.streakBadge.create({
     *   data: {
     *     // ... data to create a StreakBadge
     *   }
     * })
     * 
     */
    create<T extends StreakBadgeCreateArgs>(args: SelectSubset<T, StreakBadgeCreateArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StreakBadges.
     * @param {StreakBadgeCreateManyArgs} args - Arguments to create many StreakBadges.
     * @example
     * // Create many StreakBadges
     * const streakBadge = await prisma.streakBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreakBadgeCreateManyArgs>(args?: SelectSubset<T, StreakBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StreakBadges and returns the data saved in the database.
     * @param {StreakBadgeCreateManyAndReturnArgs} args - Arguments to create many StreakBadges.
     * @example
     * // Create many StreakBadges
     * const streakBadge = await prisma.streakBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StreakBadges and only return the `id`
     * const streakBadgeWithIdOnly = await prisma.streakBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreakBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, StreakBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StreakBadge.
     * @param {StreakBadgeDeleteArgs} args - Arguments to delete one StreakBadge.
     * @example
     * // Delete one StreakBadge
     * const StreakBadge = await prisma.streakBadge.delete({
     *   where: {
     *     // ... filter to delete one StreakBadge
     *   }
     * })
     * 
     */
    delete<T extends StreakBadgeDeleteArgs>(args: SelectSubset<T, StreakBadgeDeleteArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StreakBadge.
     * @param {StreakBadgeUpdateArgs} args - Arguments to update one StreakBadge.
     * @example
     * // Update one StreakBadge
     * const streakBadge = await prisma.streakBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreakBadgeUpdateArgs>(args: SelectSubset<T, StreakBadgeUpdateArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StreakBadges.
     * @param {StreakBadgeDeleteManyArgs} args - Arguments to filter StreakBadges to delete.
     * @example
     * // Delete a few StreakBadges
     * const { count } = await prisma.streakBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreakBadgeDeleteManyArgs>(args?: SelectSubset<T, StreakBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreakBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StreakBadges
     * const streakBadge = await prisma.streakBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreakBadgeUpdateManyArgs>(args: SelectSubset<T, StreakBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreakBadges and returns the data updated in the database.
     * @param {StreakBadgeUpdateManyAndReturnArgs} args - Arguments to update many StreakBadges.
     * @example
     * // Update many StreakBadges
     * const streakBadge = await prisma.streakBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StreakBadges and only return the `id`
     * const streakBadgeWithIdOnly = await prisma.streakBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StreakBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, StreakBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StreakBadge.
     * @param {StreakBadgeUpsertArgs} args - Arguments to update or create a StreakBadge.
     * @example
     * // Update or create a StreakBadge
     * const streakBadge = await prisma.streakBadge.upsert({
     *   create: {
     *     // ... data to create a StreakBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StreakBadge we want to update
     *   }
     * })
     */
    upsert<T extends StreakBadgeUpsertArgs>(args: SelectSubset<T, StreakBadgeUpsertArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StreakBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeCountArgs} args - Arguments to filter StreakBadges to count.
     * @example
     * // Count the number of StreakBadges
     * const count = await prisma.streakBadge.count({
     *   where: {
     *     // ... the filter for the StreakBadges we want to count
     *   }
     * })
    **/
    count<T extends StreakBadgeCountArgs>(
      args?: Subset<T, StreakBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreakBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StreakBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreakBadgeAggregateArgs>(args: Subset<T, StreakBadgeAggregateArgs>): Prisma.PrismaPromise<GetStreakBadgeAggregateType<T>>

    /**
     * Group by StreakBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreakBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreakBadgeGroupByArgs['orderBy'] }
        : { orderBy?: StreakBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreakBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreakBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StreakBadge model
   */
  readonly fields: StreakBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StreakBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreakBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_badges<T extends StreakBadge$user_badgesArgs<ExtArgs> = {}>(args?: Subset<T, StreakBadge$user_badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StreakBadge model
   */
  interface StreakBadgeFieldRefs {
    readonly id: FieldRef<"StreakBadge", 'String'>
    readonly name: FieldRef<"StreakBadge", 'String'>
    readonly icon: FieldRef<"StreakBadge", 'String'>
    readonly min_streak: FieldRef<"StreakBadge", 'Int'>
    readonly is_active: FieldRef<"StreakBadge", 'Boolean'>
    readonly created_at: FieldRef<"StreakBadge", 'DateTime'>
    readonly updated_at: FieldRef<"StreakBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StreakBadge findUnique
   */
  export type StreakBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StreakBadge to fetch.
     */
    where: StreakBadgeWhereUniqueInput
  }

  /**
   * StreakBadge findUniqueOrThrow
   */
  export type StreakBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StreakBadge to fetch.
     */
    where: StreakBadgeWhereUniqueInput
  }

  /**
   * StreakBadge findFirst
   */
  export type StreakBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StreakBadge to fetch.
     */
    where?: StreakBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakBadges to fetch.
     */
    orderBy?: StreakBadgeOrderByWithRelationInput | StreakBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreakBadges.
     */
    cursor?: StreakBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreakBadges.
     */
    distinct?: StreakBadgeScalarFieldEnum | StreakBadgeScalarFieldEnum[]
  }

  /**
   * StreakBadge findFirstOrThrow
   */
  export type StreakBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StreakBadge to fetch.
     */
    where?: StreakBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakBadges to fetch.
     */
    orderBy?: StreakBadgeOrderByWithRelationInput | StreakBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreakBadges.
     */
    cursor?: StreakBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreakBadges.
     */
    distinct?: StreakBadgeScalarFieldEnum | StreakBadgeScalarFieldEnum[]
  }

  /**
   * StreakBadge findMany
   */
  export type StreakBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * Filter, which StreakBadges to fetch.
     */
    where?: StreakBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreakBadges to fetch.
     */
    orderBy?: StreakBadgeOrderByWithRelationInput | StreakBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StreakBadges.
     */
    cursor?: StreakBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreakBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreakBadges.
     */
    skip?: number
    distinct?: StreakBadgeScalarFieldEnum | StreakBadgeScalarFieldEnum[]
  }

  /**
   * StreakBadge create
   */
  export type StreakBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a StreakBadge.
     */
    data: XOR<StreakBadgeCreateInput, StreakBadgeUncheckedCreateInput>
  }

  /**
   * StreakBadge createMany
   */
  export type StreakBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StreakBadges.
     */
    data: StreakBadgeCreateManyInput | StreakBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StreakBadge createManyAndReturn
   */
  export type StreakBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many StreakBadges.
     */
    data: StreakBadgeCreateManyInput | StreakBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StreakBadge update
   */
  export type StreakBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a StreakBadge.
     */
    data: XOR<StreakBadgeUpdateInput, StreakBadgeUncheckedUpdateInput>
    /**
     * Choose, which StreakBadge to update.
     */
    where: StreakBadgeWhereUniqueInput
  }

  /**
   * StreakBadge updateMany
   */
  export type StreakBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StreakBadges.
     */
    data: XOR<StreakBadgeUpdateManyMutationInput, StreakBadgeUncheckedUpdateManyInput>
    /**
     * Filter which StreakBadges to update
     */
    where?: StreakBadgeWhereInput
    /**
     * Limit how many StreakBadges to update.
     */
    limit?: number
  }

  /**
   * StreakBadge updateManyAndReturn
   */
  export type StreakBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * The data used to update StreakBadges.
     */
    data: XOR<StreakBadgeUpdateManyMutationInput, StreakBadgeUncheckedUpdateManyInput>
    /**
     * Filter which StreakBadges to update
     */
    where?: StreakBadgeWhereInput
    /**
     * Limit how many StreakBadges to update.
     */
    limit?: number
  }

  /**
   * StreakBadge upsert
   */
  export type StreakBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the StreakBadge to update in case it exists.
     */
    where: StreakBadgeWhereUniqueInput
    /**
     * In case the StreakBadge found by the `where` argument doesn't exist, create a new StreakBadge with this data.
     */
    create: XOR<StreakBadgeCreateInput, StreakBadgeUncheckedCreateInput>
    /**
     * In case the StreakBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreakBadgeUpdateInput, StreakBadgeUncheckedUpdateInput>
  }

  /**
   * StreakBadge delete
   */
  export type StreakBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
    /**
     * Filter which StreakBadge to delete.
     */
    where: StreakBadgeWhereUniqueInput
  }

  /**
   * StreakBadge deleteMany
   */
  export type StreakBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreakBadges to delete
     */
    where?: StreakBadgeWhereInput
    /**
     * Limit how many StreakBadges to delete.
     */
    limit?: number
  }

  /**
   * StreakBadge.user_badges
   */
  export type StreakBadge$user_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * StreakBadge without action
   */
  export type StreakBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreakBadge
     */
    select?: StreakBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StreakBadge
     */
    omit?: StreakBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakBadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserBadgeSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    badge_id: string | null
    earned_at: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    badge_id: string | null
    earned_at: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    user_id: number
    badge_id: number
    earned_at: number
    _all: number
  }


  export type UserBadgeAvgAggregateInputType = {
    user_id?: true
  }

  export type UserBadgeSumAggregateInputType = {
    user_id?: true
  }

  export type UserBadgeMinAggregateInputType = {
    id?: true
    user_id?: true
    badge_id?: true
    earned_at?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    user_id?: true
    badge_id?: true
    earned_at?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    user_id?: true
    badge_id?: true
    earned_at?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _avg?: UserBadgeAvgAggregateInputType
    _sum?: UserBadgeSumAggregateInputType
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    user_id: number
    badge_id: string
    earned_at: Date
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    badge_id?: boolean
    earned_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    badge?: boolean | StreakBadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    badge_id?: boolean
    earned_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    badge?: boolean | StreakBadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    badge_id?: boolean
    earned_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    badge?: boolean | StreakBadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    id?: boolean
    user_id?: boolean
    badge_id?: boolean
    earned_at?: boolean
  }

  export type UserBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "badge_id" | "earned_at", ExtArgs["result"]["userBadge"]>
  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    badge?: boolean | StreakBadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    badge?: boolean | StreakBadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    badge?: boolean | StreakBadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      badge: Prisma.$StreakBadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      badge_id: string
      earned_at: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges and returns the data updated in the database.
     * @param {UserBadgeUpdateManyAndReturnArgs} args - Arguments to update many UserBadges.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends StreakBadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StreakBadgeDefaultArgs<ExtArgs>>): Prisma__StreakBadgeClient<$Result.GetResult<Prisma.$StreakBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly user_id: FieldRef<"UserBadge", 'Int'>
    readonly badge_id: FieldRef<"UserBadge", 'String'>
    readonly earned_at: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
  }

  /**
   * UserBadge updateManyAndReturn
   */
  export type UserBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to delete.
     */
    limit?: number
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model LearningSession
   */

  export type AggregateLearningSession = {
    _count: LearningSessionCountAggregateOutputType | null
    _avg: LearningSessionAvgAggregateOutputType | null
    _sum: LearningSessionSumAggregateOutputType | null
    _min: LearningSessionMinAggregateOutputType | null
    _max: LearningSessionMaxAggregateOutputType | null
  }

  export type LearningSessionAvgAggregateOutputType = {
    user_id: number | null
    chapter_id: number | null
    progress: number | null
  }

  export type LearningSessionSumAggregateOutputType = {
    user_id: number | null
    chapter_id: bigint | null
    progress: number | null
  }

  export type LearningSessionMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    chapter_id: bigint | null
    status: string | null
    current_topic: string | null
    progress: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LearningSessionMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    chapter_id: bigint | null
    status: string | null
    current_topic: string | null
    progress: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LearningSessionCountAggregateOutputType = {
    id: number
    user_id: number
    chapter_id: number
    status: number
    current_topic: number
    progress: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LearningSessionAvgAggregateInputType = {
    user_id?: true
    chapter_id?: true
    progress?: true
  }

  export type LearningSessionSumAggregateInputType = {
    user_id?: true
    chapter_id?: true
    progress?: true
  }

  export type LearningSessionMinAggregateInputType = {
    id?: true
    user_id?: true
    chapter_id?: true
    status?: true
    current_topic?: true
    progress?: true
    created_at?: true
    updated_at?: true
  }

  export type LearningSessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    chapter_id?: true
    status?: true
    current_topic?: true
    progress?: true
    created_at?: true
    updated_at?: true
  }

  export type LearningSessionCountAggregateInputType = {
    id?: true
    user_id?: true
    chapter_id?: true
    status?: true
    current_topic?: true
    progress?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LearningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSession to aggregate.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningSessions
    **/
    _count?: true | LearningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningSessionMaxAggregateInputType
  }

  export type GetLearningSessionAggregateType<T extends LearningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningSession[P]>
      : GetScalarType<T[P], AggregateLearningSession[P]>
  }




  export type LearningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningSessionWhereInput
    orderBy?: LearningSessionOrderByWithAggregationInput | LearningSessionOrderByWithAggregationInput[]
    by: LearningSessionScalarFieldEnum[] | LearningSessionScalarFieldEnum
    having?: LearningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningSessionCountAggregateInputType | true
    _avg?: LearningSessionAvgAggregateInputType
    _sum?: LearningSessionSumAggregateInputType
    _min?: LearningSessionMinAggregateInputType
    _max?: LearningSessionMaxAggregateInputType
  }

  export type LearningSessionGroupByOutputType = {
    id: string
    user_id: number
    chapter_id: bigint
    status: string
    current_topic: string | null
    progress: number
    created_at: Date
    updated_at: Date
    _count: LearningSessionCountAggregateOutputType | null
    _avg: LearningSessionAvgAggregateOutputType | null
    _sum: LearningSessionSumAggregateOutputType | null
    _min: LearningSessionMinAggregateOutputType | null
    _max: LearningSessionMaxAggregateOutputType | null
  }

  type GetLearningSessionGroupByPayload<T extends LearningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], LearningSessionGroupByOutputType[P]>
        }
      >
    >


  export type LearningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    chapter_id?: boolean
    status?: boolean
    current_topic?: boolean
    progress?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    chapter_id?: boolean
    status?: boolean
    current_topic?: boolean
    progress?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    chapter_id?: boolean
    status?: boolean
    current_topic?: boolean
    progress?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningSession"]>

  export type LearningSessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    chapter_id?: boolean
    status?: boolean
    current_topic?: boolean
    progress?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type LearningSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "chapter_id" | "status" | "current_topic" | "progress" | "created_at" | "updated_at", ExtArgs["result"]["learningSession"]>
  export type LearningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type LearningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type LearningSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $LearningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningSession"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      chapter_id: bigint
      status: string
      current_topic: string | null
      progress: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["learningSession"]>
    composites: {}
  }

  type LearningSessionGetPayload<S extends boolean | null | undefined | LearningSessionDefaultArgs> = $Result.GetResult<Prisma.$LearningSessionPayload, S>

  type LearningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningSessionCountAggregateInputType | true
    }

  export interface LearningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningSession'], meta: { name: 'LearningSession' } }
    /**
     * Find zero or one LearningSession that matches the filter.
     * @param {LearningSessionFindUniqueArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningSessionFindUniqueArgs>(args: SelectSubset<T, LearningSessionFindUniqueArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningSessionFindUniqueOrThrowArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindFirstArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningSessionFindFirstArgs>(args?: SelectSubset<T, LearningSessionFindFirstArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindFirstOrThrowArgs} args - Arguments to find a LearningSession
     * @example
     * // Get one LearningSession
     * const learningSession = await prisma.learningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningSessions
     * const learningSessions = await prisma.learningSession.findMany()
     * 
     * // Get first 10 LearningSessions
     * const learningSessions = await prisma.learningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningSessionFindManyArgs>(args?: SelectSubset<T, LearningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningSession.
     * @param {LearningSessionCreateArgs} args - Arguments to create a LearningSession.
     * @example
     * // Create one LearningSession
     * const LearningSession = await prisma.learningSession.create({
     *   data: {
     *     // ... data to create a LearningSession
     *   }
     * })
     * 
     */
    create<T extends LearningSessionCreateArgs>(args: SelectSubset<T, LearningSessionCreateArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningSessions.
     * @param {LearningSessionCreateManyArgs} args - Arguments to create many LearningSessions.
     * @example
     * // Create many LearningSessions
     * const learningSession = await prisma.learningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningSessionCreateManyArgs>(args?: SelectSubset<T, LearningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningSessions and returns the data saved in the database.
     * @param {LearningSessionCreateManyAndReturnArgs} args - Arguments to create many LearningSessions.
     * @example
     * // Create many LearningSessions
     * const learningSession = await prisma.learningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningSessions and only return the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningSession.
     * @param {LearningSessionDeleteArgs} args - Arguments to delete one LearningSession.
     * @example
     * // Delete one LearningSession
     * const LearningSession = await prisma.learningSession.delete({
     *   where: {
     *     // ... filter to delete one LearningSession
     *   }
     * })
     * 
     */
    delete<T extends LearningSessionDeleteArgs>(args: SelectSubset<T, LearningSessionDeleteArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningSession.
     * @param {LearningSessionUpdateArgs} args - Arguments to update one LearningSession.
     * @example
     * // Update one LearningSession
     * const learningSession = await prisma.learningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningSessionUpdateArgs>(args: SelectSubset<T, LearningSessionUpdateArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningSessions.
     * @param {LearningSessionDeleteManyArgs} args - Arguments to filter LearningSessions to delete.
     * @example
     * // Delete a few LearningSessions
     * const { count } = await prisma.learningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningSessionDeleteManyArgs>(args?: SelectSubset<T, LearningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningSessions
     * const learningSession = await prisma.learningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningSessionUpdateManyArgs>(args: SelectSubset<T, LearningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningSessions and returns the data updated in the database.
     * @param {LearningSessionUpdateManyAndReturnArgs} args - Arguments to update many LearningSessions.
     * @example
     * // Update many LearningSessions
     * const learningSession = await prisma.learningSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningSessions and only return the `id`
     * const learningSessionWithIdOnly = await prisma.learningSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningSession.
     * @param {LearningSessionUpsertArgs} args - Arguments to update or create a LearningSession.
     * @example
     * // Update or create a LearningSession
     * const learningSession = await prisma.learningSession.upsert({
     *   create: {
     *     // ... data to create a LearningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningSession we want to update
     *   }
     * })
     */
    upsert<T extends LearningSessionUpsertArgs>(args: SelectSubset<T, LearningSessionUpsertArgs<ExtArgs>>): Prisma__LearningSessionClient<$Result.GetResult<Prisma.$LearningSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionCountArgs} args - Arguments to filter LearningSessions to count.
     * @example
     * // Count the number of LearningSessions
     * const count = await prisma.learningSession.count({
     *   where: {
     *     // ... the filter for the LearningSessions we want to count
     *   }
     * })
    **/
    count<T extends LearningSessionCountArgs>(
      args?: Subset<T, LearningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningSessionAggregateArgs>(args: Subset<T, LearningSessionAggregateArgs>): Prisma.PrismaPromise<GetLearningSessionAggregateType<T>>

    /**
     * Group by LearningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningSessionGroupByArgs['orderBy'] }
        : { orderBy?: LearningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningSession model
   */
  readonly fields: LearningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningSession model
   */
  interface LearningSessionFieldRefs {
    readonly id: FieldRef<"LearningSession", 'String'>
    readonly user_id: FieldRef<"LearningSession", 'Int'>
    readonly chapter_id: FieldRef<"LearningSession", 'BigInt'>
    readonly status: FieldRef<"LearningSession", 'String'>
    readonly current_topic: FieldRef<"LearningSession", 'String'>
    readonly progress: FieldRef<"LearningSession", 'Int'>
    readonly created_at: FieldRef<"LearningSession", 'DateTime'>
    readonly updated_at: FieldRef<"LearningSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningSession findUnique
   */
  export type LearningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession findUniqueOrThrow
   */
  export type LearningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession findFirst
   */
  export type LearningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessions.
     */
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession findFirstOrThrow
   */
  export type LearningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSession to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningSessions.
     */
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession findMany
   */
  export type LearningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter, which LearningSessions to fetch.
     */
    where?: LearningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningSessions to fetch.
     */
    orderBy?: LearningSessionOrderByWithRelationInput | LearningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningSessions.
     */
    cursor?: LearningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningSessions.
     */
    skip?: number
    distinct?: LearningSessionScalarFieldEnum | LearningSessionScalarFieldEnum[]
  }

  /**
   * LearningSession create
   */
  export type LearningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningSession.
     */
    data: XOR<LearningSessionCreateInput, LearningSessionUncheckedCreateInput>
  }

  /**
   * LearningSession createMany
   */
  export type LearningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningSessions.
     */
    data: LearningSessionCreateManyInput | LearningSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningSession createManyAndReturn
   */
  export type LearningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * The data used to create many LearningSessions.
     */
    data: LearningSessionCreateManyInput | LearningSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningSession update
   */
  export type LearningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningSession.
     */
    data: XOR<LearningSessionUpdateInput, LearningSessionUncheckedUpdateInput>
    /**
     * Choose, which LearningSession to update.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession updateMany
   */
  export type LearningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningSessions.
     */
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyInput>
    /**
     * Filter which LearningSessions to update
     */
    where?: LearningSessionWhereInput
    /**
     * Limit how many LearningSessions to update.
     */
    limit?: number
  }

  /**
   * LearningSession updateManyAndReturn
   */
  export type LearningSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * The data used to update LearningSessions.
     */
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyInput>
    /**
     * Filter which LearningSessions to update
     */
    where?: LearningSessionWhereInput
    /**
     * Limit how many LearningSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningSession upsert
   */
  export type LearningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningSession to update in case it exists.
     */
    where: LearningSessionWhereUniqueInput
    /**
     * In case the LearningSession found by the `where` argument doesn't exist, create a new LearningSession with this data.
     */
    create: XOR<LearningSessionCreateInput, LearningSessionUncheckedCreateInput>
    /**
     * In case the LearningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningSessionUpdateInput, LearningSessionUncheckedUpdateInput>
  }

  /**
   * LearningSession delete
   */
  export type LearningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
    /**
     * Filter which LearningSession to delete.
     */
    where: LearningSessionWhereUniqueInput
  }

  /**
   * LearningSession deleteMany
   */
  export type LearningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningSessions to delete
     */
    where?: LearningSessionWhereInput
    /**
     * Limit how many LearningSessions to delete.
     */
    limit?: number
  }

  /**
   * LearningSession without action
   */
  export type LearningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningSession
     */
    select?: LearningSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningSession
     */
    omit?: LearningSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningSessionInclude<ExtArgs> | null
  }


  /**
   * Model Battle
   */

  export type AggregateBattle = {
    _count: BattleCountAggregateOutputType | null
    _avg: BattleAvgAggregateOutputType | null
    _sum: BattleSumAggregateOutputType | null
    _min: BattleMinAggregateOutputType | null
    _max: BattleMaxAggregateOutputType | null
  }

  export type BattleAvgAggregateOutputType = {
    created_by: number | null
  }

  export type BattleSumAggregateOutputType = {
    created_by: number | null
  }

  export type BattleMinAggregateOutputType = {
    id: string | null
    quiz_id: string | null
    code: string | null
    status: $Enums.BattleStatus | null
    created_by: number | null
    created_at: Date | null
    started_at: Date | null
    ended_at: Date | null
  }

  export type BattleMaxAggregateOutputType = {
    id: string | null
    quiz_id: string | null
    code: string | null
    status: $Enums.BattleStatus | null
    created_by: number | null
    created_at: Date | null
    started_at: Date | null
    ended_at: Date | null
  }

  export type BattleCountAggregateOutputType = {
    id: number
    quiz_id: number
    code: number
    status: number
    created_by: number
    created_at: number
    started_at: number
    ended_at: number
    settings: number
    _all: number
  }


  export type BattleAvgAggregateInputType = {
    created_by?: true
  }

  export type BattleSumAggregateInputType = {
    created_by?: true
  }

  export type BattleMinAggregateInputType = {
    id?: true
    quiz_id?: true
    code?: true
    status?: true
    created_by?: true
    created_at?: true
    started_at?: true
    ended_at?: true
  }

  export type BattleMaxAggregateInputType = {
    id?: true
    quiz_id?: true
    code?: true
    status?: true
    created_by?: true
    created_at?: true
    started_at?: true
    ended_at?: true
  }

  export type BattleCountAggregateInputType = {
    id?: true
    quiz_id?: true
    code?: true
    status?: true
    created_by?: true
    created_at?: true
    started_at?: true
    ended_at?: true
    settings?: true
    _all?: true
  }

  export type BattleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Battle to aggregate.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Battles
    **/
    _count?: true | BattleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BattleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BattleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BattleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BattleMaxAggregateInputType
  }

  export type GetBattleAggregateType<T extends BattleAggregateArgs> = {
        [P in keyof T & keyof AggregateBattle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBattle[P]>
      : GetScalarType<T[P], AggregateBattle[P]>
  }




  export type BattleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleWhereInput
    orderBy?: BattleOrderByWithAggregationInput | BattleOrderByWithAggregationInput[]
    by: BattleScalarFieldEnum[] | BattleScalarFieldEnum
    having?: BattleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BattleCountAggregateInputType | true
    _avg?: BattleAvgAggregateInputType
    _sum?: BattleSumAggregateInputType
    _min?: BattleMinAggregateInputType
    _max?: BattleMaxAggregateInputType
  }

  export type BattleGroupByOutputType = {
    id: string
    quiz_id: string
    code: string
    status: $Enums.BattleStatus
    created_by: number
    created_at: Date
    started_at: Date | null
    ended_at: Date | null
    settings: JsonValue | null
    _count: BattleCountAggregateOutputType | null
    _avg: BattleAvgAggregateOutputType | null
    _sum: BattleSumAggregateOutputType | null
    _min: BattleMinAggregateOutputType | null
    _max: BattleMaxAggregateOutputType | null
  }

  type GetBattleGroupByPayload<T extends BattleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BattleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BattleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BattleGroupByOutputType[P]>
            : GetScalarType<T[P], BattleGroupByOutputType[P]>
        }
      >
    >


  export type BattleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    code?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    started_at?: boolean
    ended_at?: boolean
    settings?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
    participants?: boolean | Battle$participantsArgs<ExtArgs>
    _count?: boolean | BattleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battle"]>

  export type BattleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    code?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    started_at?: boolean
    ended_at?: boolean
    settings?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battle"]>

  export type BattleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    code?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    started_at?: boolean
    ended_at?: boolean
    settings?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battle"]>

  export type BattleSelectScalar = {
    id?: boolean
    quiz_id?: boolean
    code?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    started_at?: boolean
    ended_at?: boolean
    settings?: boolean
  }

  export type BattleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quiz_id" | "code" | "status" | "created_by" | "created_at" | "started_at" | "ended_at" | "settings", ExtArgs["result"]["battle"]>
  export type BattleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
    participants?: boolean | Battle$participantsArgs<ExtArgs>
    _count?: boolean | BattleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BattleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }
  export type BattleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $BattlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Battle"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      creator: Prisma.$userPayload<ExtArgs>
      participants: Prisma.$BattleParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quiz_id: string
      code: string
      status: $Enums.BattleStatus
      created_by: number
      created_at: Date
      started_at: Date | null
      ended_at: Date | null
      settings: Prisma.JsonValue | null
    }, ExtArgs["result"]["battle"]>
    composites: {}
  }

  type BattleGetPayload<S extends boolean | null | undefined | BattleDefaultArgs> = $Result.GetResult<Prisma.$BattlePayload, S>

  type BattleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BattleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BattleCountAggregateInputType | true
    }

  export interface BattleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Battle'], meta: { name: 'Battle' } }
    /**
     * Find zero or one Battle that matches the filter.
     * @param {BattleFindUniqueArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BattleFindUniqueArgs>(args: SelectSubset<T, BattleFindUniqueArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Battle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BattleFindUniqueOrThrowArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BattleFindUniqueOrThrowArgs>(args: SelectSubset<T, BattleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Battle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleFindFirstArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BattleFindFirstArgs>(args?: SelectSubset<T, BattleFindFirstArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Battle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleFindFirstOrThrowArgs} args - Arguments to find a Battle
     * @example
     * // Get one Battle
     * const battle = await prisma.battle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BattleFindFirstOrThrowArgs>(args?: SelectSubset<T, BattleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Battles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Battles
     * const battles = await prisma.battle.findMany()
     * 
     * // Get first 10 Battles
     * const battles = await prisma.battle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const battleWithIdOnly = await prisma.battle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BattleFindManyArgs>(args?: SelectSubset<T, BattleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Battle.
     * @param {BattleCreateArgs} args - Arguments to create a Battle.
     * @example
     * // Create one Battle
     * const Battle = await prisma.battle.create({
     *   data: {
     *     // ... data to create a Battle
     *   }
     * })
     * 
     */
    create<T extends BattleCreateArgs>(args: SelectSubset<T, BattleCreateArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Battles.
     * @param {BattleCreateManyArgs} args - Arguments to create many Battles.
     * @example
     * // Create many Battles
     * const battle = await prisma.battle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BattleCreateManyArgs>(args?: SelectSubset<T, BattleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Battles and returns the data saved in the database.
     * @param {BattleCreateManyAndReturnArgs} args - Arguments to create many Battles.
     * @example
     * // Create many Battles
     * const battle = await prisma.battle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Battles and only return the `id`
     * const battleWithIdOnly = await prisma.battle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BattleCreateManyAndReturnArgs>(args?: SelectSubset<T, BattleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Battle.
     * @param {BattleDeleteArgs} args - Arguments to delete one Battle.
     * @example
     * // Delete one Battle
     * const Battle = await prisma.battle.delete({
     *   where: {
     *     // ... filter to delete one Battle
     *   }
     * })
     * 
     */
    delete<T extends BattleDeleteArgs>(args: SelectSubset<T, BattleDeleteArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Battle.
     * @param {BattleUpdateArgs} args - Arguments to update one Battle.
     * @example
     * // Update one Battle
     * const battle = await prisma.battle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BattleUpdateArgs>(args: SelectSubset<T, BattleUpdateArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Battles.
     * @param {BattleDeleteManyArgs} args - Arguments to filter Battles to delete.
     * @example
     * // Delete a few Battles
     * const { count } = await prisma.battle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BattleDeleteManyArgs>(args?: SelectSubset<T, BattleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Battles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Battles
     * const battle = await prisma.battle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BattleUpdateManyArgs>(args: SelectSubset<T, BattleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Battles and returns the data updated in the database.
     * @param {BattleUpdateManyAndReturnArgs} args - Arguments to update many Battles.
     * @example
     * // Update many Battles
     * const battle = await prisma.battle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Battles and only return the `id`
     * const battleWithIdOnly = await prisma.battle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BattleUpdateManyAndReturnArgs>(args: SelectSubset<T, BattleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Battle.
     * @param {BattleUpsertArgs} args - Arguments to update or create a Battle.
     * @example
     * // Update or create a Battle
     * const battle = await prisma.battle.upsert({
     *   create: {
     *     // ... data to create a Battle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Battle we want to update
     *   }
     * })
     */
    upsert<T extends BattleUpsertArgs>(args: SelectSubset<T, BattleUpsertArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Battles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleCountArgs} args - Arguments to filter Battles to count.
     * @example
     * // Count the number of Battles
     * const count = await prisma.battle.count({
     *   where: {
     *     // ... the filter for the Battles we want to count
     *   }
     * })
    **/
    count<T extends BattleCountArgs>(
      args?: Subset<T, BattleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BattleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Battle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BattleAggregateArgs>(args: Subset<T, BattleAggregateArgs>): Prisma.PrismaPromise<GetBattleAggregateType<T>>

    /**
     * Group by Battle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BattleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BattleGroupByArgs['orderBy'] }
        : { orderBy?: BattleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BattleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBattleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Battle model
   */
  readonly fields: BattleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Battle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BattleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Battle$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Battle$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Battle model
   */
  interface BattleFieldRefs {
    readonly id: FieldRef<"Battle", 'String'>
    readonly quiz_id: FieldRef<"Battle", 'String'>
    readonly code: FieldRef<"Battle", 'String'>
    readonly status: FieldRef<"Battle", 'BattleStatus'>
    readonly created_by: FieldRef<"Battle", 'Int'>
    readonly created_at: FieldRef<"Battle", 'DateTime'>
    readonly started_at: FieldRef<"Battle", 'DateTime'>
    readonly ended_at: FieldRef<"Battle", 'DateTime'>
    readonly settings: FieldRef<"Battle", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Battle findUnique
   */
  export type BattleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle findUniqueOrThrow
   */
  export type BattleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle findFirst
   */
  export type BattleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Battles.
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Battles.
     */
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Battle findFirstOrThrow
   */
  export type BattleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battle to fetch.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Battles.
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Battles.
     */
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Battle findMany
   */
  export type BattleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter, which Battles to fetch.
     */
    where?: BattleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Battles to fetch.
     */
    orderBy?: BattleOrderByWithRelationInput | BattleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Battles.
     */
    cursor?: BattleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Battles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Battles.
     */
    skip?: number
    distinct?: BattleScalarFieldEnum | BattleScalarFieldEnum[]
  }

  /**
   * Battle create
   */
  export type BattleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * The data needed to create a Battle.
     */
    data: XOR<BattleCreateInput, BattleUncheckedCreateInput>
  }

  /**
   * Battle createMany
   */
  export type BattleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Battles.
     */
    data: BattleCreateManyInput | BattleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Battle createManyAndReturn
   */
  export type BattleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * The data used to create many Battles.
     */
    data: BattleCreateManyInput | BattleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Battle update
   */
  export type BattleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * The data needed to update a Battle.
     */
    data: XOR<BattleUpdateInput, BattleUncheckedUpdateInput>
    /**
     * Choose, which Battle to update.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle updateMany
   */
  export type BattleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Battles.
     */
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyInput>
    /**
     * Filter which Battles to update
     */
    where?: BattleWhereInput
    /**
     * Limit how many Battles to update.
     */
    limit?: number
  }

  /**
   * Battle updateManyAndReturn
   */
  export type BattleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * The data used to update Battles.
     */
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyInput>
    /**
     * Filter which Battles to update
     */
    where?: BattleWhereInput
    /**
     * Limit how many Battles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Battle upsert
   */
  export type BattleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * The filter to search for the Battle to update in case it exists.
     */
    where: BattleWhereUniqueInput
    /**
     * In case the Battle found by the `where` argument doesn't exist, create a new Battle with this data.
     */
    create: XOR<BattleCreateInput, BattleUncheckedCreateInput>
    /**
     * In case the Battle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BattleUpdateInput, BattleUncheckedUpdateInput>
  }

  /**
   * Battle delete
   */
  export type BattleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
    /**
     * Filter which Battle to delete.
     */
    where: BattleWhereUniqueInput
  }

  /**
   * Battle deleteMany
   */
  export type BattleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Battles to delete
     */
    where?: BattleWhereInput
    /**
     * Limit how many Battles to delete.
     */
    limit?: number
  }

  /**
   * Battle.participants
   */
  export type Battle$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    where?: BattleParticipantWhereInput
    orderBy?: BattleParticipantOrderByWithRelationInput | BattleParticipantOrderByWithRelationInput[]
    cursor?: BattleParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BattleParticipantScalarFieldEnum | BattleParticipantScalarFieldEnum[]
  }

  /**
   * Battle without action
   */
  export type BattleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Battle
     */
    select?: BattleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Battle
     */
    omit?: BattleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleInclude<ExtArgs> | null
  }


  /**
   * Model BattleParticipant
   */

  export type AggregateBattleParticipant = {
    _count: BattleParticipantCountAggregateOutputType | null
    _avg: BattleParticipantAvgAggregateOutputType | null
    _sum: BattleParticipantSumAggregateOutputType | null
    _min: BattleParticipantMinAggregateOutputType | null
    _max: BattleParticipantMaxAggregateOutputType | null
  }

  export type BattleParticipantAvgAggregateOutputType = {
    user_id: number | null
    score: number | null
    current_q_index: number | null
  }

  export type BattleParticipantSumAggregateOutputType = {
    user_id: number | null
    score: number | null
    current_q_index: number | null
  }

  export type BattleParticipantMinAggregateOutputType = {
    id: string | null
    battle_id: string | null
    user_id: number | null
    score: number | null
    current_q_index: number | null
    finished: boolean | null
    joined_at: Date | null
    last_active: Date | null
  }

  export type BattleParticipantMaxAggregateOutputType = {
    id: string | null
    battle_id: string | null
    user_id: number | null
    score: number | null
    current_q_index: number | null
    finished: boolean | null
    joined_at: Date | null
    last_active: Date | null
  }

  export type BattleParticipantCountAggregateOutputType = {
    id: number
    battle_id: number
    user_id: number
    score: number
    current_q_index: number
    finished: number
    joined_at: number
    last_active: number
    _all: number
  }


  export type BattleParticipantAvgAggregateInputType = {
    user_id?: true
    score?: true
    current_q_index?: true
  }

  export type BattleParticipantSumAggregateInputType = {
    user_id?: true
    score?: true
    current_q_index?: true
  }

  export type BattleParticipantMinAggregateInputType = {
    id?: true
    battle_id?: true
    user_id?: true
    score?: true
    current_q_index?: true
    finished?: true
    joined_at?: true
    last_active?: true
  }

  export type BattleParticipantMaxAggregateInputType = {
    id?: true
    battle_id?: true
    user_id?: true
    score?: true
    current_q_index?: true
    finished?: true
    joined_at?: true
    last_active?: true
  }

  export type BattleParticipantCountAggregateInputType = {
    id?: true
    battle_id?: true
    user_id?: true
    score?: true
    current_q_index?: true
    finished?: true
    joined_at?: true
    last_active?: true
    _all?: true
  }

  export type BattleParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleParticipant to aggregate.
     */
    where?: BattleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleParticipants to fetch.
     */
    orderBy?: BattleParticipantOrderByWithRelationInput | BattleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BattleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BattleParticipants
    **/
    _count?: true | BattleParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BattleParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BattleParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BattleParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BattleParticipantMaxAggregateInputType
  }

  export type GetBattleParticipantAggregateType<T extends BattleParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateBattleParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBattleParticipant[P]>
      : GetScalarType<T[P], AggregateBattleParticipant[P]>
  }




  export type BattleParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BattleParticipantWhereInput
    orderBy?: BattleParticipantOrderByWithAggregationInput | BattleParticipantOrderByWithAggregationInput[]
    by: BattleParticipantScalarFieldEnum[] | BattleParticipantScalarFieldEnum
    having?: BattleParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BattleParticipantCountAggregateInputType | true
    _avg?: BattleParticipantAvgAggregateInputType
    _sum?: BattleParticipantSumAggregateInputType
    _min?: BattleParticipantMinAggregateInputType
    _max?: BattleParticipantMaxAggregateInputType
  }

  export type BattleParticipantGroupByOutputType = {
    id: string
    battle_id: string
    user_id: number
    score: number
    current_q_index: number
    finished: boolean
    joined_at: Date
    last_active: Date
    _count: BattleParticipantCountAggregateOutputType | null
    _avg: BattleParticipantAvgAggregateOutputType | null
    _sum: BattleParticipantSumAggregateOutputType | null
    _min: BattleParticipantMinAggregateOutputType | null
    _max: BattleParticipantMaxAggregateOutputType | null
  }

  type GetBattleParticipantGroupByPayload<T extends BattleParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BattleParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BattleParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BattleParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], BattleParticipantGroupByOutputType[P]>
        }
      >
    >


  export type BattleParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battle_id?: boolean
    user_id?: boolean
    score?: boolean
    current_q_index?: boolean
    finished?: boolean
    joined_at?: boolean
    last_active?: boolean
    battle?: boolean | BattleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleParticipant"]>

  export type BattleParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battle_id?: boolean
    user_id?: boolean
    score?: boolean
    current_q_index?: boolean
    finished?: boolean
    joined_at?: boolean
    last_active?: boolean
    battle?: boolean | BattleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleParticipant"]>

  export type BattleParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    battle_id?: boolean
    user_id?: boolean
    score?: boolean
    current_q_index?: boolean
    finished?: boolean
    joined_at?: boolean
    last_active?: boolean
    battle?: boolean | BattleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["battleParticipant"]>

  export type BattleParticipantSelectScalar = {
    id?: boolean
    battle_id?: boolean
    user_id?: boolean
    score?: boolean
    current_q_index?: boolean
    finished?: boolean
    joined_at?: boolean
    last_active?: boolean
  }

  export type BattleParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "battle_id" | "user_id" | "score" | "current_q_index" | "finished" | "joined_at" | "last_active", ExtArgs["result"]["battleParticipant"]>
  export type BattleParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | BattleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type BattleParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | BattleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type BattleParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    battle?: boolean | BattleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $BattleParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BattleParticipant"
    objects: {
      battle: Prisma.$BattlePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      battle_id: string
      user_id: number
      score: number
      current_q_index: number
      finished: boolean
      joined_at: Date
      last_active: Date
    }, ExtArgs["result"]["battleParticipant"]>
    composites: {}
  }

  type BattleParticipantGetPayload<S extends boolean | null | undefined | BattleParticipantDefaultArgs> = $Result.GetResult<Prisma.$BattleParticipantPayload, S>

  type BattleParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BattleParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BattleParticipantCountAggregateInputType | true
    }

  export interface BattleParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BattleParticipant'], meta: { name: 'BattleParticipant' } }
    /**
     * Find zero or one BattleParticipant that matches the filter.
     * @param {BattleParticipantFindUniqueArgs} args - Arguments to find a BattleParticipant
     * @example
     * // Get one BattleParticipant
     * const battleParticipant = await prisma.battleParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BattleParticipantFindUniqueArgs>(args: SelectSubset<T, BattleParticipantFindUniqueArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BattleParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BattleParticipantFindUniqueOrThrowArgs} args - Arguments to find a BattleParticipant
     * @example
     * // Get one BattleParticipant
     * const battleParticipant = await prisma.battleParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BattleParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, BattleParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantFindFirstArgs} args - Arguments to find a BattleParticipant
     * @example
     * // Get one BattleParticipant
     * const battleParticipant = await prisma.battleParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BattleParticipantFindFirstArgs>(args?: SelectSubset<T, BattleParticipantFindFirstArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BattleParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantFindFirstOrThrowArgs} args - Arguments to find a BattleParticipant
     * @example
     * // Get one BattleParticipant
     * const battleParticipant = await prisma.battleParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BattleParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, BattleParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BattleParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BattleParticipants
     * const battleParticipants = await prisma.battleParticipant.findMany()
     * 
     * // Get first 10 BattleParticipants
     * const battleParticipants = await prisma.battleParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const battleParticipantWithIdOnly = await prisma.battleParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BattleParticipantFindManyArgs>(args?: SelectSubset<T, BattleParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BattleParticipant.
     * @param {BattleParticipantCreateArgs} args - Arguments to create a BattleParticipant.
     * @example
     * // Create one BattleParticipant
     * const BattleParticipant = await prisma.battleParticipant.create({
     *   data: {
     *     // ... data to create a BattleParticipant
     *   }
     * })
     * 
     */
    create<T extends BattleParticipantCreateArgs>(args: SelectSubset<T, BattleParticipantCreateArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BattleParticipants.
     * @param {BattleParticipantCreateManyArgs} args - Arguments to create many BattleParticipants.
     * @example
     * // Create many BattleParticipants
     * const battleParticipant = await prisma.battleParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BattleParticipantCreateManyArgs>(args?: SelectSubset<T, BattleParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BattleParticipants and returns the data saved in the database.
     * @param {BattleParticipantCreateManyAndReturnArgs} args - Arguments to create many BattleParticipants.
     * @example
     * // Create many BattleParticipants
     * const battleParticipant = await prisma.battleParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BattleParticipants and only return the `id`
     * const battleParticipantWithIdOnly = await prisma.battleParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BattleParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, BattleParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BattleParticipant.
     * @param {BattleParticipantDeleteArgs} args - Arguments to delete one BattleParticipant.
     * @example
     * // Delete one BattleParticipant
     * const BattleParticipant = await prisma.battleParticipant.delete({
     *   where: {
     *     // ... filter to delete one BattleParticipant
     *   }
     * })
     * 
     */
    delete<T extends BattleParticipantDeleteArgs>(args: SelectSubset<T, BattleParticipantDeleteArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BattleParticipant.
     * @param {BattleParticipantUpdateArgs} args - Arguments to update one BattleParticipant.
     * @example
     * // Update one BattleParticipant
     * const battleParticipant = await prisma.battleParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BattleParticipantUpdateArgs>(args: SelectSubset<T, BattleParticipantUpdateArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BattleParticipants.
     * @param {BattleParticipantDeleteManyArgs} args - Arguments to filter BattleParticipants to delete.
     * @example
     * // Delete a few BattleParticipants
     * const { count } = await prisma.battleParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BattleParticipantDeleteManyArgs>(args?: SelectSubset<T, BattleParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BattleParticipants
     * const battleParticipant = await prisma.battleParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BattleParticipantUpdateManyArgs>(args: SelectSubset<T, BattleParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BattleParticipants and returns the data updated in the database.
     * @param {BattleParticipantUpdateManyAndReturnArgs} args - Arguments to update many BattleParticipants.
     * @example
     * // Update many BattleParticipants
     * const battleParticipant = await prisma.battleParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BattleParticipants and only return the `id`
     * const battleParticipantWithIdOnly = await prisma.battleParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BattleParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, BattleParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BattleParticipant.
     * @param {BattleParticipantUpsertArgs} args - Arguments to update or create a BattleParticipant.
     * @example
     * // Update or create a BattleParticipant
     * const battleParticipant = await prisma.battleParticipant.upsert({
     *   create: {
     *     // ... data to create a BattleParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BattleParticipant we want to update
     *   }
     * })
     */
    upsert<T extends BattleParticipantUpsertArgs>(args: SelectSubset<T, BattleParticipantUpsertArgs<ExtArgs>>): Prisma__BattleParticipantClient<$Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BattleParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantCountArgs} args - Arguments to filter BattleParticipants to count.
     * @example
     * // Count the number of BattleParticipants
     * const count = await prisma.battleParticipant.count({
     *   where: {
     *     // ... the filter for the BattleParticipants we want to count
     *   }
     * })
    **/
    count<T extends BattleParticipantCountArgs>(
      args?: Subset<T, BattleParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BattleParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BattleParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BattleParticipantAggregateArgs>(args: Subset<T, BattleParticipantAggregateArgs>): Prisma.PrismaPromise<GetBattleParticipantAggregateType<T>>

    /**
     * Group by BattleParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BattleParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BattleParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BattleParticipantGroupByArgs['orderBy'] }
        : { orderBy?: BattleParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BattleParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBattleParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BattleParticipant model
   */
  readonly fields: BattleParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BattleParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BattleParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    battle<T extends BattleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BattleDefaultArgs<ExtArgs>>): Prisma__BattleClient<$Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BattleParticipant model
   */
  interface BattleParticipantFieldRefs {
    readonly id: FieldRef<"BattleParticipant", 'String'>
    readonly battle_id: FieldRef<"BattleParticipant", 'String'>
    readonly user_id: FieldRef<"BattleParticipant", 'Int'>
    readonly score: FieldRef<"BattleParticipant", 'Int'>
    readonly current_q_index: FieldRef<"BattleParticipant", 'Int'>
    readonly finished: FieldRef<"BattleParticipant", 'Boolean'>
    readonly joined_at: FieldRef<"BattleParticipant", 'DateTime'>
    readonly last_active: FieldRef<"BattleParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BattleParticipant findUnique
   */
  export type BattleParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which BattleParticipant to fetch.
     */
    where: BattleParticipantWhereUniqueInput
  }

  /**
   * BattleParticipant findUniqueOrThrow
   */
  export type BattleParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which BattleParticipant to fetch.
     */
    where: BattleParticipantWhereUniqueInput
  }

  /**
   * BattleParticipant findFirst
   */
  export type BattleParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which BattleParticipant to fetch.
     */
    where?: BattleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleParticipants to fetch.
     */
    orderBy?: BattleParticipantOrderByWithRelationInput | BattleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleParticipants.
     */
    cursor?: BattleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleParticipants.
     */
    distinct?: BattleParticipantScalarFieldEnum | BattleParticipantScalarFieldEnum[]
  }

  /**
   * BattleParticipant findFirstOrThrow
   */
  export type BattleParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which BattleParticipant to fetch.
     */
    where?: BattleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleParticipants to fetch.
     */
    orderBy?: BattleParticipantOrderByWithRelationInput | BattleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BattleParticipants.
     */
    cursor?: BattleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BattleParticipants.
     */
    distinct?: BattleParticipantScalarFieldEnum | BattleParticipantScalarFieldEnum[]
  }

  /**
   * BattleParticipant findMany
   */
  export type BattleParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which BattleParticipants to fetch.
     */
    where?: BattleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BattleParticipants to fetch.
     */
    orderBy?: BattleParticipantOrderByWithRelationInput | BattleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BattleParticipants.
     */
    cursor?: BattleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BattleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BattleParticipants.
     */
    skip?: number
    distinct?: BattleParticipantScalarFieldEnum | BattleParticipantScalarFieldEnum[]
  }

  /**
   * BattleParticipant create
   */
  export type BattleParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a BattleParticipant.
     */
    data: XOR<BattleParticipantCreateInput, BattleParticipantUncheckedCreateInput>
  }

  /**
   * BattleParticipant createMany
   */
  export type BattleParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BattleParticipants.
     */
    data: BattleParticipantCreateManyInput | BattleParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BattleParticipant createManyAndReturn
   */
  export type BattleParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many BattleParticipants.
     */
    data: BattleParticipantCreateManyInput | BattleParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleParticipant update
   */
  export type BattleParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a BattleParticipant.
     */
    data: XOR<BattleParticipantUpdateInput, BattleParticipantUncheckedUpdateInput>
    /**
     * Choose, which BattleParticipant to update.
     */
    where: BattleParticipantWhereUniqueInput
  }

  /**
   * BattleParticipant updateMany
   */
  export type BattleParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BattleParticipants.
     */
    data: XOR<BattleParticipantUpdateManyMutationInput, BattleParticipantUncheckedUpdateManyInput>
    /**
     * Filter which BattleParticipants to update
     */
    where?: BattleParticipantWhereInput
    /**
     * Limit how many BattleParticipants to update.
     */
    limit?: number
  }

  /**
   * BattleParticipant updateManyAndReturn
   */
  export type BattleParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * The data used to update BattleParticipants.
     */
    data: XOR<BattleParticipantUpdateManyMutationInput, BattleParticipantUncheckedUpdateManyInput>
    /**
     * Filter which BattleParticipants to update
     */
    where?: BattleParticipantWhereInput
    /**
     * Limit how many BattleParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BattleParticipant upsert
   */
  export type BattleParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the BattleParticipant to update in case it exists.
     */
    where: BattleParticipantWhereUniqueInput
    /**
     * In case the BattleParticipant found by the `where` argument doesn't exist, create a new BattleParticipant with this data.
     */
    create: XOR<BattleParticipantCreateInput, BattleParticipantUncheckedCreateInput>
    /**
     * In case the BattleParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BattleParticipantUpdateInput, BattleParticipantUncheckedUpdateInput>
  }

  /**
   * BattleParticipant delete
   */
  export type BattleParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
    /**
     * Filter which BattleParticipant to delete.
     */
    where: BattleParticipantWhereUniqueInput
  }

  /**
   * BattleParticipant deleteMany
   */
  export type BattleParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BattleParticipants to delete
     */
    where?: BattleParticipantWhereInput
    /**
     * Limit how many BattleParticipants to delete.
     */
    limit?: number
  }

  /**
   * BattleParticipant without action
   */
  export type BattleParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BattleParticipant
     */
    select?: BattleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BattleParticipant
     */
    omit?: BattleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BattleParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Syllabus
   */

  export type AggregateSyllabus = {
    _count: SyllabusCountAggregateOutputType | null
    _avg: SyllabusAvgAggregateOutputType | null
    _sum: SyllabusSumAggregateOutputType | null
    _min: SyllabusMinAggregateOutputType | null
    _max: SyllabusMaxAggregateOutputType | null
  }

  export type SyllabusAvgAggregateOutputType = {
    id: number | null
  }

  export type SyllabusSumAggregateOutputType = {
    id: number | null
  }

  export type SyllabusMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    board: string | null
    class_level: string | null
    stream: string | null
    subject: string | null
    academic_year: string | null
    raw_text: string | null
    status: $Enums.SyllabusStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SyllabusMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    board: string | null
    class_level: string | null
    stream: string | null
    subject: string | null
    academic_year: string | null
    raw_text: string | null
    status: $Enums.SyllabusStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SyllabusCountAggregateOutputType = {
    id: number
    title: number
    description: number
    board: number
    class_level: number
    stream: number
    subject: number
    academic_year: number
    raw_text: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SyllabusAvgAggregateInputType = {
    id?: true
  }

  export type SyllabusSumAggregateInputType = {
    id?: true
  }

  export type SyllabusMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    board?: true
    class_level?: true
    stream?: true
    subject?: true
    academic_year?: true
    raw_text?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type SyllabusMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    board?: true
    class_level?: true
    stream?: true
    subject?: true
    academic_year?: true
    raw_text?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type SyllabusCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    board?: true
    class_level?: true
    stream?: true
    subject?: true
    academic_year?: true
    raw_text?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SyllabusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syllabus to aggregate.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Syllabi
    **/
    _count?: true | SyllabusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyllabusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyllabusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusMaxAggregateInputType
  }

  export type GetSyllabusAggregateType<T extends SyllabusAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabus[P]>
      : GetScalarType<T[P], AggregateSyllabus[P]>
  }




  export type SyllabusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusWhereInput
    orderBy?: SyllabusOrderByWithAggregationInput | SyllabusOrderByWithAggregationInput[]
    by: SyllabusScalarFieldEnum[] | SyllabusScalarFieldEnum
    having?: SyllabusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusCountAggregateInputType | true
    _avg?: SyllabusAvgAggregateInputType
    _sum?: SyllabusSumAggregateInputType
    _min?: SyllabusMinAggregateInputType
    _max?: SyllabusMaxAggregateInputType
  }

  export type SyllabusGroupByOutputType = {
    id: number
    title: string
    description: string | null
    board: string
    class_level: string
    stream: string | null
    subject: string
    academic_year: string | null
    raw_text: string | null
    status: $Enums.SyllabusStatus
    created_at: Date
    updated_at: Date
    _count: SyllabusCountAggregateOutputType | null
    _avg: SyllabusAvgAggregateOutputType | null
    _sum: SyllabusSumAggregateOutputType | null
    _min: SyllabusMinAggregateOutputType | null
    _max: SyllabusMaxAggregateOutputType | null
  }

  type GetSyllabusGroupByPayload<T extends SyllabusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    board?: boolean
    class_level?: boolean
    stream?: boolean
    subject?: boolean
    academic_year?: boolean
    raw_text?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    units?: boolean | Syllabus$unitsArgs<ExtArgs>
    textbooks?: boolean | Syllabus$textbooksArgs<ExtArgs>
    _count?: boolean | SyllabusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabus"]>

  export type SyllabusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    board?: boolean
    class_level?: boolean
    stream?: boolean
    subject?: boolean
    academic_year?: boolean
    raw_text?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["syllabus"]>

  export type SyllabusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    board?: boolean
    class_level?: boolean
    stream?: boolean
    subject?: boolean
    academic_year?: boolean
    raw_text?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["syllabus"]>

  export type SyllabusSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    board?: boolean
    class_level?: boolean
    stream?: boolean
    subject?: boolean
    academic_year?: boolean
    raw_text?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SyllabusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "board" | "class_level" | "stream" | "subject" | "academic_year" | "raw_text" | "status" | "created_at" | "updated_at", ExtArgs["result"]["syllabus"]>
  export type SyllabusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | Syllabus$unitsArgs<ExtArgs>
    textbooks?: boolean | Syllabus$textbooksArgs<ExtArgs>
    _count?: boolean | SyllabusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SyllabusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SyllabusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SyllabusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Syllabus"
    objects: {
      units: Prisma.$SyllabusUnitPayload<ExtArgs>[]
      textbooks: Prisma.$TextbookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      board: string
      class_level: string
      stream: string | null
      subject: string
      academic_year: string | null
      raw_text: string | null
      status: $Enums.SyllabusStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["syllabus"]>
    composites: {}
  }

  type SyllabusGetPayload<S extends boolean | null | undefined | SyllabusDefaultArgs> = $Result.GetResult<Prisma.$SyllabusPayload, S>

  type SyllabusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyllabusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyllabusCountAggregateInputType | true
    }

  export interface SyllabusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Syllabus'], meta: { name: 'Syllabus' } }
    /**
     * Find zero or one Syllabus that matches the filter.
     * @param {SyllabusFindUniqueArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusFindUniqueArgs>(args: SelectSubset<T, SyllabusFindUniqueArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Syllabus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyllabusFindUniqueOrThrowArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Syllabus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindFirstArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusFindFirstArgs>(args?: SelectSubset<T, SyllabusFindFirstArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Syllabus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindFirstOrThrowArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Syllabi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Syllabi
     * const syllabi = await prisma.syllabus.findMany()
     * 
     * // Get first 10 Syllabi
     * const syllabi = await prisma.syllabus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syllabusWithIdOnly = await prisma.syllabus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyllabusFindManyArgs>(args?: SelectSubset<T, SyllabusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Syllabus.
     * @param {SyllabusCreateArgs} args - Arguments to create a Syllabus.
     * @example
     * // Create one Syllabus
     * const Syllabus = await prisma.syllabus.create({
     *   data: {
     *     // ... data to create a Syllabus
     *   }
     * })
     * 
     */
    create<T extends SyllabusCreateArgs>(args: SelectSubset<T, SyllabusCreateArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Syllabi.
     * @param {SyllabusCreateManyArgs} args - Arguments to create many Syllabi.
     * @example
     * // Create many Syllabi
     * const syllabus = await prisma.syllabus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusCreateManyArgs>(args?: SelectSubset<T, SyllabusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Syllabi and returns the data saved in the database.
     * @param {SyllabusCreateManyAndReturnArgs} args - Arguments to create many Syllabi.
     * @example
     * // Create many Syllabi
     * const syllabus = await prisma.syllabus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Syllabi and only return the `id`
     * const syllabusWithIdOnly = await prisma.syllabus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyllabusCreateManyAndReturnArgs>(args?: SelectSubset<T, SyllabusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Syllabus.
     * @param {SyllabusDeleteArgs} args - Arguments to delete one Syllabus.
     * @example
     * // Delete one Syllabus
     * const Syllabus = await prisma.syllabus.delete({
     *   where: {
     *     // ... filter to delete one Syllabus
     *   }
     * })
     * 
     */
    delete<T extends SyllabusDeleteArgs>(args: SelectSubset<T, SyllabusDeleteArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Syllabus.
     * @param {SyllabusUpdateArgs} args - Arguments to update one Syllabus.
     * @example
     * // Update one Syllabus
     * const syllabus = await prisma.syllabus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusUpdateArgs>(args: SelectSubset<T, SyllabusUpdateArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Syllabi.
     * @param {SyllabusDeleteManyArgs} args - Arguments to filter Syllabi to delete.
     * @example
     * // Delete a few Syllabi
     * const { count } = await prisma.syllabus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusDeleteManyArgs>(args?: SelectSubset<T, SyllabusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Syllabi
     * const syllabus = await prisma.syllabus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusUpdateManyArgs>(args: SelectSubset<T, SyllabusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syllabi and returns the data updated in the database.
     * @param {SyllabusUpdateManyAndReturnArgs} args - Arguments to update many Syllabi.
     * @example
     * // Update many Syllabi
     * const syllabus = await prisma.syllabus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Syllabi and only return the `id`
     * const syllabusWithIdOnly = await prisma.syllabus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyllabusUpdateManyAndReturnArgs>(args: SelectSubset<T, SyllabusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Syllabus.
     * @param {SyllabusUpsertArgs} args - Arguments to update or create a Syllabus.
     * @example
     * // Update or create a Syllabus
     * const syllabus = await prisma.syllabus.upsert({
     *   create: {
     *     // ... data to create a Syllabus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Syllabus we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusUpsertArgs>(args: SelectSubset<T, SyllabusUpsertArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Syllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusCountArgs} args - Arguments to filter Syllabi to count.
     * @example
     * // Count the number of Syllabi
     * const count = await prisma.syllabus.count({
     *   where: {
     *     // ... the filter for the Syllabi we want to count
     *   }
     * })
    **/
    count<T extends SyllabusCountArgs>(
      args?: Subset<T, SyllabusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Syllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusAggregateArgs>(args: Subset<T, SyllabusAggregateArgs>): Prisma.PrismaPromise<GetSyllabusAggregateType<T>>

    /**
     * Group by Syllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Syllabus model
   */
  readonly fields: SyllabusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Syllabus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    units<T extends Syllabus$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Syllabus$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    textbooks<T extends Syllabus$textbooksArgs<ExtArgs> = {}>(args?: Subset<T, Syllabus$textbooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Syllabus model
   */
  interface SyllabusFieldRefs {
    readonly id: FieldRef<"Syllabus", 'Int'>
    readonly title: FieldRef<"Syllabus", 'String'>
    readonly description: FieldRef<"Syllabus", 'String'>
    readonly board: FieldRef<"Syllabus", 'String'>
    readonly class_level: FieldRef<"Syllabus", 'String'>
    readonly stream: FieldRef<"Syllabus", 'String'>
    readonly subject: FieldRef<"Syllabus", 'String'>
    readonly academic_year: FieldRef<"Syllabus", 'String'>
    readonly raw_text: FieldRef<"Syllabus", 'String'>
    readonly status: FieldRef<"Syllabus", 'SyllabusStatus'>
    readonly created_at: FieldRef<"Syllabus", 'DateTime'>
    readonly updated_at: FieldRef<"Syllabus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Syllabus findUnique
   */
  export type SyllabusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus findUniqueOrThrow
   */
  export type SyllabusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus findFirst
   */
  export type SyllabusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syllabi.
     */
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus findFirstOrThrow
   */
  export type SyllabusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syllabi.
     */
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus findMany
   */
  export type SyllabusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabi to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus create
   */
  export type SyllabusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The data needed to create a Syllabus.
     */
    data: XOR<SyllabusCreateInput, SyllabusUncheckedCreateInput>
  }

  /**
   * Syllabus createMany
   */
  export type SyllabusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Syllabi.
     */
    data: SyllabusCreateManyInput | SyllabusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Syllabus createManyAndReturn
   */
  export type SyllabusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * The data used to create many Syllabi.
     */
    data: SyllabusCreateManyInput | SyllabusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Syllabus update
   */
  export type SyllabusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The data needed to update a Syllabus.
     */
    data: XOR<SyllabusUpdateInput, SyllabusUncheckedUpdateInput>
    /**
     * Choose, which Syllabus to update.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus updateMany
   */
  export type SyllabusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Syllabi.
     */
    data: XOR<SyllabusUpdateManyMutationInput, SyllabusUncheckedUpdateManyInput>
    /**
     * Filter which Syllabi to update
     */
    where?: SyllabusWhereInput
    /**
     * Limit how many Syllabi to update.
     */
    limit?: number
  }

  /**
   * Syllabus updateManyAndReturn
   */
  export type SyllabusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * The data used to update Syllabi.
     */
    data: XOR<SyllabusUpdateManyMutationInput, SyllabusUncheckedUpdateManyInput>
    /**
     * Filter which Syllabi to update
     */
    where?: SyllabusWhereInput
    /**
     * Limit how many Syllabi to update.
     */
    limit?: number
  }

  /**
   * Syllabus upsert
   */
  export type SyllabusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The filter to search for the Syllabus to update in case it exists.
     */
    where: SyllabusWhereUniqueInput
    /**
     * In case the Syllabus found by the `where` argument doesn't exist, create a new Syllabus with this data.
     */
    create: XOR<SyllabusCreateInput, SyllabusUncheckedCreateInput>
    /**
     * In case the Syllabus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusUpdateInput, SyllabusUncheckedUpdateInput>
  }

  /**
   * Syllabus delete
   */
  export type SyllabusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter which Syllabus to delete.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus deleteMany
   */
  export type SyllabusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syllabi to delete
     */
    where?: SyllabusWhereInput
    /**
     * Limit how many Syllabi to delete.
     */
    limit?: number
  }

  /**
   * Syllabus.units
   */
  export type Syllabus$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    where?: SyllabusUnitWhereInput
    orderBy?: SyllabusUnitOrderByWithRelationInput | SyllabusUnitOrderByWithRelationInput[]
    cursor?: SyllabusUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusUnitScalarFieldEnum | SyllabusUnitScalarFieldEnum[]
  }

  /**
   * Syllabus.textbooks
   */
  export type Syllabus$textbooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    where?: TextbookWhereInput
    orderBy?: TextbookOrderByWithRelationInput | TextbookOrderByWithRelationInput[]
    cursor?: TextbookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextbookScalarFieldEnum | TextbookScalarFieldEnum[]
  }

  /**
   * Syllabus without action
   */
  export type SyllabusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
  }


  /**
   * Model SyllabusUnit
   */

  export type AggregateSyllabusUnit = {
    _count: SyllabusUnitCountAggregateOutputType | null
    _avg: SyllabusUnitAvgAggregateOutputType | null
    _sum: SyllabusUnitSumAggregateOutputType | null
    _min: SyllabusUnitMinAggregateOutputType | null
    _max: SyllabusUnitMaxAggregateOutputType | null
  }

  export type SyllabusUnitAvgAggregateOutputType = {
    id: number | null
    syllabus_id: number | null
    order: number | null
  }

  export type SyllabusUnitSumAggregateOutputType = {
    id: number | null
    syllabus_id: number | null
    order: number | null
  }

  export type SyllabusUnitMinAggregateOutputType = {
    id: number | null
    syllabus_id: number | null
    title: string | null
    order: number | null
    description: string | null
  }

  export type SyllabusUnitMaxAggregateOutputType = {
    id: number | null
    syllabus_id: number | null
    title: string | null
    order: number | null
    description: string | null
  }

  export type SyllabusUnitCountAggregateOutputType = {
    id: number
    syllabus_id: number
    title: number
    order: number
    description: number
    _all: number
  }


  export type SyllabusUnitAvgAggregateInputType = {
    id?: true
    syllabus_id?: true
    order?: true
  }

  export type SyllabusUnitSumAggregateInputType = {
    id?: true
    syllabus_id?: true
    order?: true
  }

  export type SyllabusUnitMinAggregateInputType = {
    id?: true
    syllabus_id?: true
    title?: true
    order?: true
    description?: true
  }

  export type SyllabusUnitMaxAggregateInputType = {
    id?: true
    syllabus_id?: true
    title?: true
    order?: true
    description?: true
  }

  export type SyllabusUnitCountAggregateInputType = {
    id?: true
    syllabus_id?: true
    title?: true
    order?: true
    description?: true
    _all?: true
  }

  export type SyllabusUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusUnit to aggregate.
     */
    where?: SyllabusUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusUnits to fetch.
     */
    orderBy?: SyllabusUnitOrderByWithRelationInput | SyllabusUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyllabusUnits
    **/
    _count?: true | SyllabusUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyllabusUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyllabusUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusUnitMaxAggregateInputType
  }

  export type GetSyllabusUnitAggregateType<T extends SyllabusUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabusUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabusUnit[P]>
      : GetScalarType<T[P], AggregateSyllabusUnit[P]>
  }




  export type SyllabusUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusUnitWhereInput
    orderBy?: SyllabusUnitOrderByWithAggregationInput | SyllabusUnitOrderByWithAggregationInput[]
    by: SyllabusUnitScalarFieldEnum[] | SyllabusUnitScalarFieldEnum
    having?: SyllabusUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusUnitCountAggregateInputType | true
    _avg?: SyllabusUnitAvgAggregateInputType
    _sum?: SyllabusUnitSumAggregateInputType
    _min?: SyllabusUnitMinAggregateInputType
    _max?: SyllabusUnitMaxAggregateInputType
  }

  export type SyllabusUnitGroupByOutputType = {
    id: number
    syllabus_id: number
    title: string
    order: number
    description: string | null
    _count: SyllabusUnitCountAggregateOutputType | null
    _avg: SyllabusUnitAvgAggregateOutputType | null
    _sum: SyllabusUnitSumAggregateOutputType | null
    _min: SyllabusUnitMinAggregateOutputType | null
    _max: SyllabusUnitMaxAggregateOutputType | null
  }

  type GetSyllabusUnitGroupByPayload<T extends SyllabusUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusUnitGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusUnitGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syllabus_id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
    chapters?: boolean | SyllabusUnit$chaptersArgs<ExtArgs>
    _count?: boolean | SyllabusUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusUnit"]>

  export type SyllabusUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syllabus_id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusUnit"]>

  export type SyllabusUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syllabus_id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusUnit"]>

  export type SyllabusUnitSelectScalar = {
    id?: boolean
    syllabus_id?: boolean
    title?: boolean
    order?: boolean
    description?: boolean
  }

  export type SyllabusUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syllabus_id" | "title" | "order" | "description", ExtArgs["result"]["syllabusUnit"]>
  export type SyllabusUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
    chapters?: boolean | SyllabusUnit$chaptersArgs<ExtArgs>
    _count?: boolean | SyllabusUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SyllabusUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
  }
  export type SyllabusUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
  }

  export type $SyllabusUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyllabusUnit"
    objects: {
      syllabus: Prisma.$SyllabusPayload<ExtArgs>
      chapters: Prisma.$SyllabusChapterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      syllabus_id: number
      title: string
      order: number
      description: string | null
    }, ExtArgs["result"]["syllabusUnit"]>
    composites: {}
  }

  type SyllabusUnitGetPayload<S extends boolean | null | undefined | SyllabusUnitDefaultArgs> = $Result.GetResult<Prisma.$SyllabusUnitPayload, S>

  type SyllabusUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyllabusUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyllabusUnitCountAggregateInputType | true
    }

  export interface SyllabusUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyllabusUnit'], meta: { name: 'SyllabusUnit' } }
    /**
     * Find zero or one SyllabusUnit that matches the filter.
     * @param {SyllabusUnitFindUniqueArgs} args - Arguments to find a SyllabusUnit
     * @example
     * // Get one SyllabusUnit
     * const syllabusUnit = await prisma.syllabusUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusUnitFindUniqueArgs>(args: SelectSubset<T, SyllabusUnitFindUniqueArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyllabusUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyllabusUnitFindUniqueOrThrowArgs} args - Arguments to find a SyllabusUnit
     * @example
     * // Get one SyllabusUnit
     * const syllabusUnit = await prisma.syllabusUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyllabusUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitFindFirstArgs} args - Arguments to find a SyllabusUnit
     * @example
     * // Get one SyllabusUnit
     * const syllabusUnit = await prisma.syllabusUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusUnitFindFirstArgs>(args?: SelectSubset<T, SyllabusUnitFindFirstArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyllabusUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitFindFirstOrThrowArgs} args - Arguments to find a SyllabusUnit
     * @example
     * // Get one SyllabusUnit
     * const syllabusUnit = await prisma.syllabusUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyllabusUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyllabusUnits
     * const syllabusUnits = await prisma.syllabusUnit.findMany()
     * 
     * // Get first 10 SyllabusUnits
     * const syllabusUnits = await prisma.syllabusUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syllabusUnitWithIdOnly = await prisma.syllabusUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyllabusUnitFindManyArgs>(args?: SelectSubset<T, SyllabusUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyllabusUnit.
     * @param {SyllabusUnitCreateArgs} args - Arguments to create a SyllabusUnit.
     * @example
     * // Create one SyllabusUnit
     * const SyllabusUnit = await prisma.syllabusUnit.create({
     *   data: {
     *     // ... data to create a SyllabusUnit
     *   }
     * })
     * 
     */
    create<T extends SyllabusUnitCreateArgs>(args: SelectSubset<T, SyllabusUnitCreateArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyllabusUnits.
     * @param {SyllabusUnitCreateManyArgs} args - Arguments to create many SyllabusUnits.
     * @example
     * // Create many SyllabusUnits
     * const syllabusUnit = await prisma.syllabusUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusUnitCreateManyArgs>(args?: SelectSubset<T, SyllabusUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyllabusUnits and returns the data saved in the database.
     * @param {SyllabusUnitCreateManyAndReturnArgs} args - Arguments to create many SyllabusUnits.
     * @example
     * // Create many SyllabusUnits
     * const syllabusUnit = await prisma.syllabusUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyllabusUnits and only return the `id`
     * const syllabusUnitWithIdOnly = await prisma.syllabusUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyllabusUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, SyllabusUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyllabusUnit.
     * @param {SyllabusUnitDeleteArgs} args - Arguments to delete one SyllabusUnit.
     * @example
     * // Delete one SyllabusUnit
     * const SyllabusUnit = await prisma.syllabusUnit.delete({
     *   where: {
     *     // ... filter to delete one SyllabusUnit
     *   }
     * })
     * 
     */
    delete<T extends SyllabusUnitDeleteArgs>(args: SelectSubset<T, SyllabusUnitDeleteArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyllabusUnit.
     * @param {SyllabusUnitUpdateArgs} args - Arguments to update one SyllabusUnit.
     * @example
     * // Update one SyllabusUnit
     * const syllabusUnit = await prisma.syllabusUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusUnitUpdateArgs>(args: SelectSubset<T, SyllabusUnitUpdateArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyllabusUnits.
     * @param {SyllabusUnitDeleteManyArgs} args - Arguments to filter SyllabusUnits to delete.
     * @example
     * // Delete a few SyllabusUnits
     * const { count } = await prisma.syllabusUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusUnitDeleteManyArgs>(args?: SelectSubset<T, SyllabusUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyllabusUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyllabusUnits
     * const syllabusUnit = await prisma.syllabusUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusUnitUpdateManyArgs>(args: SelectSubset<T, SyllabusUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyllabusUnits and returns the data updated in the database.
     * @param {SyllabusUnitUpdateManyAndReturnArgs} args - Arguments to update many SyllabusUnits.
     * @example
     * // Update many SyllabusUnits
     * const syllabusUnit = await prisma.syllabusUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyllabusUnits and only return the `id`
     * const syllabusUnitWithIdOnly = await prisma.syllabusUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyllabusUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, SyllabusUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyllabusUnit.
     * @param {SyllabusUnitUpsertArgs} args - Arguments to update or create a SyllabusUnit.
     * @example
     * // Update or create a SyllabusUnit
     * const syllabusUnit = await prisma.syllabusUnit.upsert({
     *   create: {
     *     // ... data to create a SyllabusUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyllabusUnit we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusUnitUpsertArgs>(args: SelectSubset<T, SyllabusUnitUpsertArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyllabusUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitCountArgs} args - Arguments to filter SyllabusUnits to count.
     * @example
     * // Count the number of SyllabusUnits
     * const count = await prisma.syllabusUnit.count({
     *   where: {
     *     // ... the filter for the SyllabusUnits we want to count
     *   }
     * })
    **/
    count<T extends SyllabusUnitCountArgs>(
      args?: Subset<T, SyllabusUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyllabusUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusUnitAggregateArgs>(args: Subset<T, SyllabusUnitAggregateArgs>): Prisma.PrismaPromise<GetSyllabusUnitAggregateType<T>>

    /**
     * Group by SyllabusUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusUnitGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyllabusUnit model
   */
  readonly fields: SyllabusUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyllabusUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    syllabus<T extends SyllabusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusDefaultArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapters<T extends SyllabusUnit$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusUnit$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyllabusUnit model
   */
  interface SyllabusUnitFieldRefs {
    readonly id: FieldRef<"SyllabusUnit", 'Int'>
    readonly syllabus_id: FieldRef<"SyllabusUnit", 'Int'>
    readonly title: FieldRef<"SyllabusUnit", 'String'>
    readonly order: FieldRef<"SyllabusUnit", 'Int'>
    readonly description: FieldRef<"SyllabusUnit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyllabusUnit findUnique
   */
  export type SyllabusUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusUnit to fetch.
     */
    where: SyllabusUnitWhereUniqueInput
  }

  /**
   * SyllabusUnit findUniqueOrThrow
   */
  export type SyllabusUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusUnit to fetch.
     */
    where: SyllabusUnitWhereUniqueInput
  }

  /**
   * SyllabusUnit findFirst
   */
  export type SyllabusUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusUnit to fetch.
     */
    where?: SyllabusUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusUnits to fetch.
     */
    orderBy?: SyllabusUnitOrderByWithRelationInput | SyllabusUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusUnits.
     */
    cursor?: SyllabusUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusUnits.
     */
    distinct?: SyllabusUnitScalarFieldEnum | SyllabusUnitScalarFieldEnum[]
  }

  /**
   * SyllabusUnit findFirstOrThrow
   */
  export type SyllabusUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusUnit to fetch.
     */
    where?: SyllabusUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusUnits to fetch.
     */
    orderBy?: SyllabusUnitOrderByWithRelationInput | SyllabusUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusUnits.
     */
    cursor?: SyllabusUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusUnits.
     */
    distinct?: SyllabusUnitScalarFieldEnum | SyllabusUnitScalarFieldEnum[]
  }

  /**
   * SyllabusUnit findMany
   */
  export type SyllabusUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusUnits to fetch.
     */
    where?: SyllabusUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusUnits to fetch.
     */
    orderBy?: SyllabusUnitOrderByWithRelationInput | SyllabusUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyllabusUnits.
     */
    cursor?: SyllabusUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusUnits.
     */
    skip?: number
    distinct?: SyllabusUnitScalarFieldEnum | SyllabusUnitScalarFieldEnum[]
  }

  /**
   * SyllabusUnit create
   */
  export type SyllabusUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a SyllabusUnit.
     */
    data: XOR<SyllabusUnitCreateInput, SyllabusUnitUncheckedCreateInput>
  }

  /**
   * SyllabusUnit createMany
   */
  export type SyllabusUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyllabusUnits.
     */
    data: SyllabusUnitCreateManyInput | SyllabusUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyllabusUnit createManyAndReturn
   */
  export type SyllabusUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * The data used to create many SyllabusUnits.
     */
    data: SyllabusUnitCreateManyInput | SyllabusUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyllabusUnit update
   */
  export type SyllabusUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a SyllabusUnit.
     */
    data: XOR<SyllabusUnitUpdateInput, SyllabusUnitUncheckedUpdateInput>
    /**
     * Choose, which SyllabusUnit to update.
     */
    where: SyllabusUnitWhereUniqueInput
  }

  /**
   * SyllabusUnit updateMany
   */
  export type SyllabusUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyllabusUnits.
     */
    data: XOR<SyllabusUnitUpdateManyMutationInput, SyllabusUnitUncheckedUpdateManyInput>
    /**
     * Filter which SyllabusUnits to update
     */
    where?: SyllabusUnitWhereInput
    /**
     * Limit how many SyllabusUnits to update.
     */
    limit?: number
  }

  /**
   * SyllabusUnit updateManyAndReturn
   */
  export type SyllabusUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * The data used to update SyllabusUnits.
     */
    data: XOR<SyllabusUnitUpdateManyMutationInput, SyllabusUnitUncheckedUpdateManyInput>
    /**
     * Filter which SyllabusUnits to update
     */
    where?: SyllabusUnitWhereInput
    /**
     * Limit how many SyllabusUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyllabusUnit upsert
   */
  export type SyllabusUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the SyllabusUnit to update in case it exists.
     */
    where: SyllabusUnitWhereUniqueInput
    /**
     * In case the SyllabusUnit found by the `where` argument doesn't exist, create a new SyllabusUnit with this data.
     */
    create: XOR<SyllabusUnitCreateInput, SyllabusUnitUncheckedCreateInput>
    /**
     * In case the SyllabusUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusUnitUpdateInput, SyllabusUnitUncheckedUpdateInput>
  }

  /**
   * SyllabusUnit delete
   */
  export type SyllabusUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
    /**
     * Filter which SyllabusUnit to delete.
     */
    where: SyllabusUnitWhereUniqueInput
  }

  /**
   * SyllabusUnit deleteMany
   */
  export type SyllabusUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusUnits to delete
     */
    where?: SyllabusUnitWhereInput
    /**
     * Limit how many SyllabusUnits to delete.
     */
    limit?: number
  }

  /**
   * SyllabusUnit.chapters
   */
  export type SyllabusUnit$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    where?: SyllabusChapterWhereInput
    orderBy?: SyllabusChapterOrderByWithRelationInput | SyllabusChapterOrderByWithRelationInput[]
    cursor?: SyllabusChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusChapterScalarFieldEnum | SyllabusChapterScalarFieldEnum[]
  }

  /**
   * SyllabusUnit without action
   */
  export type SyllabusUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusUnit
     */
    select?: SyllabusUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusUnit
     */
    omit?: SyllabusUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusUnitInclude<ExtArgs> | null
  }


  /**
   * Model SyllabusChapter
   */

  export type AggregateSyllabusChapter = {
    _count: SyllabusChapterCountAggregateOutputType | null
    _avg: SyllabusChapterAvgAggregateOutputType | null
    _sum: SyllabusChapterSumAggregateOutputType | null
    _min: SyllabusChapterMinAggregateOutputType | null
    _max: SyllabusChapterMaxAggregateOutputType | null
  }

  export type SyllabusChapterAvgAggregateOutputType = {
    id: number | null
    unit_id: number | null
    order: number | null
  }

  export type SyllabusChapterSumAggregateOutputType = {
    id: number | null
    unit_id: number | null
    order: number | null
  }

  export type SyllabusChapterMinAggregateOutputType = {
    id: number | null
    unit_id: number | null
    chapter_number: string | null
    title: string | null
    order: number | null
  }

  export type SyllabusChapterMaxAggregateOutputType = {
    id: number | null
    unit_id: number | null
    chapter_number: string | null
    title: string | null
    order: number | null
  }

  export type SyllabusChapterCountAggregateOutputType = {
    id: number
    unit_id: number
    chapter_number: number
    title: number
    order: number
    subtopics: number
    _all: number
  }


  export type SyllabusChapterAvgAggregateInputType = {
    id?: true
    unit_id?: true
    order?: true
  }

  export type SyllabusChapterSumAggregateInputType = {
    id?: true
    unit_id?: true
    order?: true
  }

  export type SyllabusChapterMinAggregateInputType = {
    id?: true
    unit_id?: true
    chapter_number?: true
    title?: true
    order?: true
  }

  export type SyllabusChapterMaxAggregateInputType = {
    id?: true
    unit_id?: true
    chapter_number?: true
    title?: true
    order?: true
  }

  export type SyllabusChapterCountAggregateInputType = {
    id?: true
    unit_id?: true
    chapter_number?: true
    title?: true
    order?: true
    subtopics?: true
    _all?: true
  }

  export type SyllabusChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusChapter to aggregate.
     */
    where?: SyllabusChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusChapters to fetch.
     */
    orderBy?: SyllabusChapterOrderByWithRelationInput | SyllabusChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyllabusChapters
    **/
    _count?: true | SyllabusChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyllabusChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyllabusChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusChapterMaxAggregateInputType
  }

  export type GetSyllabusChapterAggregateType<T extends SyllabusChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabusChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabusChapter[P]>
      : GetScalarType<T[P], AggregateSyllabusChapter[P]>
  }




  export type SyllabusChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusChapterWhereInput
    orderBy?: SyllabusChapterOrderByWithAggregationInput | SyllabusChapterOrderByWithAggregationInput[]
    by: SyllabusChapterScalarFieldEnum[] | SyllabusChapterScalarFieldEnum
    having?: SyllabusChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusChapterCountAggregateInputType | true
    _avg?: SyllabusChapterAvgAggregateInputType
    _sum?: SyllabusChapterSumAggregateInputType
    _min?: SyllabusChapterMinAggregateInputType
    _max?: SyllabusChapterMaxAggregateInputType
  }

  export type SyllabusChapterGroupByOutputType = {
    id: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    subtopics: JsonValue | null
    _count: SyllabusChapterCountAggregateOutputType | null
    _avg: SyllabusChapterAvgAggregateOutputType | null
    _sum: SyllabusChapterSumAggregateOutputType | null
    _min: SyllabusChapterMinAggregateOutputType | null
    _max: SyllabusChapterMaxAggregateOutputType | null
  }

  type GetSyllabusChapterGroupByPayload<T extends SyllabusChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusChapterGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusChapterGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    subtopics?: boolean
    unit?: boolean | SyllabusUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusChapter"]>

  export type SyllabusChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    subtopics?: boolean
    unit?: boolean | SyllabusUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusChapter"]>

  export type SyllabusChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    subtopics?: boolean
    unit?: boolean | SyllabusUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusChapter"]>

  export type SyllabusChapterSelectScalar = {
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    subtopics?: boolean
  }

  export type SyllabusChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "chapter_number" | "title" | "order" | "subtopics", ExtArgs["result"]["syllabusChapter"]>
  export type SyllabusChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | SyllabusUnitDefaultArgs<ExtArgs>
  }
  export type SyllabusChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | SyllabusUnitDefaultArgs<ExtArgs>
  }
  export type SyllabusChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | SyllabusUnitDefaultArgs<ExtArgs>
  }

  export type $SyllabusChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyllabusChapter"
    objects: {
      unit: Prisma.$SyllabusUnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unit_id: number
      chapter_number: string
      title: string
      order: number
      subtopics: Prisma.JsonValue | null
    }, ExtArgs["result"]["syllabusChapter"]>
    composites: {}
  }

  type SyllabusChapterGetPayload<S extends boolean | null | undefined | SyllabusChapterDefaultArgs> = $Result.GetResult<Prisma.$SyllabusChapterPayload, S>

  type SyllabusChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyllabusChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyllabusChapterCountAggregateInputType | true
    }

  export interface SyllabusChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyllabusChapter'], meta: { name: 'SyllabusChapter' } }
    /**
     * Find zero or one SyllabusChapter that matches the filter.
     * @param {SyllabusChapterFindUniqueArgs} args - Arguments to find a SyllabusChapter
     * @example
     * // Get one SyllabusChapter
     * const syllabusChapter = await prisma.syllabusChapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusChapterFindUniqueArgs>(args: SelectSubset<T, SyllabusChapterFindUniqueArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyllabusChapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyllabusChapterFindUniqueOrThrowArgs} args - Arguments to find a SyllabusChapter
     * @example
     * // Get one SyllabusChapter
     * const syllabusChapter = await prisma.syllabusChapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyllabusChapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterFindFirstArgs} args - Arguments to find a SyllabusChapter
     * @example
     * // Get one SyllabusChapter
     * const syllabusChapter = await prisma.syllabusChapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusChapterFindFirstArgs>(args?: SelectSubset<T, SyllabusChapterFindFirstArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyllabusChapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterFindFirstOrThrowArgs} args - Arguments to find a SyllabusChapter
     * @example
     * // Get one SyllabusChapter
     * const syllabusChapter = await prisma.syllabusChapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyllabusChapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyllabusChapters
     * const syllabusChapters = await prisma.syllabusChapter.findMany()
     * 
     * // Get first 10 SyllabusChapters
     * const syllabusChapters = await prisma.syllabusChapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syllabusChapterWithIdOnly = await prisma.syllabusChapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyllabusChapterFindManyArgs>(args?: SelectSubset<T, SyllabusChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyllabusChapter.
     * @param {SyllabusChapterCreateArgs} args - Arguments to create a SyllabusChapter.
     * @example
     * // Create one SyllabusChapter
     * const SyllabusChapter = await prisma.syllabusChapter.create({
     *   data: {
     *     // ... data to create a SyllabusChapter
     *   }
     * })
     * 
     */
    create<T extends SyllabusChapterCreateArgs>(args: SelectSubset<T, SyllabusChapterCreateArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyllabusChapters.
     * @param {SyllabusChapterCreateManyArgs} args - Arguments to create many SyllabusChapters.
     * @example
     * // Create many SyllabusChapters
     * const syllabusChapter = await prisma.syllabusChapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusChapterCreateManyArgs>(args?: SelectSubset<T, SyllabusChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyllabusChapters and returns the data saved in the database.
     * @param {SyllabusChapterCreateManyAndReturnArgs} args - Arguments to create many SyllabusChapters.
     * @example
     * // Create many SyllabusChapters
     * const syllabusChapter = await prisma.syllabusChapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyllabusChapters and only return the `id`
     * const syllabusChapterWithIdOnly = await prisma.syllabusChapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyllabusChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, SyllabusChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyllabusChapter.
     * @param {SyllabusChapterDeleteArgs} args - Arguments to delete one SyllabusChapter.
     * @example
     * // Delete one SyllabusChapter
     * const SyllabusChapter = await prisma.syllabusChapter.delete({
     *   where: {
     *     // ... filter to delete one SyllabusChapter
     *   }
     * })
     * 
     */
    delete<T extends SyllabusChapterDeleteArgs>(args: SelectSubset<T, SyllabusChapterDeleteArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyllabusChapter.
     * @param {SyllabusChapterUpdateArgs} args - Arguments to update one SyllabusChapter.
     * @example
     * // Update one SyllabusChapter
     * const syllabusChapter = await prisma.syllabusChapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusChapterUpdateArgs>(args: SelectSubset<T, SyllabusChapterUpdateArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyllabusChapters.
     * @param {SyllabusChapterDeleteManyArgs} args - Arguments to filter SyllabusChapters to delete.
     * @example
     * // Delete a few SyllabusChapters
     * const { count } = await prisma.syllabusChapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusChapterDeleteManyArgs>(args?: SelectSubset<T, SyllabusChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyllabusChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyllabusChapters
     * const syllabusChapter = await prisma.syllabusChapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusChapterUpdateManyArgs>(args: SelectSubset<T, SyllabusChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyllabusChapters and returns the data updated in the database.
     * @param {SyllabusChapterUpdateManyAndReturnArgs} args - Arguments to update many SyllabusChapters.
     * @example
     * // Update many SyllabusChapters
     * const syllabusChapter = await prisma.syllabusChapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyllabusChapters and only return the `id`
     * const syllabusChapterWithIdOnly = await prisma.syllabusChapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyllabusChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, SyllabusChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyllabusChapter.
     * @param {SyllabusChapterUpsertArgs} args - Arguments to update or create a SyllabusChapter.
     * @example
     * // Update or create a SyllabusChapter
     * const syllabusChapter = await prisma.syllabusChapter.upsert({
     *   create: {
     *     // ... data to create a SyllabusChapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyllabusChapter we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusChapterUpsertArgs>(args: SelectSubset<T, SyllabusChapterUpsertArgs<ExtArgs>>): Prisma__SyllabusChapterClient<$Result.GetResult<Prisma.$SyllabusChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyllabusChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterCountArgs} args - Arguments to filter SyllabusChapters to count.
     * @example
     * // Count the number of SyllabusChapters
     * const count = await prisma.syllabusChapter.count({
     *   where: {
     *     // ... the filter for the SyllabusChapters we want to count
     *   }
     * })
    **/
    count<T extends SyllabusChapterCountArgs>(
      args?: Subset<T, SyllabusChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyllabusChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusChapterAggregateArgs>(args: Subset<T, SyllabusChapterAggregateArgs>): Prisma.PrismaPromise<GetSyllabusChapterAggregateType<T>>

    /**
     * Group by SyllabusChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusChapterGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyllabusChapter model
   */
  readonly fields: SyllabusChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyllabusChapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends SyllabusUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusUnitDefaultArgs<ExtArgs>>): Prisma__SyllabusUnitClient<$Result.GetResult<Prisma.$SyllabusUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyllabusChapter model
   */
  interface SyllabusChapterFieldRefs {
    readonly id: FieldRef<"SyllabusChapter", 'Int'>
    readonly unit_id: FieldRef<"SyllabusChapter", 'Int'>
    readonly chapter_number: FieldRef<"SyllabusChapter", 'String'>
    readonly title: FieldRef<"SyllabusChapter", 'String'>
    readonly order: FieldRef<"SyllabusChapter", 'Int'>
    readonly subtopics: FieldRef<"SyllabusChapter", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SyllabusChapter findUnique
   */
  export type SyllabusChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusChapter to fetch.
     */
    where: SyllabusChapterWhereUniqueInput
  }

  /**
   * SyllabusChapter findUniqueOrThrow
   */
  export type SyllabusChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusChapter to fetch.
     */
    where: SyllabusChapterWhereUniqueInput
  }

  /**
   * SyllabusChapter findFirst
   */
  export type SyllabusChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusChapter to fetch.
     */
    where?: SyllabusChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusChapters to fetch.
     */
    orderBy?: SyllabusChapterOrderByWithRelationInput | SyllabusChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusChapters.
     */
    cursor?: SyllabusChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusChapters.
     */
    distinct?: SyllabusChapterScalarFieldEnum | SyllabusChapterScalarFieldEnum[]
  }

  /**
   * SyllabusChapter findFirstOrThrow
   */
  export type SyllabusChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusChapter to fetch.
     */
    where?: SyllabusChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusChapters to fetch.
     */
    orderBy?: SyllabusChapterOrderByWithRelationInput | SyllabusChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusChapters.
     */
    cursor?: SyllabusChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusChapters.
     */
    distinct?: SyllabusChapterScalarFieldEnum | SyllabusChapterScalarFieldEnum[]
  }

  /**
   * SyllabusChapter findMany
   */
  export type SyllabusChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusChapters to fetch.
     */
    where?: SyllabusChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusChapters to fetch.
     */
    orderBy?: SyllabusChapterOrderByWithRelationInput | SyllabusChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyllabusChapters.
     */
    cursor?: SyllabusChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusChapters.
     */
    skip?: number
    distinct?: SyllabusChapterScalarFieldEnum | SyllabusChapterScalarFieldEnum[]
  }

  /**
   * SyllabusChapter create
   */
  export type SyllabusChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a SyllabusChapter.
     */
    data: XOR<SyllabusChapterCreateInput, SyllabusChapterUncheckedCreateInput>
  }

  /**
   * SyllabusChapter createMany
   */
  export type SyllabusChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyllabusChapters.
     */
    data: SyllabusChapterCreateManyInput | SyllabusChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyllabusChapter createManyAndReturn
   */
  export type SyllabusChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * The data used to create many SyllabusChapters.
     */
    data: SyllabusChapterCreateManyInput | SyllabusChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyllabusChapter update
   */
  export type SyllabusChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a SyllabusChapter.
     */
    data: XOR<SyllabusChapterUpdateInput, SyllabusChapterUncheckedUpdateInput>
    /**
     * Choose, which SyllabusChapter to update.
     */
    where: SyllabusChapterWhereUniqueInput
  }

  /**
   * SyllabusChapter updateMany
   */
  export type SyllabusChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyllabusChapters.
     */
    data: XOR<SyllabusChapterUpdateManyMutationInput, SyllabusChapterUncheckedUpdateManyInput>
    /**
     * Filter which SyllabusChapters to update
     */
    where?: SyllabusChapterWhereInput
    /**
     * Limit how many SyllabusChapters to update.
     */
    limit?: number
  }

  /**
   * SyllabusChapter updateManyAndReturn
   */
  export type SyllabusChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * The data used to update SyllabusChapters.
     */
    data: XOR<SyllabusChapterUpdateManyMutationInput, SyllabusChapterUncheckedUpdateManyInput>
    /**
     * Filter which SyllabusChapters to update
     */
    where?: SyllabusChapterWhereInput
    /**
     * Limit how many SyllabusChapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyllabusChapter upsert
   */
  export type SyllabusChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the SyllabusChapter to update in case it exists.
     */
    where: SyllabusChapterWhereUniqueInput
    /**
     * In case the SyllabusChapter found by the `where` argument doesn't exist, create a new SyllabusChapter with this data.
     */
    create: XOR<SyllabusChapterCreateInput, SyllabusChapterUncheckedCreateInput>
    /**
     * In case the SyllabusChapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusChapterUpdateInput, SyllabusChapterUncheckedUpdateInput>
  }

  /**
   * SyllabusChapter delete
   */
  export type SyllabusChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
    /**
     * Filter which SyllabusChapter to delete.
     */
    where: SyllabusChapterWhereUniqueInput
  }

  /**
   * SyllabusChapter deleteMany
   */
  export type SyllabusChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusChapters to delete
     */
    where?: SyllabusChapterWhereInput
    /**
     * Limit how many SyllabusChapters to delete.
     */
    limit?: number
  }

  /**
   * SyllabusChapter without action
   */
  export type SyllabusChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusChapter
     */
    select?: SyllabusChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusChapter
     */
    omit?: SyllabusChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusChapterInclude<ExtArgs> | null
  }


  /**
   * Model Textbook
   */

  export type AggregateTextbook = {
    _count: TextbookCountAggregateOutputType | null
    _avg: TextbookAvgAggregateOutputType | null
    _sum: TextbookSumAggregateOutputType | null
    _min: TextbookMinAggregateOutputType | null
    _max: TextbookMaxAggregateOutputType | null
  }

  export type TextbookAvgAggregateOutputType = {
    id: number | null
    syllabus_id: number | null
    progress: number | null
    created_by: number | null
  }

  export type TextbookSumAggregateOutputType = {
    id: number | null
    syllabus_id: number | null
    progress: number | null
    created_by: number | null
  }

  export type TextbookMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    class_level: string | null
    stream: string | null
    subject_name: string | null
    board_id: string | null
    academic_year: string | null
    author: string | null
    syllabus_id: number | null
    raw_syllabus: string | null
    status: $Enums.TextbookStatus | null
    progress: number | null
    cover_image_url: string | null
    pdf_url: string | null
    compiled_pdf_url: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
  }

  export type TextbookMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    class_level: string | null
    stream: string | null
    subject_name: string | null
    board_id: string | null
    academic_year: string | null
    author: string | null
    syllabus_id: number | null
    raw_syllabus: string | null
    status: $Enums.TextbookStatus | null
    progress: number | null
    cover_image_url: string | null
    pdf_url: string | null
    compiled_pdf_url: string | null
    created_at: Date | null
    updated_at: Date | null
    created_by: number | null
  }

  export type TextbookCountAggregateOutputType = {
    id: number
    title: number
    description: number
    class_level: number
    stream: number
    subject_name: number
    board_id: number
    academic_year: number
    author: number
    syllabus_id: number
    raw_syllabus: number
    status: number
    progress: number
    cover_image_url: number
    pdf_url: number
    compiled_pdf_url: number
    created_at: number
    updated_at: number
    created_by: number
    _all: number
  }


  export type TextbookAvgAggregateInputType = {
    id?: true
    syllabus_id?: true
    progress?: true
    created_by?: true
  }

  export type TextbookSumAggregateInputType = {
    id?: true
    syllabus_id?: true
    progress?: true
    created_by?: true
  }

  export type TextbookMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    class_level?: true
    stream?: true
    subject_name?: true
    board_id?: true
    academic_year?: true
    author?: true
    syllabus_id?: true
    raw_syllabus?: true
    status?: true
    progress?: true
    cover_image_url?: true
    pdf_url?: true
    compiled_pdf_url?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type TextbookMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    class_level?: true
    stream?: true
    subject_name?: true
    board_id?: true
    academic_year?: true
    author?: true
    syllabus_id?: true
    raw_syllabus?: true
    status?: true
    progress?: true
    cover_image_url?: true
    pdf_url?: true
    compiled_pdf_url?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type TextbookCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    class_level?: true
    stream?: true
    subject_name?: true
    board_id?: true
    academic_year?: true
    author?: true
    syllabus_id?: true
    raw_syllabus?: true
    status?: true
    progress?: true
    cover_image_url?: true
    pdf_url?: true
    compiled_pdf_url?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    _all?: true
  }

  export type TextbookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Textbook to aggregate.
     */
    where?: TextbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Textbooks to fetch.
     */
    orderBy?: TextbookOrderByWithRelationInput | TextbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Textbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Textbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Textbooks
    **/
    _count?: true | TextbookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextbookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextbookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextbookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextbookMaxAggregateInputType
  }

  export type GetTextbookAggregateType<T extends TextbookAggregateArgs> = {
        [P in keyof T & keyof AggregateTextbook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextbook[P]>
      : GetScalarType<T[P], AggregateTextbook[P]>
  }




  export type TextbookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookWhereInput
    orderBy?: TextbookOrderByWithAggregationInput | TextbookOrderByWithAggregationInput[]
    by: TextbookScalarFieldEnum[] | TextbookScalarFieldEnum
    having?: TextbookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextbookCountAggregateInputType | true
    _avg?: TextbookAvgAggregateInputType
    _sum?: TextbookSumAggregateInputType
    _min?: TextbookMinAggregateInputType
    _max?: TextbookMaxAggregateInputType
  }

  export type TextbookGroupByOutputType = {
    id: number
    title: string
    description: string | null
    class_level: string
    stream: string | null
    subject_name: string | null
    board_id: string | null
    academic_year: string | null
    author: string | null
    syllabus_id: number | null
    raw_syllabus: string | null
    status: $Enums.TextbookStatus
    progress: number
    cover_image_url: string | null
    pdf_url: string | null
    compiled_pdf_url: string | null
    created_at: Date
    updated_at: Date
    created_by: number
    _count: TextbookCountAggregateOutputType | null
    _avg: TextbookAvgAggregateOutputType | null
    _sum: TextbookSumAggregateOutputType | null
    _min: TextbookMinAggregateOutputType | null
    _max: TextbookMaxAggregateOutputType | null
  }

  type GetTextbookGroupByPayload<T extends TextbookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextbookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextbookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextbookGroupByOutputType[P]>
            : GetScalarType<T[P], TextbookGroupByOutputType[P]>
        }
      >
    >


  export type TextbookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    class_level?: boolean
    stream?: boolean
    subject_name?: boolean
    board_id?: boolean
    academic_year?: boolean
    author?: boolean
    syllabus_id?: boolean
    raw_syllabus?: boolean
    status?: boolean
    progress?: boolean
    cover_image_url?: boolean
    pdf_url?: boolean
    compiled_pdf_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    syllabus?: boolean | Textbook$syllabusArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
    units?: boolean | Textbook$unitsArgs<ExtArgs>
    generation_jobs?: boolean | Textbook$generation_jobsArgs<ExtArgs>
    enrollments?: boolean | Textbook$enrollmentsArgs<ExtArgs>
    _count?: boolean | TextbookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbook"]>

  export type TextbookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    class_level?: boolean
    stream?: boolean
    subject_name?: boolean
    board_id?: boolean
    academic_year?: boolean
    author?: boolean
    syllabus_id?: boolean
    raw_syllabus?: boolean
    status?: boolean
    progress?: boolean
    cover_image_url?: boolean
    pdf_url?: boolean
    compiled_pdf_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    syllabus?: boolean | Textbook$syllabusArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbook"]>

  export type TextbookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    class_level?: boolean
    stream?: boolean
    subject_name?: boolean
    board_id?: boolean
    academic_year?: boolean
    author?: boolean
    syllabus_id?: boolean
    raw_syllabus?: boolean
    status?: boolean
    progress?: boolean
    cover_image_url?: boolean
    pdf_url?: boolean
    compiled_pdf_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    syllabus?: boolean | Textbook$syllabusArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbook"]>

  export type TextbookSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    class_level?: boolean
    stream?: boolean
    subject_name?: boolean
    board_id?: boolean
    academic_year?: boolean
    author?: boolean
    syllabus_id?: boolean
    raw_syllabus?: boolean
    status?: boolean
    progress?: boolean
    cover_image_url?: boolean
    pdf_url?: boolean
    compiled_pdf_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }

  export type TextbookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "class_level" | "stream" | "subject_name" | "board_id" | "academic_year" | "author" | "syllabus_id" | "raw_syllabus" | "status" | "progress" | "cover_image_url" | "pdf_url" | "compiled_pdf_url" | "created_at" | "updated_at" | "created_by", ExtArgs["result"]["textbook"]>
  export type TextbookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | Textbook$syllabusArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
    units?: boolean | Textbook$unitsArgs<ExtArgs>
    generation_jobs?: boolean | Textbook$generation_jobsArgs<ExtArgs>
    enrollments?: boolean | Textbook$enrollmentsArgs<ExtArgs>
    _count?: boolean | TextbookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TextbookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | Textbook$syllabusArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }
  export type TextbookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | Textbook$syllabusArgs<ExtArgs>
    creator?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $TextbookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Textbook"
    objects: {
      syllabus: Prisma.$SyllabusPayload<ExtArgs> | null
      creator: Prisma.$userPayload<ExtArgs>
      units: Prisma.$TextbookUnitPayload<ExtArgs>[]
      generation_jobs: Prisma.$TextbookGenerationJobPayload<ExtArgs>[]
      enrollments: Prisma.$UserEnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      class_level: string
      stream: string | null
      subject_name: string | null
      board_id: string | null
      academic_year: string | null
      author: string | null
      syllabus_id: number | null
      raw_syllabus: string | null
      status: $Enums.TextbookStatus
      progress: number
      cover_image_url: string | null
      pdf_url: string | null
      compiled_pdf_url: string | null
      created_at: Date
      updated_at: Date
      created_by: number
    }, ExtArgs["result"]["textbook"]>
    composites: {}
  }

  type TextbookGetPayload<S extends boolean | null | undefined | TextbookDefaultArgs> = $Result.GetResult<Prisma.$TextbookPayload, S>

  type TextbookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextbookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextbookCountAggregateInputType | true
    }

  export interface TextbookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Textbook'], meta: { name: 'Textbook' } }
    /**
     * Find zero or one Textbook that matches the filter.
     * @param {TextbookFindUniqueArgs} args - Arguments to find a Textbook
     * @example
     * // Get one Textbook
     * const textbook = await prisma.textbook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextbookFindUniqueArgs>(args: SelectSubset<T, TextbookFindUniqueArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Textbook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextbookFindUniqueOrThrowArgs} args - Arguments to find a Textbook
     * @example
     * // Get one Textbook
     * const textbook = await prisma.textbook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextbookFindUniqueOrThrowArgs>(args: SelectSubset<T, TextbookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Textbook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookFindFirstArgs} args - Arguments to find a Textbook
     * @example
     * // Get one Textbook
     * const textbook = await prisma.textbook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextbookFindFirstArgs>(args?: SelectSubset<T, TextbookFindFirstArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Textbook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookFindFirstOrThrowArgs} args - Arguments to find a Textbook
     * @example
     * // Get one Textbook
     * const textbook = await prisma.textbook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextbookFindFirstOrThrowArgs>(args?: SelectSubset<T, TextbookFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Textbooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Textbooks
     * const textbooks = await prisma.textbook.findMany()
     * 
     * // Get first 10 Textbooks
     * const textbooks = await prisma.textbook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textbookWithIdOnly = await prisma.textbook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextbookFindManyArgs>(args?: SelectSubset<T, TextbookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Textbook.
     * @param {TextbookCreateArgs} args - Arguments to create a Textbook.
     * @example
     * // Create one Textbook
     * const Textbook = await prisma.textbook.create({
     *   data: {
     *     // ... data to create a Textbook
     *   }
     * })
     * 
     */
    create<T extends TextbookCreateArgs>(args: SelectSubset<T, TextbookCreateArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Textbooks.
     * @param {TextbookCreateManyArgs} args - Arguments to create many Textbooks.
     * @example
     * // Create many Textbooks
     * const textbook = await prisma.textbook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextbookCreateManyArgs>(args?: SelectSubset<T, TextbookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Textbooks and returns the data saved in the database.
     * @param {TextbookCreateManyAndReturnArgs} args - Arguments to create many Textbooks.
     * @example
     * // Create many Textbooks
     * const textbook = await prisma.textbook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Textbooks and only return the `id`
     * const textbookWithIdOnly = await prisma.textbook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextbookCreateManyAndReturnArgs>(args?: SelectSubset<T, TextbookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Textbook.
     * @param {TextbookDeleteArgs} args - Arguments to delete one Textbook.
     * @example
     * // Delete one Textbook
     * const Textbook = await prisma.textbook.delete({
     *   where: {
     *     // ... filter to delete one Textbook
     *   }
     * })
     * 
     */
    delete<T extends TextbookDeleteArgs>(args: SelectSubset<T, TextbookDeleteArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Textbook.
     * @param {TextbookUpdateArgs} args - Arguments to update one Textbook.
     * @example
     * // Update one Textbook
     * const textbook = await prisma.textbook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextbookUpdateArgs>(args: SelectSubset<T, TextbookUpdateArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Textbooks.
     * @param {TextbookDeleteManyArgs} args - Arguments to filter Textbooks to delete.
     * @example
     * // Delete a few Textbooks
     * const { count } = await prisma.textbook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextbookDeleteManyArgs>(args?: SelectSubset<T, TextbookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Textbooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Textbooks
     * const textbook = await prisma.textbook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextbookUpdateManyArgs>(args: SelectSubset<T, TextbookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Textbooks and returns the data updated in the database.
     * @param {TextbookUpdateManyAndReturnArgs} args - Arguments to update many Textbooks.
     * @example
     * // Update many Textbooks
     * const textbook = await prisma.textbook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Textbooks and only return the `id`
     * const textbookWithIdOnly = await prisma.textbook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextbookUpdateManyAndReturnArgs>(args: SelectSubset<T, TextbookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Textbook.
     * @param {TextbookUpsertArgs} args - Arguments to update or create a Textbook.
     * @example
     * // Update or create a Textbook
     * const textbook = await prisma.textbook.upsert({
     *   create: {
     *     // ... data to create a Textbook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Textbook we want to update
     *   }
     * })
     */
    upsert<T extends TextbookUpsertArgs>(args: SelectSubset<T, TextbookUpsertArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Textbooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookCountArgs} args - Arguments to filter Textbooks to count.
     * @example
     * // Count the number of Textbooks
     * const count = await prisma.textbook.count({
     *   where: {
     *     // ... the filter for the Textbooks we want to count
     *   }
     * })
    **/
    count<T extends TextbookCountArgs>(
      args?: Subset<T, TextbookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextbookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Textbook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextbookAggregateArgs>(args: Subset<T, TextbookAggregateArgs>): Prisma.PrismaPromise<GetTextbookAggregateType<T>>

    /**
     * Group by Textbook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextbookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextbookGroupByArgs['orderBy'] }
        : { orderBy?: TextbookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextbookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextbookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Textbook model
   */
  readonly fields: TextbookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Textbook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextbookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    syllabus<T extends Textbook$syllabusArgs<ExtArgs> = {}>(args?: Subset<T, Textbook$syllabusArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    units<T extends Textbook$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Textbook$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generation_jobs<T extends Textbook$generation_jobsArgs<ExtArgs> = {}>(args?: Subset<T, Textbook$generation_jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Textbook$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Textbook$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Textbook model
   */
  interface TextbookFieldRefs {
    readonly id: FieldRef<"Textbook", 'Int'>
    readonly title: FieldRef<"Textbook", 'String'>
    readonly description: FieldRef<"Textbook", 'String'>
    readonly class_level: FieldRef<"Textbook", 'String'>
    readonly stream: FieldRef<"Textbook", 'String'>
    readonly subject_name: FieldRef<"Textbook", 'String'>
    readonly board_id: FieldRef<"Textbook", 'String'>
    readonly academic_year: FieldRef<"Textbook", 'String'>
    readonly author: FieldRef<"Textbook", 'String'>
    readonly syllabus_id: FieldRef<"Textbook", 'Int'>
    readonly raw_syllabus: FieldRef<"Textbook", 'String'>
    readonly status: FieldRef<"Textbook", 'TextbookStatus'>
    readonly progress: FieldRef<"Textbook", 'Int'>
    readonly cover_image_url: FieldRef<"Textbook", 'String'>
    readonly pdf_url: FieldRef<"Textbook", 'String'>
    readonly compiled_pdf_url: FieldRef<"Textbook", 'String'>
    readonly created_at: FieldRef<"Textbook", 'DateTime'>
    readonly updated_at: FieldRef<"Textbook", 'DateTime'>
    readonly created_by: FieldRef<"Textbook", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Textbook findUnique
   */
  export type TextbookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * Filter, which Textbook to fetch.
     */
    where: TextbookWhereUniqueInput
  }

  /**
   * Textbook findUniqueOrThrow
   */
  export type TextbookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * Filter, which Textbook to fetch.
     */
    where: TextbookWhereUniqueInput
  }

  /**
   * Textbook findFirst
   */
  export type TextbookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * Filter, which Textbook to fetch.
     */
    where?: TextbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Textbooks to fetch.
     */
    orderBy?: TextbookOrderByWithRelationInput | TextbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Textbooks.
     */
    cursor?: TextbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Textbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Textbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Textbooks.
     */
    distinct?: TextbookScalarFieldEnum | TextbookScalarFieldEnum[]
  }

  /**
   * Textbook findFirstOrThrow
   */
  export type TextbookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * Filter, which Textbook to fetch.
     */
    where?: TextbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Textbooks to fetch.
     */
    orderBy?: TextbookOrderByWithRelationInput | TextbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Textbooks.
     */
    cursor?: TextbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Textbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Textbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Textbooks.
     */
    distinct?: TextbookScalarFieldEnum | TextbookScalarFieldEnum[]
  }

  /**
   * Textbook findMany
   */
  export type TextbookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * Filter, which Textbooks to fetch.
     */
    where?: TextbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Textbooks to fetch.
     */
    orderBy?: TextbookOrderByWithRelationInput | TextbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Textbooks.
     */
    cursor?: TextbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Textbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Textbooks.
     */
    skip?: number
    distinct?: TextbookScalarFieldEnum | TextbookScalarFieldEnum[]
  }

  /**
   * Textbook create
   */
  export type TextbookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * The data needed to create a Textbook.
     */
    data: XOR<TextbookCreateInput, TextbookUncheckedCreateInput>
  }

  /**
   * Textbook createMany
   */
  export type TextbookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Textbooks.
     */
    data: TextbookCreateManyInput | TextbookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Textbook createManyAndReturn
   */
  export type TextbookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * The data used to create many Textbooks.
     */
    data: TextbookCreateManyInput | TextbookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Textbook update
   */
  export type TextbookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * The data needed to update a Textbook.
     */
    data: XOR<TextbookUpdateInput, TextbookUncheckedUpdateInput>
    /**
     * Choose, which Textbook to update.
     */
    where: TextbookWhereUniqueInput
  }

  /**
   * Textbook updateMany
   */
  export type TextbookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Textbooks.
     */
    data: XOR<TextbookUpdateManyMutationInput, TextbookUncheckedUpdateManyInput>
    /**
     * Filter which Textbooks to update
     */
    where?: TextbookWhereInput
    /**
     * Limit how many Textbooks to update.
     */
    limit?: number
  }

  /**
   * Textbook updateManyAndReturn
   */
  export type TextbookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * The data used to update Textbooks.
     */
    data: XOR<TextbookUpdateManyMutationInput, TextbookUncheckedUpdateManyInput>
    /**
     * Filter which Textbooks to update
     */
    where?: TextbookWhereInput
    /**
     * Limit how many Textbooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Textbook upsert
   */
  export type TextbookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * The filter to search for the Textbook to update in case it exists.
     */
    where: TextbookWhereUniqueInput
    /**
     * In case the Textbook found by the `where` argument doesn't exist, create a new Textbook with this data.
     */
    create: XOR<TextbookCreateInput, TextbookUncheckedCreateInput>
    /**
     * In case the Textbook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextbookUpdateInput, TextbookUncheckedUpdateInput>
  }

  /**
   * Textbook delete
   */
  export type TextbookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
    /**
     * Filter which Textbook to delete.
     */
    where: TextbookWhereUniqueInput
  }

  /**
   * Textbook deleteMany
   */
  export type TextbookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Textbooks to delete
     */
    where?: TextbookWhereInput
    /**
     * Limit how many Textbooks to delete.
     */
    limit?: number
  }

  /**
   * Textbook.syllabus
   */
  export type Textbook$syllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    where?: SyllabusWhereInput
  }

  /**
   * Textbook.units
   */
  export type Textbook$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    where?: TextbookUnitWhereInput
    orderBy?: TextbookUnitOrderByWithRelationInput | TextbookUnitOrderByWithRelationInput[]
    cursor?: TextbookUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextbookUnitScalarFieldEnum | TextbookUnitScalarFieldEnum[]
  }

  /**
   * Textbook.generation_jobs
   */
  export type Textbook$generation_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    where?: TextbookGenerationJobWhereInput
    orderBy?: TextbookGenerationJobOrderByWithRelationInput | TextbookGenerationJobOrderByWithRelationInput[]
    cursor?: TextbookGenerationJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextbookGenerationJobScalarFieldEnum | TextbookGenerationJobScalarFieldEnum[]
  }

  /**
   * Textbook.enrollments
   */
  export type Textbook$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnrollment
     */
    select?: UserEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEnrollment
     */
    omit?: UserEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEnrollmentInclude<ExtArgs> | null
    where?: UserEnrollmentWhereInput
    orderBy?: UserEnrollmentOrderByWithRelationInput | UserEnrollmentOrderByWithRelationInput[]
    cursor?: UserEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEnrollmentScalarFieldEnum | UserEnrollmentScalarFieldEnum[]
  }

  /**
   * Textbook without action
   */
  export type TextbookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Textbook
     */
    select?: TextbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Textbook
     */
    omit?: TextbookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookInclude<ExtArgs> | null
  }


  /**
   * Model TextbookUnit
   */

  export type AggregateTextbookUnit = {
    _count: TextbookUnitCountAggregateOutputType | null
    _avg: TextbookUnitAvgAggregateOutputType | null
    _sum: TextbookUnitSumAggregateOutputType | null
    _min: TextbookUnitMinAggregateOutputType | null
    _max: TextbookUnitMaxAggregateOutputType | null
  }

  export type TextbookUnitAvgAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    order: number | null
  }

  export type TextbookUnitSumAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    order: number | null
  }

  export type TextbookUnitMinAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    order: number | null
    title: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TextbookUnitMaxAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    order: number | null
    title: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TextbookUnitCountAggregateOutputType = {
    id: number
    textbook_id: number
    order: number
    title: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TextbookUnitAvgAggregateInputType = {
    id?: true
    textbook_id?: true
    order?: true
  }

  export type TextbookUnitSumAggregateInputType = {
    id?: true
    textbook_id?: true
    order?: true
  }

  export type TextbookUnitMinAggregateInputType = {
    id?: true
    textbook_id?: true
    order?: true
    title?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type TextbookUnitMaxAggregateInputType = {
    id?: true
    textbook_id?: true
    order?: true
    title?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type TextbookUnitCountAggregateInputType = {
    id?: true
    textbook_id?: true
    order?: true
    title?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TextbookUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookUnit to aggregate.
     */
    where?: TextbookUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookUnits to fetch.
     */
    orderBy?: TextbookUnitOrderByWithRelationInput | TextbookUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextbookUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextbookUnits
    **/
    _count?: true | TextbookUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextbookUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextbookUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextbookUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextbookUnitMaxAggregateInputType
  }

  export type GetTextbookUnitAggregateType<T extends TextbookUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateTextbookUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextbookUnit[P]>
      : GetScalarType<T[P], AggregateTextbookUnit[P]>
  }




  export type TextbookUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookUnitWhereInput
    orderBy?: TextbookUnitOrderByWithAggregationInput | TextbookUnitOrderByWithAggregationInput[]
    by: TextbookUnitScalarFieldEnum[] | TextbookUnitScalarFieldEnum
    having?: TextbookUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextbookUnitCountAggregateInputType | true
    _avg?: TextbookUnitAvgAggregateInputType
    _sum?: TextbookUnitSumAggregateInputType
    _min?: TextbookUnitMinAggregateInputType
    _max?: TextbookUnitMaxAggregateInputType
  }

  export type TextbookUnitGroupByOutputType = {
    id: number
    textbook_id: number
    order: number
    title: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: TextbookUnitCountAggregateOutputType | null
    _avg: TextbookUnitAvgAggregateOutputType | null
    _sum: TextbookUnitSumAggregateOutputType | null
    _min: TextbookUnitMinAggregateOutputType | null
    _max: TextbookUnitMaxAggregateOutputType | null
  }

  type GetTextbookUnitGroupByPayload<T extends TextbookUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextbookUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextbookUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextbookUnitGroupByOutputType[P]>
            : GetScalarType<T[P], TextbookUnitGroupByOutputType[P]>
        }
      >
    >


  export type TextbookUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    textbook_id?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
    chapters?: boolean | TextbookUnit$chaptersArgs<ExtArgs>
    _count?: boolean | TextbookUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookUnit"]>

  export type TextbookUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    textbook_id?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookUnit"]>

  export type TextbookUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    textbook_id?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookUnit"]>

  export type TextbookUnitSelectScalar = {
    id?: boolean
    textbook_id?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TextbookUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "textbook_id" | "order" | "title" | "description" | "created_at" | "updated_at", ExtArgs["result"]["textbookUnit"]>
  export type TextbookUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
    chapters?: boolean | TextbookUnit$chaptersArgs<ExtArgs>
    _count?: boolean | TextbookUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TextbookUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }
  export type TextbookUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }

  export type $TextbookUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextbookUnit"
    objects: {
      textbook: Prisma.$TextbookPayload<ExtArgs>
      chapters: Prisma.$TextbookChapterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      textbook_id: number
      order: number
      title: string
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["textbookUnit"]>
    composites: {}
  }

  type TextbookUnitGetPayload<S extends boolean | null | undefined | TextbookUnitDefaultArgs> = $Result.GetResult<Prisma.$TextbookUnitPayload, S>

  type TextbookUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextbookUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextbookUnitCountAggregateInputType | true
    }

  export interface TextbookUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextbookUnit'], meta: { name: 'TextbookUnit' } }
    /**
     * Find zero or one TextbookUnit that matches the filter.
     * @param {TextbookUnitFindUniqueArgs} args - Arguments to find a TextbookUnit
     * @example
     * // Get one TextbookUnit
     * const textbookUnit = await prisma.textbookUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextbookUnitFindUniqueArgs>(args: SelectSubset<T, TextbookUnitFindUniqueArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextbookUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextbookUnitFindUniqueOrThrowArgs} args - Arguments to find a TextbookUnit
     * @example
     * // Get one TextbookUnit
     * const textbookUnit = await prisma.textbookUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextbookUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, TextbookUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitFindFirstArgs} args - Arguments to find a TextbookUnit
     * @example
     * // Get one TextbookUnit
     * const textbookUnit = await prisma.textbookUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextbookUnitFindFirstArgs>(args?: SelectSubset<T, TextbookUnitFindFirstArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitFindFirstOrThrowArgs} args - Arguments to find a TextbookUnit
     * @example
     * // Get one TextbookUnit
     * const textbookUnit = await prisma.textbookUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextbookUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, TextbookUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextbookUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextbookUnits
     * const textbookUnits = await prisma.textbookUnit.findMany()
     * 
     * // Get first 10 TextbookUnits
     * const textbookUnits = await prisma.textbookUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textbookUnitWithIdOnly = await prisma.textbookUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextbookUnitFindManyArgs>(args?: SelectSubset<T, TextbookUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextbookUnit.
     * @param {TextbookUnitCreateArgs} args - Arguments to create a TextbookUnit.
     * @example
     * // Create one TextbookUnit
     * const TextbookUnit = await prisma.textbookUnit.create({
     *   data: {
     *     // ... data to create a TextbookUnit
     *   }
     * })
     * 
     */
    create<T extends TextbookUnitCreateArgs>(args: SelectSubset<T, TextbookUnitCreateArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextbookUnits.
     * @param {TextbookUnitCreateManyArgs} args - Arguments to create many TextbookUnits.
     * @example
     * // Create many TextbookUnits
     * const textbookUnit = await prisma.textbookUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextbookUnitCreateManyArgs>(args?: SelectSubset<T, TextbookUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TextbookUnits and returns the data saved in the database.
     * @param {TextbookUnitCreateManyAndReturnArgs} args - Arguments to create many TextbookUnits.
     * @example
     * // Create many TextbookUnits
     * const textbookUnit = await prisma.textbookUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TextbookUnits and only return the `id`
     * const textbookUnitWithIdOnly = await prisma.textbookUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextbookUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, TextbookUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TextbookUnit.
     * @param {TextbookUnitDeleteArgs} args - Arguments to delete one TextbookUnit.
     * @example
     * // Delete one TextbookUnit
     * const TextbookUnit = await prisma.textbookUnit.delete({
     *   where: {
     *     // ... filter to delete one TextbookUnit
     *   }
     * })
     * 
     */
    delete<T extends TextbookUnitDeleteArgs>(args: SelectSubset<T, TextbookUnitDeleteArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextbookUnit.
     * @param {TextbookUnitUpdateArgs} args - Arguments to update one TextbookUnit.
     * @example
     * // Update one TextbookUnit
     * const textbookUnit = await prisma.textbookUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextbookUnitUpdateArgs>(args: SelectSubset<T, TextbookUnitUpdateArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextbookUnits.
     * @param {TextbookUnitDeleteManyArgs} args - Arguments to filter TextbookUnits to delete.
     * @example
     * // Delete a few TextbookUnits
     * const { count } = await prisma.textbookUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextbookUnitDeleteManyArgs>(args?: SelectSubset<T, TextbookUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextbookUnits
     * const textbookUnit = await prisma.textbookUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextbookUnitUpdateManyArgs>(args: SelectSubset<T, TextbookUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookUnits and returns the data updated in the database.
     * @param {TextbookUnitUpdateManyAndReturnArgs} args - Arguments to update many TextbookUnits.
     * @example
     * // Update many TextbookUnits
     * const textbookUnit = await prisma.textbookUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TextbookUnits and only return the `id`
     * const textbookUnitWithIdOnly = await prisma.textbookUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextbookUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, TextbookUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TextbookUnit.
     * @param {TextbookUnitUpsertArgs} args - Arguments to update or create a TextbookUnit.
     * @example
     * // Update or create a TextbookUnit
     * const textbookUnit = await prisma.textbookUnit.upsert({
     *   create: {
     *     // ... data to create a TextbookUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextbookUnit we want to update
     *   }
     * })
     */
    upsert<T extends TextbookUnitUpsertArgs>(args: SelectSubset<T, TextbookUnitUpsertArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TextbookUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitCountArgs} args - Arguments to filter TextbookUnits to count.
     * @example
     * // Count the number of TextbookUnits
     * const count = await prisma.textbookUnit.count({
     *   where: {
     *     // ... the filter for the TextbookUnits we want to count
     *   }
     * })
    **/
    count<T extends TextbookUnitCountArgs>(
      args?: Subset<T, TextbookUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextbookUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextbookUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextbookUnitAggregateArgs>(args: Subset<T, TextbookUnitAggregateArgs>): Prisma.PrismaPromise<GetTextbookUnitAggregateType<T>>

    /**
     * Group by TextbookUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextbookUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextbookUnitGroupByArgs['orderBy'] }
        : { orderBy?: TextbookUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextbookUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextbookUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextbookUnit model
   */
  readonly fields: TextbookUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextbookUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextbookUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    textbook<T extends TextbookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TextbookDefaultArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapters<T extends TextbookUnit$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, TextbookUnit$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextbookUnit model
   */
  interface TextbookUnitFieldRefs {
    readonly id: FieldRef<"TextbookUnit", 'Int'>
    readonly textbook_id: FieldRef<"TextbookUnit", 'Int'>
    readonly order: FieldRef<"TextbookUnit", 'Int'>
    readonly title: FieldRef<"TextbookUnit", 'String'>
    readonly description: FieldRef<"TextbookUnit", 'String'>
    readonly created_at: FieldRef<"TextbookUnit", 'DateTime'>
    readonly updated_at: FieldRef<"TextbookUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextbookUnit findUnique
   */
  export type TextbookUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * Filter, which TextbookUnit to fetch.
     */
    where: TextbookUnitWhereUniqueInput
  }

  /**
   * TextbookUnit findUniqueOrThrow
   */
  export type TextbookUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * Filter, which TextbookUnit to fetch.
     */
    where: TextbookUnitWhereUniqueInput
  }

  /**
   * TextbookUnit findFirst
   */
  export type TextbookUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * Filter, which TextbookUnit to fetch.
     */
    where?: TextbookUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookUnits to fetch.
     */
    orderBy?: TextbookUnitOrderByWithRelationInput | TextbookUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookUnits.
     */
    cursor?: TextbookUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookUnits.
     */
    distinct?: TextbookUnitScalarFieldEnum | TextbookUnitScalarFieldEnum[]
  }

  /**
   * TextbookUnit findFirstOrThrow
   */
  export type TextbookUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * Filter, which TextbookUnit to fetch.
     */
    where?: TextbookUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookUnits to fetch.
     */
    orderBy?: TextbookUnitOrderByWithRelationInput | TextbookUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookUnits.
     */
    cursor?: TextbookUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookUnits.
     */
    distinct?: TextbookUnitScalarFieldEnum | TextbookUnitScalarFieldEnum[]
  }

  /**
   * TextbookUnit findMany
   */
  export type TextbookUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * Filter, which TextbookUnits to fetch.
     */
    where?: TextbookUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookUnits to fetch.
     */
    orderBy?: TextbookUnitOrderByWithRelationInput | TextbookUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextbookUnits.
     */
    cursor?: TextbookUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookUnits.
     */
    skip?: number
    distinct?: TextbookUnitScalarFieldEnum | TextbookUnitScalarFieldEnum[]
  }

  /**
   * TextbookUnit create
   */
  export type TextbookUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a TextbookUnit.
     */
    data: XOR<TextbookUnitCreateInput, TextbookUnitUncheckedCreateInput>
  }

  /**
   * TextbookUnit createMany
   */
  export type TextbookUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextbookUnits.
     */
    data: TextbookUnitCreateManyInput | TextbookUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TextbookUnit createManyAndReturn
   */
  export type TextbookUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * The data used to create many TextbookUnits.
     */
    data: TextbookUnitCreateManyInput | TextbookUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookUnit update
   */
  export type TextbookUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a TextbookUnit.
     */
    data: XOR<TextbookUnitUpdateInput, TextbookUnitUncheckedUpdateInput>
    /**
     * Choose, which TextbookUnit to update.
     */
    where: TextbookUnitWhereUniqueInput
  }

  /**
   * TextbookUnit updateMany
   */
  export type TextbookUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextbookUnits.
     */
    data: XOR<TextbookUnitUpdateManyMutationInput, TextbookUnitUncheckedUpdateManyInput>
    /**
     * Filter which TextbookUnits to update
     */
    where?: TextbookUnitWhereInput
    /**
     * Limit how many TextbookUnits to update.
     */
    limit?: number
  }

  /**
   * TextbookUnit updateManyAndReturn
   */
  export type TextbookUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * The data used to update TextbookUnits.
     */
    data: XOR<TextbookUnitUpdateManyMutationInput, TextbookUnitUncheckedUpdateManyInput>
    /**
     * Filter which TextbookUnits to update
     */
    where?: TextbookUnitWhereInput
    /**
     * Limit how many TextbookUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookUnit upsert
   */
  export type TextbookUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the TextbookUnit to update in case it exists.
     */
    where: TextbookUnitWhereUniqueInput
    /**
     * In case the TextbookUnit found by the `where` argument doesn't exist, create a new TextbookUnit with this data.
     */
    create: XOR<TextbookUnitCreateInput, TextbookUnitUncheckedCreateInput>
    /**
     * In case the TextbookUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextbookUnitUpdateInput, TextbookUnitUncheckedUpdateInput>
  }

  /**
   * TextbookUnit delete
   */
  export type TextbookUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
    /**
     * Filter which TextbookUnit to delete.
     */
    where: TextbookUnitWhereUniqueInput
  }

  /**
   * TextbookUnit deleteMany
   */
  export type TextbookUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookUnits to delete
     */
    where?: TextbookUnitWhereInput
    /**
     * Limit how many TextbookUnits to delete.
     */
    limit?: number
  }

  /**
   * TextbookUnit.chapters
   */
  export type TextbookUnit$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    where?: TextbookChapterWhereInput
    orderBy?: TextbookChapterOrderByWithRelationInput | TextbookChapterOrderByWithRelationInput[]
    cursor?: TextbookChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextbookChapterScalarFieldEnum | TextbookChapterScalarFieldEnum[]
  }

  /**
   * TextbookUnit without action
   */
  export type TextbookUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookUnit
     */
    select?: TextbookUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookUnit
     */
    omit?: TextbookUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookUnitInclude<ExtArgs> | null
  }


  /**
   * Model TextbookChapter
   */

  export type AggregateTextbookChapter = {
    _count: TextbookChapterCountAggregateOutputType | null
    _avg: TextbookChapterAvgAggregateOutputType | null
    _sum: TextbookChapterSumAggregateOutputType | null
    _min: TextbookChapterMinAggregateOutputType | null
    _max: TextbookChapterMaxAggregateOutputType | null
  }

  export type TextbookChapterAvgAggregateOutputType = {
    id: number | null
    unit_id: number | null
    order: number | null
    generation_time_ms: number | null
  }

  export type TextbookChapterSumAggregateOutputType = {
    id: number | null
    unit_id: number | null
    order: number | null
    generation_time_ms: number | null
  }

  export type TextbookChapterMinAggregateOutputType = {
    id: number | null
    unit_id: number | null
    chapter_number: string | null
    title: string | null
    order: number | null
    raw_syllabus_text: string | null
    content: string | null
    content_markdown: string | null
    content_html: string | null
    summary: string | null
    pdf_url: string | null
    generated_at: Date | null
    neet_relevant: boolean | null
    jee_relevant: boolean | null
    cuet_relevant: boolean | null
    model_used: string | null
    generation_time_ms: number | null
    status: $Enums.ChapterGenStatus | null
    generation_error: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TextbookChapterMaxAggregateOutputType = {
    id: number | null
    unit_id: number | null
    chapter_number: string | null
    title: string | null
    order: number | null
    raw_syllabus_text: string | null
    content: string | null
    content_markdown: string | null
    content_html: string | null
    summary: string | null
    pdf_url: string | null
    generated_at: Date | null
    neet_relevant: boolean | null
    jee_relevant: boolean | null
    cuet_relevant: boolean | null
    model_used: string | null
    generation_time_ms: number | null
    status: $Enums.ChapterGenStatus | null
    generation_error: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TextbookChapterCountAggregateOutputType = {
    id: number
    unit_id: number
    chapter_number: number
    title: number
    order: number
    raw_syllabus_text: number
    subtopics: number
    content: number
    content_markdown: number
    content_html: number
    summary: number
    learning_outcomes: number
    key_takeaways: number
    pdf_url: number
    generated_at: number
    neet_relevant: number
    jee_relevant: number
    cuet_relevant: number
    exam_highlights: number
    mcq_questions: number
    short_questions: number
    long_questions: number
    model_used: number
    tokens_used: number
    generation_time_ms: number
    status: number
    generation_error: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TextbookChapterAvgAggregateInputType = {
    id?: true
    unit_id?: true
    order?: true
    generation_time_ms?: true
  }

  export type TextbookChapterSumAggregateInputType = {
    id?: true
    unit_id?: true
    order?: true
    generation_time_ms?: true
  }

  export type TextbookChapterMinAggregateInputType = {
    id?: true
    unit_id?: true
    chapter_number?: true
    title?: true
    order?: true
    raw_syllabus_text?: true
    content?: true
    content_markdown?: true
    content_html?: true
    summary?: true
    pdf_url?: true
    generated_at?: true
    neet_relevant?: true
    jee_relevant?: true
    cuet_relevant?: true
    model_used?: true
    generation_time_ms?: true
    status?: true
    generation_error?: true
    created_at?: true
    updated_at?: true
  }

  export type TextbookChapterMaxAggregateInputType = {
    id?: true
    unit_id?: true
    chapter_number?: true
    title?: true
    order?: true
    raw_syllabus_text?: true
    content?: true
    content_markdown?: true
    content_html?: true
    summary?: true
    pdf_url?: true
    generated_at?: true
    neet_relevant?: true
    jee_relevant?: true
    cuet_relevant?: true
    model_used?: true
    generation_time_ms?: true
    status?: true
    generation_error?: true
    created_at?: true
    updated_at?: true
  }

  export type TextbookChapterCountAggregateInputType = {
    id?: true
    unit_id?: true
    chapter_number?: true
    title?: true
    order?: true
    raw_syllabus_text?: true
    subtopics?: true
    content?: true
    content_markdown?: true
    content_html?: true
    summary?: true
    learning_outcomes?: true
    key_takeaways?: true
    pdf_url?: true
    generated_at?: true
    neet_relevant?: true
    jee_relevant?: true
    cuet_relevant?: true
    exam_highlights?: true
    mcq_questions?: true
    short_questions?: true
    long_questions?: true
    model_used?: true
    tokens_used?: true
    generation_time_ms?: true
    status?: true
    generation_error?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TextbookChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookChapter to aggregate.
     */
    where?: TextbookChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookChapters to fetch.
     */
    orderBy?: TextbookChapterOrderByWithRelationInput | TextbookChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextbookChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextbookChapters
    **/
    _count?: true | TextbookChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextbookChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextbookChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextbookChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextbookChapterMaxAggregateInputType
  }

  export type GetTextbookChapterAggregateType<T extends TextbookChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateTextbookChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextbookChapter[P]>
      : GetScalarType<T[P], AggregateTextbookChapter[P]>
  }




  export type TextbookChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookChapterWhereInput
    orderBy?: TextbookChapterOrderByWithAggregationInput | TextbookChapterOrderByWithAggregationInput[]
    by: TextbookChapterScalarFieldEnum[] | TextbookChapterScalarFieldEnum
    having?: TextbookChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextbookChapterCountAggregateInputType | true
    _avg?: TextbookChapterAvgAggregateInputType
    _sum?: TextbookChapterSumAggregateInputType
    _min?: TextbookChapterMinAggregateInputType
    _max?: TextbookChapterMaxAggregateInputType
  }

  export type TextbookChapterGroupByOutputType = {
    id: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text: string | null
    subtopics: JsonValue | null
    content: string | null
    content_markdown: string | null
    content_html: string | null
    summary: string | null
    learning_outcomes: JsonValue | null
    key_takeaways: JsonValue | null
    pdf_url: string | null
    generated_at: Date | null
    neet_relevant: boolean
    jee_relevant: boolean
    cuet_relevant: boolean
    exam_highlights: JsonValue | null
    mcq_questions: JsonValue | null
    short_questions: JsonValue | null
    long_questions: JsonValue | null
    model_used: string | null
    tokens_used: JsonValue | null
    generation_time_ms: number | null
    status: $Enums.ChapterGenStatus
    generation_error: string | null
    created_at: Date
    updated_at: Date
    _count: TextbookChapterCountAggregateOutputType | null
    _avg: TextbookChapterAvgAggregateOutputType | null
    _sum: TextbookChapterSumAggregateOutputType | null
    _min: TextbookChapterMinAggregateOutputType | null
    _max: TextbookChapterMaxAggregateOutputType | null
  }

  type GetTextbookChapterGroupByPayload<T extends TextbookChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextbookChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextbookChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextbookChapterGroupByOutputType[P]>
            : GetScalarType<T[P], TextbookChapterGroupByOutputType[P]>
        }
      >
    >


  export type TextbookChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    raw_syllabus_text?: boolean
    subtopics?: boolean
    content?: boolean
    content_markdown?: boolean
    content_html?: boolean
    summary?: boolean
    learning_outcomes?: boolean
    key_takeaways?: boolean
    pdf_url?: boolean
    generated_at?: boolean
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: boolean
    mcq_questions?: boolean
    short_questions?: boolean
    long_questions?: boolean
    model_used?: boolean
    tokens_used?: boolean
    generation_time_ms?: boolean
    status?: boolean
    generation_error?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | TextbookUnitDefaultArgs<ExtArgs>
    images?: boolean | TextbookChapter$imagesArgs<ExtArgs>
    _count?: boolean | TextbookChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookChapter"]>

  export type TextbookChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    raw_syllabus_text?: boolean
    subtopics?: boolean
    content?: boolean
    content_markdown?: boolean
    content_html?: boolean
    summary?: boolean
    learning_outcomes?: boolean
    key_takeaways?: boolean
    pdf_url?: boolean
    generated_at?: boolean
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: boolean
    mcq_questions?: boolean
    short_questions?: boolean
    long_questions?: boolean
    model_used?: boolean
    tokens_used?: boolean
    generation_time_ms?: boolean
    status?: boolean
    generation_error?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | TextbookUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookChapter"]>

  export type TextbookChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    raw_syllabus_text?: boolean
    subtopics?: boolean
    content?: boolean
    content_markdown?: boolean
    content_html?: boolean
    summary?: boolean
    learning_outcomes?: boolean
    key_takeaways?: boolean
    pdf_url?: boolean
    generated_at?: boolean
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: boolean
    mcq_questions?: boolean
    short_questions?: boolean
    long_questions?: boolean
    model_used?: boolean
    tokens_used?: boolean
    generation_time_ms?: boolean
    status?: boolean
    generation_error?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | TextbookUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookChapter"]>

  export type TextbookChapterSelectScalar = {
    id?: boolean
    unit_id?: boolean
    chapter_number?: boolean
    title?: boolean
    order?: boolean
    raw_syllabus_text?: boolean
    subtopics?: boolean
    content?: boolean
    content_markdown?: boolean
    content_html?: boolean
    summary?: boolean
    learning_outcomes?: boolean
    key_takeaways?: boolean
    pdf_url?: boolean
    generated_at?: boolean
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: boolean
    mcq_questions?: boolean
    short_questions?: boolean
    long_questions?: boolean
    model_used?: boolean
    tokens_used?: boolean
    generation_time_ms?: boolean
    status?: boolean
    generation_error?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TextbookChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "chapter_number" | "title" | "order" | "raw_syllabus_text" | "subtopics" | "content" | "content_markdown" | "content_html" | "summary" | "learning_outcomes" | "key_takeaways" | "pdf_url" | "generated_at" | "neet_relevant" | "jee_relevant" | "cuet_relevant" | "exam_highlights" | "mcq_questions" | "short_questions" | "long_questions" | "model_used" | "tokens_used" | "generation_time_ms" | "status" | "generation_error" | "created_at" | "updated_at", ExtArgs["result"]["textbookChapter"]>
  export type TextbookChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | TextbookUnitDefaultArgs<ExtArgs>
    images?: boolean | TextbookChapter$imagesArgs<ExtArgs>
    _count?: boolean | TextbookChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TextbookChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | TextbookUnitDefaultArgs<ExtArgs>
  }
  export type TextbookChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | TextbookUnitDefaultArgs<ExtArgs>
  }

  export type $TextbookChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextbookChapter"
    objects: {
      unit: Prisma.$TextbookUnitPayload<ExtArgs>
      images: Prisma.$TextbookImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      unit_id: number
      chapter_number: string
      title: string
      order: number
      raw_syllabus_text: string | null
      subtopics: Prisma.JsonValue | null
      content: string | null
      content_markdown: string | null
      content_html: string | null
      summary: string | null
      learning_outcomes: Prisma.JsonValue | null
      key_takeaways: Prisma.JsonValue | null
      pdf_url: string | null
      generated_at: Date | null
      neet_relevant: boolean
      jee_relevant: boolean
      cuet_relevant: boolean
      exam_highlights: Prisma.JsonValue | null
      mcq_questions: Prisma.JsonValue | null
      short_questions: Prisma.JsonValue | null
      long_questions: Prisma.JsonValue | null
      model_used: string | null
      tokens_used: Prisma.JsonValue | null
      generation_time_ms: number | null
      status: $Enums.ChapterGenStatus
      generation_error: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["textbookChapter"]>
    composites: {}
  }

  type TextbookChapterGetPayload<S extends boolean | null | undefined | TextbookChapterDefaultArgs> = $Result.GetResult<Prisma.$TextbookChapterPayload, S>

  type TextbookChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextbookChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextbookChapterCountAggregateInputType | true
    }

  export interface TextbookChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextbookChapter'], meta: { name: 'TextbookChapter' } }
    /**
     * Find zero or one TextbookChapter that matches the filter.
     * @param {TextbookChapterFindUniqueArgs} args - Arguments to find a TextbookChapter
     * @example
     * // Get one TextbookChapter
     * const textbookChapter = await prisma.textbookChapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextbookChapterFindUniqueArgs>(args: SelectSubset<T, TextbookChapterFindUniqueArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextbookChapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextbookChapterFindUniqueOrThrowArgs} args - Arguments to find a TextbookChapter
     * @example
     * // Get one TextbookChapter
     * const textbookChapter = await prisma.textbookChapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextbookChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, TextbookChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookChapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterFindFirstArgs} args - Arguments to find a TextbookChapter
     * @example
     * // Get one TextbookChapter
     * const textbookChapter = await prisma.textbookChapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextbookChapterFindFirstArgs>(args?: SelectSubset<T, TextbookChapterFindFirstArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookChapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterFindFirstOrThrowArgs} args - Arguments to find a TextbookChapter
     * @example
     * // Get one TextbookChapter
     * const textbookChapter = await prisma.textbookChapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextbookChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, TextbookChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextbookChapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextbookChapters
     * const textbookChapters = await prisma.textbookChapter.findMany()
     * 
     * // Get first 10 TextbookChapters
     * const textbookChapters = await prisma.textbookChapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textbookChapterWithIdOnly = await prisma.textbookChapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextbookChapterFindManyArgs>(args?: SelectSubset<T, TextbookChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextbookChapter.
     * @param {TextbookChapterCreateArgs} args - Arguments to create a TextbookChapter.
     * @example
     * // Create one TextbookChapter
     * const TextbookChapter = await prisma.textbookChapter.create({
     *   data: {
     *     // ... data to create a TextbookChapter
     *   }
     * })
     * 
     */
    create<T extends TextbookChapterCreateArgs>(args: SelectSubset<T, TextbookChapterCreateArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextbookChapters.
     * @param {TextbookChapterCreateManyArgs} args - Arguments to create many TextbookChapters.
     * @example
     * // Create many TextbookChapters
     * const textbookChapter = await prisma.textbookChapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextbookChapterCreateManyArgs>(args?: SelectSubset<T, TextbookChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TextbookChapters and returns the data saved in the database.
     * @param {TextbookChapterCreateManyAndReturnArgs} args - Arguments to create many TextbookChapters.
     * @example
     * // Create many TextbookChapters
     * const textbookChapter = await prisma.textbookChapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TextbookChapters and only return the `id`
     * const textbookChapterWithIdOnly = await prisma.textbookChapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextbookChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, TextbookChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TextbookChapter.
     * @param {TextbookChapterDeleteArgs} args - Arguments to delete one TextbookChapter.
     * @example
     * // Delete one TextbookChapter
     * const TextbookChapter = await prisma.textbookChapter.delete({
     *   where: {
     *     // ... filter to delete one TextbookChapter
     *   }
     * })
     * 
     */
    delete<T extends TextbookChapterDeleteArgs>(args: SelectSubset<T, TextbookChapterDeleteArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextbookChapter.
     * @param {TextbookChapterUpdateArgs} args - Arguments to update one TextbookChapter.
     * @example
     * // Update one TextbookChapter
     * const textbookChapter = await prisma.textbookChapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextbookChapterUpdateArgs>(args: SelectSubset<T, TextbookChapterUpdateArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextbookChapters.
     * @param {TextbookChapterDeleteManyArgs} args - Arguments to filter TextbookChapters to delete.
     * @example
     * // Delete a few TextbookChapters
     * const { count } = await prisma.textbookChapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextbookChapterDeleteManyArgs>(args?: SelectSubset<T, TextbookChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextbookChapters
     * const textbookChapter = await prisma.textbookChapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextbookChapterUpdateManyArgs>(args: SelectSubset<T, TextbookChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookChapters and returns the data updated in the database.
     * @param {TextbookChapterUpdateManyAndReturnArgs} args - Arguments to update many TextbookChapters.
     * @example
     * // Update many TextbookChapters
     * const textbookChapter = await prisma.textbookChapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TextbookChapters and only return the `id`
     * const textbookChapterWithIdOnly = await prisma.textbookChapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextbookChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, TextbookChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TextbookChapter.
     * @param {TextbookChapterUpsertArgs} args - Arguments to update or create a TextbookChapter.
     * @example
     * // Update or create a TextbookChapter
     * const textbookChapter = await prisma.textbookChapter.upsert({
     *   create: {
     *     // ... data to create a TextbookChapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextbookChapter we want to update
     *   }
     * })
     */
    upsert<T extends TextbookChapterUpsertArgs>(args: SelectSubset<T, TextbookChapterUpsertArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TextbookChapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterCountArgs} args - Arguments to filter TextbookChapters to count.
     * @example
     * // Count the number of TextbookChapters
     * const count = await prisma.textbookChapter.count({
     *   where: {
     *     // ... the filter for the TextbookChapters we want to count
     *   }
     * })
    **/
    count<T extends TextbookChapterCountArgs>(
      args?: Subset<T, TextbookChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextbookChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextbookChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextbookChapterAggregateArgs>(args: Subset<T, TextbookChapterAggregateArgs>): Prisma.PrismaPromise<GetTextbookChapterAggregateType<T>>

    /**
     * Group by TextbookChapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextbookChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextbookChapterGroupByArgs['orderBy'] }
        : { orderBy?: TextbookChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextbookChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextbookChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextbookChapter model
   */
  readonly fields: TextbookChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextbookChapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextbookChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends TextbookUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TextbookUnitDefaultArgs<ExtArgs>>): Prisma__TextbookUnitClient<$Result.GetResult<Prisma.$TextbookUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends TextbookChapter$imagesArgs<ExtArgs> = {}>(args?: Subset<T, TextbookChapter$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextbookChapter model
   */
  interface TextbookChapterFieldRefs {
    readonly id: FieldRef<"TextbookChapter", 'Int'>
    readonly unit_id: FieldRef<"TextbookChapter", 'Int'>
    readonly chapter_number: FieldRef<"TextbookChapter", 'String'>
    readonly title: FieldRef<"TextbookChapter", 'String'>
    readonly order: FieldRef<"TextbookChapter", 'Int'>
    readonly raw_syllabus_text: FieldRef<"TextbookChapter", 'String'>
    readonly subtopics: FieldRef<"TextbookChapter", 'Json'>
    readonly content: FieldRef<"TextbookChapter", 'String'>
    readonly content_markdown: FieldRef<"TextbookChapter", 'String'>
    readonly content_html: FieldRef<"TextbookChapter", 'String'>
    readonly summary: FieldRef<"TextbookChapter", 'String'>
    readonly learning_outcomes: FieldRef<"TextbookChapter", 'Json'>
    readonly key_takeaways: FieldRef<"TextbookChapter", 'Json'>
    readonly pdf_url: FieldRef<"TextbookChapter", 'String'>
    readonly generated_at: FieldRef<"TextbookChapter", 'DateTime'>
    readonly neet_relevant: FieldRef<"TextbookChapter", 'Boolean'>
    readonly jee_relevant: FieldRef<"TextbookChapter", 'Boolean'>
    readonly cuet_relevant: FieldRef<"TextbookChapter", 'Boolean'>
    readonly exam_highlights: FieldRef<"TextbookChapter", 'Json'>
    readonly mcq_questions: FieldRef<"TextbookChapter", 'Json'>
    readonly short_questions: FieldRef<"TextbookChapter", 'Json'>
    readonly long_questions: FieldRef<"TextbookChapter", 'Json'>
    readonly model_used: FieldRef<"TextbookChapter", 'String'>
    readonly tokens_used: FieldRef<"TextbookChapter", 'Json'>
    readonly generation_time_ms: FieldRef<"TextbookChapter", 'Int'>
    readonly status: FieldRef<"TextbookChapter", 'ChapterGenStatus'>
    readonly generation_error: FieldRef<"TextbookChapter", 'String'>
    readonly created_at: FieldRef<"TextbookChapter", 'DateTime'>
    readonly updated_at: FieldRef<"TextbookChapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextbookChapter findUnique
   */
  export type TextbookChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * Filter, which TextbookChapter to fetch.
     */
    where: TextbookChapterWhereUniqueInput
  }

  /**
   * TextbookChapter findUniqueOrThrow
   */
  export type TextbookChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * Filter, which TextbookChapter to fetch.
     */
    where: TextbookChapterWhereUniqueInput
  }

  /**
   * TextbookChapter findFirst
   */
  export type TextbookChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * Filter, which TextbookChapter to fetch.
     */
    where?: TextbookChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookChapters to fetch.
     */
    orderBy?: TextbookChapterOrderByWithRelationInput | TextbookChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookChapters.
     */
    cursor?: TextbookChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookChapters.
     */
    distinct?: TextbookChapterScalarFieldEnum | TextbookChapterScalarFieldEnum[]
  }

  /**
   * TextbookChapter findFirstOrThrow
   */
  export type TextbookChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * Filter, which TextbookChapter to fetch.
     */
    where?: TextbookChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookChapters to fetch.
     */
    orderBy?: TextbookChapterOrderByWithRelationInput | TextbookChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookChapters.
     */
    cursor?: TextbookChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookChapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookChapters.
     */
    distinct?: TextbookChapterScalarFieldEnum | TextbookChapterScalarFieldEnum[]
  }

  /**
   * TextbookChapter findMany
   */
  export type TextbookChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * Filter, which TextbookChapters to fetch.
     */
    where?: TextbookChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookChapters to fetch.
     */
    orderBy?: TextbookChapterOrderByWithRelationInput | TextbookChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextbookChapters.
     */
    cursor?: TextbookChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookChapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookChapters.
     */
    skip?: number
    distinct?: TextbookChapterScalarFieldEnum | TextbookChapterScalarFieldEnum[]
  }

  /**
   * TextbookChapter create
   */
  export type TextbookChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a TextbookChapter.
     */
    data: XOR<TextbookChapterCreateInput, TextbookChapterUncheckedCreateInput>
  }

  /**
   * TextbookChapter createMany
   */
  export type TextbookChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextbookChapters.
     */
    data: TextbookChapterCreateManyInput | TextbookChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TextbookChapter createManyAndReturn
   */
  export type TextbookChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * The data used to create many TextbookChapters.
     */
    data: TextbookChapterCreateManyInput | TextbookChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookChapter update
   */
  export type TextbookChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a TextbookChapter.
     */
    data: XOR<TextbookChapterUpdateInput, TextbookChapterUncheckedUpdateInput>
    /**
     * Choose, which TextbookChapter to update.
     */
    where: TextbookChapterWhereUniqueInput
  }

  /**
   * TextbookChapter updateMany
   */
  export type TextbookChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextbookChapters.
     */
    data: XOR<TextbookChapterUpdateManyMutationInput, TextbookChapterUncheckedUpdateManyInput>
    /**
     * Filter which TextbookChapters to update
     */
    where?: TextbookChapterWhereInput
    /**
     * Limit how many TextbookChapters to update.
     */
    limit?: number
  }

  /**
   * TextbookChapter updateManyAndReturn
   */
  export type TextbookChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * The data used to update TextbookChapters.
     */
    data: XOR<TextbookChapterUpdateManyMutationInput, TextbookChapterUncheckedUpdateManyInput>
    /**
     * Filter which TextbookChapters to update
     */
    where?: TextbookChapterWhereInput
    /**
     * Limit how many TextbookChapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookChapter upsert
   */
  export type TextbookChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the TextbookChapter to update in case it exists.
     */
    where: TextbookChapterWhereUniqueInput
    /**
     * In case the TextbookChapter found by the `where` argument doesn't exist, create a new TextbookChapter with this data.
     */
    create: XOR<TextbookChapterCreateInput, TextbookChapterUncheckedCreateInput>
    /**
     * In case the TextbookChapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextbookChapterUpdateInput, TextbookChapterUncheckedUpdateInput>
  }

  /**
   * TextbookChapter delete
   */
  export type TextbookChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
    /**
     * Filter which TextbookChapter to delete.
     */
    where: TextbookChapterWhereUniqueInput
  }

  /**
   * TextbookChapter deleteMany
   */
  export type TextbookChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookChapters to delete
     */
    where?: TextbookChapterWhereInput
    /**
     * Limit how many TextbookChapters to delete.
     */
    limit?: number
  }

  /**
   * TextbookChapter.images
   */
  export type TextbookChapter$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    where?: TextbookImageWhereInput
    orderBy?: TextbookImageOrderByWithRelationInput | TextbookImageOrderByWithRelationInput[]
    cursor?: TextbookImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TextbookImageScalarFieldEnum | TextbookImageScalarFieldEnum[]
  }

  /**
   * TextbookChapter without action
   */
  export type TextbookChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookChapter
     */
    select?: TextbookChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookChapter
     */
    omit?: TextbookChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookChapterInclude<ExtArgs> | null
  }


  /**
   * Model TextbookImage
   */

  export type AggregateTextbookImage = {
    _count: TextbookImageCountAggregateOutputType | null
    _avg: TextbookImageAvgAggregateOutputType | null
    _sum: TextbookImageSumAggregateOutputType | null
    _min: TextbookImageMinAggregateOutputType | null
    _max: TextbookImageMaxAggregateOutputType | null
  }

  export type TextbookImageAvgAggregateOutputType = {
    id: number | null
    chapter_id: number | null
    order: number | null
    generation_time_ms: number | null
  }

  export type TextbookImageSumAggregateOutputType = {
    id: number | null
    chapter_id: number | null
    order: number | null
    generation_time_ms: number | null
  }

  export type TextbookImageMinAggregateOutputType = {
    id: number | null
    chapter_id: number | null
    type: $Enums.TextbookImageType | null
    prompt: string | null
    alt_text: string | null
    url: string | null
    image_url: string | null
    order: number | null
    placement: string | null
    caption: string | null
    status: $Enums.ImageGenStatus | null
    model_used: string | null
    generation_time_ms: number | null
    generated_at: Date | null
    created_at: Date | null
  }

  export type TextbookImageMaxAggregateOutputType = {
    id: number | null
    chapter_id: number | null
    type: $Enums.TextbookImageType | null
    prompt: string | null
    alt_text: string | null
    url: string | null
    image_url: string | null
    order: number | null
    placement: string | null
    caption: string | null
    status: $Enums.ImageGenStatus | null
    model_used: string | null
    generation_time_ms: number | null
    generated_at: Date | null
    created_at: Date | null
  }

  export type TextbookImageCountAggregateOutputType = {
    id: number
    chapter_id: number
    type: number
    prompt: number
    alt_text: number
    url: number
    image_url: number
    order: number
    placement: number
    caption: number
    status: number
    model_used: number
    generation_time_ms: number
    generated_at: number
    created_at: number
    _all: number
  }


  export type TextbookImageAvgAggregateInputType = {
    id?: true
    chapter_id?: true
    order?: true
    generation_time_ms?: true
  }

  export type TextbookImageSumAggregateInputType = {
    id?: true
    chapter_id?: true
    order?: true
    generation_time_ms?: true
  }

  export type TextbookImageMinAggregateInputType = {
    id?: true
    chapter_id?: true
    type?: true
    prompt?: true
    alt_text?: true
    url?: true
    image_url?: true
    order?: true
    placement?: true
    caption?: true
    status?: true
    model_used?: true
    generation_time_ms?: true
    generated_at?: true
    created_at?: true
  }

  export type TextbookImageMaxAggregateInputType = {
    id?: true
    chapter_id?: true
    type?: true
    prompt?: true
    alt_text?: true
    url?: true
    image_url?: true
    order?: true
    placement?: true
    caption?: true
    status?: true
    model_used?: true
    generation_time_ms?: true
    generated_at?: true
    created_at?: true
  }

  export type TextbookImageCountAggregateInputType = {
    id?: true
    chapter_id?: true
    type?: true
    prompt?: true
    alt_text?: true
    url?: true
    image_url?: true
    order?: true
    placement?: true
    caption?: true
    status?: true
    model_used?: true
    generation_time_ms?: true
    generated_at?: true
    created_at?: true
    _all?: true
  }

  export type TextbookImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookImage to aggregate.
     */
    where?: TextbookImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookImages to fetch.
     */
    orderBy?: TextbookImageOrderByWithRelationInput | TextbookImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextbookImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextbookImages
    **/
    _count?: true | TextbookImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextbookImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextbookImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextbookImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextbookImageMaxAggregateInputType
  }

  export type GetTextbookImageAggregateType<T extends TextbookImageAggregateArgs> = {
        [P in keyof T & keyof AggregateTextbookImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextbookImage[P]>
      : GetScalarType<T[P], AggregateTextbookImage[P]>
  }




  export type TextbookImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookImageWhereInput
    orderBy?: TextbookImageOrderByWithAggregationInput | TextbookImageOrderByWithAggregationInput[]
    by: TextbookImageScalarFieldEnum[] | TextbookImageScalarFieldEnum
    having?: TextbookImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextbookImageCountAggregateInputType | true
    _avg?: TextbookImageAvgAggregateInputType
    _sum?: TextbookImageSumAggregateInputType
    _min?: TextbookImageMinAggregateInputType
    _max?: TextbookImageMaxAggregateInputType
  }

  export type TextbookImageGroupByOutputType = {
    id: number
    chapter_id: number
    type: $Enums.TextbookImageType
    prompt: string | null
    alt_text: string | null
    url: string | null
    image_url: string | null
    order: number
    placement: string | null
    caption: string | null
    status: $Enums.ImageGenStatus
    model_used: string | null
    generation_time_ms: number | null
    generated_at: Date | null
    created_at: Date
    _count: TextbookImageCountAggregateOutputType | null
    _avg: TextbookImageAvgAggregateOutputType | null
    _sum: TextbookImageSumAggregateOutputType | null
    _min: TextbookImageMinAggregateOutputType | null
    _max: TextbookImageMaxAggregateOutputType | null
  }

  type GetTextbookImageGroupByPayload<T extends TextbookImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextbookImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextbookImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextbookImageGroupByOutputType[P]>
            : GetScalarType<T[P], TextbookImageGroupByOutputType[P]>
        }
      >
    >


  export type TextbookImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    type?: boolean
    prompt?: boolean
    alt_text?: boolean
    url?: boolean
    image_url?: boolean
    order?: boolean
    placement?: boolean
    caption?: boolean
    status?: boolean
    model_used?: boolean
    generation_time_ms?: boolean
    generated_at?: boolean
    created_at?: boolean
    chapter?: boolean | TextbookChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookImage"]>

  export type TextbookImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    type?: boolean
    prompt?: boolean
    alt_text?: boolean
    url?: boolean
    image_url?: boolean
    order?: boolean
    placement?: boolean
    caption?: boolean
    status?: boolean
    model_used?: boolean
    generation_time_ms?: boolean
    generated_at?: boolean
    created_at?: boolean
    chapter?: boolean | TextbookChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookImage"]>

  export type TextbookImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapter_id?: boolean
    type?: boolean
    prompt?: boolean
    alt_text?: boolean
    url?: boolean
    image_url?: boolean
    order?: boolean
    placement?: boolean
    caption?: boolean
    status?: boolean
    model_used?: boolean
    generation_time_ms?: boolean
    generated_at?: boolean
    created_at?: boolean
    chapter?: boolean | TextbookChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookImage"]>

  export type TextbookImageSelectScalar = {
    id?: boolean
    chapter_id?: boolean
    type?: boolean
    prompt?: boolean
    alt_text?: boolean
    url?: boolean
    image_url?: boolean
    order?: boolean
    placement?: boolean
    caption?: boolean
    status?: boolean
    model_used?: boolean
    generation_time_ms?: boolean
    generated_at?: boolean
    created_at?: boolean
  }

  export type TextbookImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapter_id" | "type" | "prompt" | "alt_text" | "url" | "image_url" | "order" | "placement" | "caption" | "status" | "model_used" | "generation_time_ms" | "generated_at" | "created_at", ExtArgs["result"]["textbookImage"]>
  export type TextbookImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | TextbookChapterDefaultArgs<ExtArgs>
  }
  export type TextbookImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | TextbookChapterDefaultArgs<ExtArgs>
  }
  export type TextbookImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | TextbookChapterDefaultArgs<ExtArgs>
  }

  export type $TextbookImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextbookImage"
    objects: {
      chapter: Prisma.$TextbookChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chapter_id: number
      type: $Enums.TextbookImageType
      prompt: string | null
      alt_text: string | null
      url: string | null
      image_url: string | null
      order: number
      placement: string | null
      caption: string | null
      status: $Enums.ImageGenStatus
      model_used: string | null
      generation_time_ms: number | null
      generated_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["textbookImage"]>
    composites: {}
  }

  type TextbookImageGetPayload<S extends boolean | null | undefined | TextbookImageDefaultArgs> = $Result.GetResult<Prisma.$TextbookImagePayload, S>

  type TextbookImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextbookImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextbookImageCountAggregateInputType | true
    }

  export interface TextbookImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextbookImage'], meta: { name: 'TextbookImage' } }
    /**
     * Find zero or one TextbookImage that matches the filter.
     * @param {TextbookImageFindUniqueArgs} args - Arguments to find a TextbookImage
     * @example
     * // Get one TextbookImage
     * const textbookImage = await prisma.textbookImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextbookImageFindUniqueArgs>(args: SelectSubset<T, TextbookImageFindUniqueArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextbookImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextbookImageFindUniqueOrThrowArgs} args - Arguments to find a TextbookImage
     * @example
     * // Get one TextbookImage
     * const textbookImage = await prisma.textbookImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextbookImageFindUniqueOrThrowArgs>(args: SelectSubset<T, TextbookImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageFindFirstArgs} args - Arguments to find a TextbookImage
     * @example
     * // Get one TextbookImage
     * const textbookImage = await prisma.textbookImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextbookImageFindFirstArgs>(args?: SelectSubset<T, TextbookImageFindFirstArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageFindFirstOrThrowArgs} args - Arguments to find a TextbookImage
     * @example
     * // Get one TextbookImage
     * const textbookImage = await prisma.textbookImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextbookImageFindFirstOrThrowArgs>(args?: SelectSubset<T, TextbookImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextbookImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextbookImages
     * const textbookImages = await prisma.textbookImage.findMany()
     * 
     * // Get first 10 TextbookImages
     * const textbookImages = await prisma.textbookImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textbookImageWithIdOnly = await prisma.textbookImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextbookImageFindManyArgs>(args?: SelectSubset<T, TextbookImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextbookImage.
     * @param {TextbookImageCreateArgs} args - Arguments to create a TextbookImage.
     * @example
     * // Create one TextbookImage
     * const TextbookImage = await prisma.textbookImage.create({
     *   data: {
     *     // ... data to create a TextbookImage
     *   }
     * })
     * 
     */
    create<T extends TextbookImageCreateArgs>(args: SelectSubset<T, TextbookImageCreateArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextbookImages.
     * @param {TextbookImageCreateManyArgs} args - Arguments to create many TextbookImages.
     * @example
     * // Create many TextbookImages
     * const textbookImage = await prisma.textbookImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextbookImageCreateManyArgs>(args?: SelectSubset<T, TextbookImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TextbookImages and returns the data saved in the database.
     * @param {TextbookImageCreateManyAndReturnArgs} args - Arguments to create many TextbookImages.
     * @example
     * // Create many TextbookImages
     * const textbookImage = await prisma.textbookImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TextbookImages and only return the `id`
     * const textbookImageWithIdOnly = await prisma.textbookImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextbookImageCreateManyAndReturnArgs>(args?: SelectSubset<T, TextbookImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TextbookImage.
     * @param {TextbookImageDeleteArgs} args - Arguments to delete one TextbookImage.
     * @example
     * // Delete one TextbookImage
     * const TextbookImage = await prisma.textbookImage.delete({
     *   where: {
     *     // ... filter to delete one TextbookImage
     *   }
     * })
     * 
     */
    delete<T extends TextbookImageDeleteArgs>(args: SelectSubset<T, TextbookImageDeleteArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextbookImage.
     * @param {TextbookImageUpdateArgs} args - Arguments to update one TextbookImage.
     * @example
     * // Update one TextbookImage
     * const textbookImage = await prisma.textbookImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextbookImageUpdateArgs>(args: SelectSubset<T, TextbookImageUpdateArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextbookImages.
     * @param {TextbookImageDeleteManyArgs} args - Arguments to filter TextbookImages to delete.
     * @example
     * // Delete a few TextbookImages
     * const { count } = await prisma.textbookImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextbookImageDeleteManyArgs>(args?: SelectSubset<T, TextbookImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextbookImages
     * const textbookImage = await prisma.textbookImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextbookImageUpdateManyArgs>(args: SelectSubset<T, TextbookImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookImages and returns the data updated in the database.
     * @param {TextbookImageUpdateManyAndReturnArgs} args - Arguments to update many TextbookImages.
     * @example
     * // Update many TextbookImages
     * const textbookImage = await prisma.textbookImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TextbookImages and only return the `id`
     * const textbookImageWithIdOnly = await prisma.textbookImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextbookImageUpdateManyAndReturnArgs>(args: SelectSubset<T, TextbookImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TextbookImage.
     * @param {TextbookImageUpsertArgs} args - Arguments to update or create a TextbookImage.
     * @example
     * // Update or create a TextbookImage
     * const textbookImage = await prisma.textbookImage.upsert({
     *   create: {
     *     // ... data to create a TextbookImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextbookImage we want to update
     *   }
     * })
     */
    upsert<T extends TextbookImageUpsertArgs>(args: SelectSubset<T, TextbookImageUpsertArgs<ExtArgs>>): Prisma__TextbookImageClient<$Result.GetResult<Prisma.$TextbookImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TextbookImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageCountArgs} args - Arguments to filter TextbookImages to count.
     * @example
     * // Count the number of TextbookImages
     * const count = await prisma.textbookImage.count({
     *   where: {
     *     // ... the filter for the TextbookImages we want to count
     *   }
     * })
    **/
    count<T extends TextbookImageCountArgs>(
      args?: Subset<T, TextbookImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextbookImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextbookImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextbookImageAggregateArgs>(args: Subset<T, TextbookImageAggregateArgs>): Prisma.PrismaPromise<GetTextbookImageAggregateType<T>>

    /**
     * Group by TextbookImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextbookImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextbookImageGroupByArgs['orderBy'] }
        : { orderBy?: TextbookImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextbookImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextbookImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextbookImage model
   */
  readonly fields: TextbookImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextbookImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextbookImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends TextbookChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TextbookChapterDefaultArgs<ExtArgs>>): Prisma__TextbookChapterClient<$Result.GetResult<Prisma.$TextbookChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextbookImage model
   */
  interface TextbookImageFieldRefs {
    readonly id: FieldRef<"TextbookImage", 'Int'>
    readonly chapter_id: FieldRef<"TextbookImage", 'Int'>
    readonly type: FieldRef<"TextbookImage", 'TextbookImageType'>
    readonly prompt: FieldRef<"TextbookImage", 'String'>
    readonly alt_text: FieldRef<"TextbookImage", 'String'>
    readonly url: FieldRef<"TextbookImage", 'String'>
    readonly image_url: FieldRef<"TextbookImage", 'String'>
    readonly order: FieldRef<"TextbookImage", 'Int'>
    readonly placement: FieldRef<"TextbookImage", 'String'>
    readonly caption: FieldRef<"TextbookImage", 'String'>
    readonly status: FieldRef<"TextbookImage", 'ImageGenStatus'>
    readonly model_used: FieldRef<"TextbookImage", 'String'>
    readonly generation_time_ms: FieldRef<"TextbookImage", 'Int'>
    readonly generated_at: FieldRef<"TextbookImage", 'DateTime'>
    readonly created_at: FieldRef<"TextbookImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextbookImage findUnique
   */
  export type TextbookImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * Filter, which TextbookImage to fetch.
     */
    where: TextbookImageWhereUniqueInput
  }

  /**
   * TextbookImage findUniqueOrThrow
   */
  export type TextbookImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * Filter, which TextbookImage to fetch.
     */
    where: TextbookImageWhereUniqueInput
  }

  /**
   * TextbookImage findFirst
   */
  export type TextbookImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * Filter, which TextbookImage to fetch.
     */
    where?: TextbookImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookImages to fetch.
     */
    orderBy?: TextbookImageOrderByWithRelationInput | TextbookImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookImages.
     */
    cursor?: TextbookImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookImages.
     */
    distinct?: TextbookImageScalarFieldEnum | TextbookImageScalarFieldEnum[]
  }

  /**
   * TextbookImage findFirstOrThrow
   */
  export type TextbookImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * Filter, which TextbookImage to fetch.
     */
    where?: TextbookImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookImages to fetch.
     */
    orderBy?: TextbookImageOrderByWithRelationInput | TextbookImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookImages.
     */
    cursor?: TextbookImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookImages.
     */
    distinct?: TextbookImageScalarFieldEnum | TextbookImageScalarFieldEnum[]
  }

  /**
   * TextbookImage findMany
   */
  export type TextbookImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * Filter, which TextbookImages to fetch.
     */
    where?: TextbookImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookImages to fetch.
     */
    orderBy?: TextbookImageOrderByWithRelationInput | TextbookImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextbookImages.
     */
    cursor?: TextbookImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookImages.
     */
    skip?: number
    distinct?: TextbookImageScalarFieldEnum | TextbookImageScalarFieldEnum[]
  }

  /**
   * TextbookImage create
   */
  export type TextbookImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * The data needed to create a TextbookImage.
     */
    data: XOR<TextbookImageCreateInput, TextbookImageUncheckedCreateInput>
  }

  /**
   * TextbookImage createMany
   */
  export type TextbookImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextbookImages.
     */
    data: TextbookImageCreateManyInput | TextbookImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TextbookImage createManyAndReturn
   */
  export type TextbookImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * The data used to create many TextbookImages.
     */
    data: TextbookImageCreateManyInput | TextbookImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookImage update
   */
  export type TextbookImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * The data needed to update a TextbookImage.
     */
    data: XOR<TextbookImageUpdateInput, TextbookImageUncheckedUpdateInput>
    /**
     * Choose, which TextbookImage to update.
     */
    where: TextbookImageWhereUniqueInput
  }

  /**
   * TextbookImage updateMany
   */
  export type TextbookImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextbookImages.
     */
    data: XOR<TextbookImageUpdateManyMutationInput, TextbookImageUncheckedUpdateManyInput>
    /**
     * Filter which TextbookImages to update
     */
    where?: TextbookImageWhereInput
    /**
     * Limit how many TextbookImages to update.
     */
    limit?: number
  }

  /**
   * TextbookImage updateManyAndReturn
   */
  export type TextbookImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * The data used to update TextbookImages.
     */
    data: XOR<TextbookImageUpdateManyMutationInput, TextbookImageUncheckedUpdateManyInput>
    /**
     * Filter which TextbookImages to update
     */
    where?: TextbookImageWhereInput
    /**
     * Limit how many TextbookImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookImage upsert
   */
  export type TextbookImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * The filter to search for the TextbookImage to update in case it exists.
     */
    where: TextbookImageWhereUniqueInput
    /**
     * In case the TextbookImage found by the `where` argument doesn't exist, create a new TextbookImage with this data.
     */
    create: XOR<TextbookImageCreateInput, TextbookImageUncheckedCreateInput>
    /**
     * In case the TextbookImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextbookImageUpdateInput, TextbookImageUncheckedUpdateInput>
  }

  /**
   * TextbookImage delete
   */
  export type TextbookImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
    /**
     * Filter which TextbookImage to delete.
     */
    where: TextbookImageWhereUniqueInput
  }

  /**
   * TextbookImage deleteMany
   */
  export type TextbookImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookImages to delete
     */
    where?: TextbookImageWhereInput
    /**
     * Limit how many TextbookImages to delete.
     */
    limit?: number
  }

  /**
   * TextbookImage without action
   */
  export type TextbookImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookImage
     */
    select?: TextbookImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookImage
     */
    omit?: TextbookImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookImageInclude<ExtArgs> | null
  }


  /**
   * Model TextbookGenerationJob
   */

  export type AggregateTextbookGenerationJob = {
    _count: TextbookGenerationJobCountAggregateOutputType | null
    _avg: TextbookGenerationJobAvgAggregateOutputType | null
    _sum: TextbookGenerationJobSumAggregateOutputType | null
    _min: TextbookGenerationJobMinAggregateOutputType | null
    _max: TextbookGenerationJobMaxAggregateOutputType | null
  }

  export type TextbookGenerationJobAvgAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    target_id: number | null
    progress: number | null
    attempts: number | null
    max_attempts: number | null
  }

  export type TextbookGenerationJobSumAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    target_id: number | null
    progress: number | null
    attempts: number | null
    max_attempts: number | null
  }

  export type TextbookGenerationJobMinAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    job_type: $Enums.TextbookGenerationJobType | null
    status: $Enums.TextbookJobStatus | null
    target_id: number | null
    error_message: string | null
    progress: number | null
    started_at: Date | null
    completed_at: Date | null
    attempts: number | null
    max_attempts: number | null
    created_at: Date | null
  }

  export type TextbookGenerationJobMaxAggregateOutputType = {
    id: number | null
    textbook_id: number | null
    job_type: $Enums.TextbookGenerationJobType | null
    status: $Enums.TextbookJobStatus | null
    target_id: number | null
    error_message: string | null
    progress: number | null
    started_at: Date | null
    completed_at: Date | null
    attempts: number | null
    max_attempts: number | null
    created_at: Date | null
  }

  export type TextbookGenerationJobCountAggregateOutputType = {
    id: number
    textbook_id: number
    job_type: number
    status: number
    target_id: number
    input_data: number
    output_data: number
    error_message: number
    progress: number
    started_at: number
    completed_at: number
    attempts: number
    max_attempts: number
    created_at: number
    _all: number
  }


  export type TextbookGenerationJobAvgAggregateInputType = {
    id?: true
    textbook_id?: true
    target_id?: true
    progress?: true
    attempts?: true
    max_attempts?: true
  }

  export type TextbookGenerationJobSumAggregateInputType = {
    id?: true
    textbook_id?: true
    target_id?: true
    progress?: true
    attempts?: true
    max_attempts?: true
  }

  export type TextbookGenerationJobMinAggregateInputType = {
    id?: true
    textbook_id?: true
    job_type?: true
    status?: true
    target_id?: true
    error_message?: true
    progress?: true
    started_at?: true
    completed_at?: true
    attempts?: true
    max_attempts?: true
    created_at?: true
  }

  export type TextbookGenerationJobMaxAggregateInputType = {
    id?: true
    textbook_id?: true
    job_type?: true
    status?: true
    target_id?: true
    error_message?: true
    progress?: true
    started_at?: true
    completed_at?: true
    attempts?: true
    max_attempts?: true
    created_at?: true
  }

  export type TextbookGenerationJobCountAggregateInputType = {
    id?: true
    textbook_id?: true
    job_type?: true
    status?: true
    target_id?: true
    input_data?: true
    output_data?: true
    error_message?: true
    progress?: true
    started_at?: true
    completed_at?: true
    attempts?: true
    max_attempts?: true
    created_at?: true
    _all?: true
  }

  export type TextbookGenerationJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookGenerationJob to aggregate.
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookGenerationJobs to fetch.
     */
    orderBy?: TextbookGenerationJobOrderByWithRelationInput | TextbookGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TextbookGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TextbookGenerationJobs
    **/
    _count?: true | TextbookGenerationJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TextbookGenerationJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TextbookGenerationJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TextbookGenerationJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TextbookGenerationJobMaxAggregateInputType
  }

  export type GetTextbookGenerationJobAggregateType<T extends TextbookGenerationJobAggregateArgs> = {
        [P in keyof T & keyof AggregateTextbookGenerationJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTextbookGenerationJob[P]>
      : GetScalarType<T[P], AggregateTextbookGenerationJob[P]>
  }




  export type TextbookGenerationJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TextbookGenerationJobWhereInput
    orderBy?: TextbookGenerationJobOrderByWithAggregationInput | TextbookGenerationJobOrderByWithAggregationInput[]
    by: TextbookGenerationJobScalarFieldEnum[] | TextbookGenerationJobScalarFieldEnum
    having?: TextbookGenerationJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TextbookGenerationJobCountAggregateInputType | true
    _avg?: TextbookGenerationJobAvgAggregateInputType
    _sum?: TextbookGenerationJobSumAggregateInputType
    _min?: TextbookGenerationJobMinAggregateInputType
    _max?: TextbookGenerationJobMaxAggregateInputType
  }

  export type TextbookGenerationJobGroupByOutputType = {
    id: number
    textbook_id: number
    job_type: $Enums.TextbookGenerationJobType
    status: $Enums.TextbookJobStatus
    target_id: number | null
    input_data: JsonValue | null
    output_data: JsonValue | null
    error_message: string | null
    progress: number
    started_at: Date | null
    completed_at: Date | null
    attempts: number
    max_attempts: number
    created_at: Date
    _count: TextbookGenerationJobCountAggregateOutputType | null
    _avg: TextbookGenerationJobAvgAggregateOutputType | null
    _sum: TextbookGenerationJobSumAggregateOutputType | null
    _min: TextbookGenerationJobMinAggregateOutputType | null
    _max: TextbookGenerationJobMaxAggregateOutputType | null
  }

  type GetTextbookGenerationJobGroupByPayload<T extends TextbookGenerationJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TextbookGenerationJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TextbookGenerationJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TextbookGenerationJobGroupByOutputType[P]>
            : GetScalarType<T[P], TextbookGenerationJobGroupByOutputType[P]>
        }
      >
    >


  export type TextbookGenerationJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    textbook_id?: boolean
    job_type?: boolean
    status?: boolean
    target_id?: boolean
    input_data?: boolean
    output_data?: boolean
    error_message?: boolean
    progress?: boolean
    started_at?: boolean
    completed_at?: boolean
    attempts?: boolean
    max_attempts?: boolean
    created_at?: boolean
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookGenerationJob"]>

  export type TextbookGenerationJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    textbook_id?: boolean
    job_type?: boolean
    status?: boolean
    target_id?: boolean
    input_data?: boolean
    output_data?: boolean
    error_message?: boolean
    progress?: boolean
    started_at?: boolean
    completed_at?: boolean
    attempts?: boolean
    max_attempts?: boolean
    created_at?: boolean
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookGenerationJob"]>

  export type TextbookGenerationJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    textbook_id?: boolean
    job_type?: boolean
    status?: boolean
    target_id?: boolean
    input_data?: boolean
    output_data?: boolean
    error_message?: boolean
    progress?: boolean
    started_at?: boolean
    completed_at?: boolean
    attempts?: boolean
    max_attempts?: boolean
    created_at?: boolean
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["textbookGenerationJob"]>

  export type TextbookGenerationJobSelectScalar = {
    id?: boolean
    textbook_id?: boolean
    job_type?: boolean
    status?: boolean
    target_id?: boolean
    input_data?: boolean
    output_data?: boolean
    error_message?: boolean
    progress?: boolean
    started_at?: boolean
    completed_at?: boolean
    attempts?: boolean
    max_attempts?: boolean
    created_at?: boolean
  }

  export type TextbookGenerationJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "textbook_id" | "job_type" | "status" | "target_id" | "input_data" | "output_data" | "error_message" | "progress" | "started_at" | "completed_at" | "attempts" | "max_attempts" | "created_at", ExtArgs["result"]["textbookGenerationJob"]>
  export type TextbookGenerationJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }
  export type TextbookGenerationJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }
  export type TextbookGenerationJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    textbook?: boolean | TextbookDefaultArgs<ExtArgs>
  }

  export type $TextbookGenerationJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TextbookGenerationJob"
    objects: {
      textbook: Prisma.$TextbookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      textbook_id: number
      job_type: $Enums.TextbookGenerationJobType
      status: $Enums.TextbookJobStatus
      target_id: number | null
      input_data: Prisma.JsonValue | null
      output_data: Prisma.JsonValue | null
      error_message: string | null
      progress: number
      started_at: Date | null
      completed_at: Date | null
      attempts: number
      max_attempts: number
      created_at: Date
    }, ExtArgs["result"]["textbookGenerationJob"]>
    composites: {}
  }

  type TextbookGenerationJobGetPayload<S extends boolean | null | undefined | TextbookGenerationJobDefaultArgs> = $Result.GetResult<Prisma.$TextbookGenerationJobPayload, S>

  type TextbookGenerationJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TextbookGenerationJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TextbookGenerationJobCountAggregateInputType | true
    }

  export interface TextbookGenerationJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TextbookGenerationJob'], meta: { name: 'TextbookGenerationJob' } }
    /**
     * Find zero or one TextbookGenerationJob that matches the filter.
     * @param {TextbookGenerationJobFindUniqueArgs} args - Arguments to find a TextbookGenerationJob
     * @example
     * // Get one TextbookGenerationJob
     * const textbookGenerationJob = await prisma.textbookGenerationJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TextbookGenerationJobFindUniqueArgs>(args: SelectSubset<T, TextbookGenerationJobFindUniqueArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TextbookGenerationJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TextbookGenerationJobFindUniqueOrThrowArgs} args - Arguments to find a TextbookGenerationJob
     * @example
     * // Get one TextbookGenerationJob
     * const textbookGenerationJob = await prisma.textbookGenerationJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TextbookGenerationJobFindUniqueOrThrowArgs>(args: SelectSubset<T, TextbookGenerationJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookGenerationJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobFindFirstArgs} args - Arguments to find a TextbookGenerationJob
     * @example
     * // Get one TextbookGenerationJob
     * const textbookGenerationJob = await prisma.textbookGenerationJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TextbookGenerationJobFindFirstArgs>(args?: SelectSubset<T, TextbookGenerationJobFindFirstArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TextbookGenerationJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobFindFirstOrThrowArgs} args - Arguments to find a TextbookGenerationJob
     * @example
     * // Get one TextbookGenerationJob
     * const textbookGenerationJob = await prisma.textbookGenerationJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TextbookGenerationJobFindFirstOrThrowArgs>(args?: SelectSubset<T, TextbookGenerationJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TextbookGenerationJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TextbookGenerationJobs
     * const textbookGenerationJobs = await prisma.textbookGenerationJob.findMany()
     * 
     * // Get first 10 TextbookGenerationJobs
     * const textbookGenerationJobs = await prisma.textbookGenerationJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const textbookGenerationJobWithIdOnly = await prisma.textbookGenerationJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TextbookGenerationJobFindManyArgs>(args?: SelectSubset<T, TextbookGenerationJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TextbookGenerationJob.
     * @param {TextbookGenerationJobCreateArgs} args - Arguments to create a TextbookGenerationJob.
     * @example
     * // Create one TextbookGenerationJob
     * const TextbookGenerationJob = await prisma.textbookGenerationJob.create({
     *   data: {
     *     // ... data to create a TextbookGenerationJob
     *   }
     * })
     * 
     */
    create<T extends TextbookGenerationJobCreateArgs>(args: SelectSubset<T, TextbookGenerationJobCreateArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TextbookGenerationJobs.
     * @param {TextbookGenerationJobCreateManyArgs} args - Arguments to create many TextbookGenerationJobs.
     * @example
     * // Create many TextbookGenerationJobs
     * const textbookGenerationJob = await prisma.textbookGenerationJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TextbookGenerationJobCreateManyArgs>(args?: SelectSubset<T, TextbookGenerationJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TextbookGenerationJobs and returns the data saved in the database.
     * @param {TextbookGenerationJobCreateManyAndReturnArgs} args - Arguments to create many TextbookGenerationJobs.
     * @example
     * // Create many TextbookGenerationJobs
     * const textbookGenerationJob = await prisma.textbookGenerationJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TextbookGenerationJobs and only return the `id`
     * const textbookGenerationJobWithIdOnly = await prisma.textbookGenerationJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TextbookGenerationJobCreateManyAndReturnArgs>(args?: SelectSubset<T, TextbookGenerationJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TextbookGenerationJob.
     * @param {TextbookGenerationJobDeleteArgs} args - Arguments to delete one TextbookGenerationJob.
     * @example
     * // Delete one TextbookGenerationJob
     * const TextbookGenerationJob = await prisma.textbookGenerationJob.delete({
     *   where: {
     *     // ... filter to delete one TextbookGenerationJob
     *   }
     * })
     * 
     */
    delete<T extends TextbookGenerationJobDeleteArgs>(args: SelectSubset<T, TextbookGenerationJobDeleteArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TextbookGenerationJob.
     * @param {TextbookGenerationJobUpdateArgs} args - Arguments to update one TextbookGenerationJob.
     * @example
     * // Update one TextbookGenerationJob
     * const textbookGenerationJob = await prisma.textbookGenerationJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TextbookGenerationJobUpdateArgs>(args: SelectSubset<T, TextbookGenerationJobUpdateArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TextbookGenerationJobs.
     * @param {TextbookGenerationJobDeleteManyArgs} args - Arguments to filter TextbookGenerationJobs to delete.
     * @example
     * // Delete a few TextbookGenerationJobs
     * const { count } = await prisma.textbookGenerationJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TextbookGenerationJobDeleteManyArgs>(args?: SelectSubset<T, TextbookGenerationJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookGenerationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TextbookGenerationJobs
     * const textbookGenerationJob = await prisma.textbookGenerationJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TextbookGenerationJobUpdateManyArgs>(args: SelectSubset<T, TextbookGenerationJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TextbookGenerationJobs and returns the data updated in the database.
     * @param {TextbookGenerationJobUpdateManyAndReturnArgs} args - Arguments to update many TextbookGenerationJobs.
     * @example
     * // Update many TextbookGenerationJobs
     * const textbookGenerationJob = await prisma.textbookGenerationJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TextbookGenerationJobs and only return the `id`
     * const textbookGenerationJobWithIdOnly = await prisma.textbookGenerationJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TextbookGenerationJobUpdateManyAndReturnArgs>(args: SelectSubset<T, TextbookGenerationJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TextbookGenerationJob.
     * @param {TextbookGenerationJobUpsertArgs} args - Arguments to update or create a TextbookGenerationJob.
     * @example
     * // Update or create a TextbookGenerationJob
     * const textbookGenerationJob = await prisma.textbookGenerationJob.upsert({
     *   create: {
     *     // ... data to create a TextbookGenerationJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TextbookGenerationJob we want to update
     *   }
     * })
     */
    upsert<T extends TextbookGenerationJobUpsertArgs>(args: SelectSubset<T, TextbookGenerationJobUpsertArgs<ExtArgs>>): Prisma__TextbookGenerationJobClient<$Result.GetResult<Prisma.$TextbookGenerationJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TextbookGenerationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobCountArgs} args - Arguments to filter TextbookGenerationJobs to count.
     * @example
     * // Count the number of TextbookGenerationJobs
     * const count = await prisma.textbookGenerationJob.count({
     *   where: {
     *     // ... the filter for the TextbookGenerationJobs we want to count
     *   }
     * })
    **/
    count<T extends TextbookGenerationJobCountArgs>(
      args?: Subset<T, TextbookGenerationJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TextbookGenerationJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TextbookGenerationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TextbookGenerationJobAggregateArgs>(args: Subset<T, TextbookGenerationJobAggregateArgs>): Prisma.PrismaPromise<GetTextbookGenerationJobAggregateType<T>>

    /**
     * Group by TextbookGenerationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TextbookGenerationJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TextbookGenerationJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TextbookGenerationJobGroupByArgs['orderBy'] }
        : { orderBy?: TextbookGenerationJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TextbookGenerationJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTextbookGenerationJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TextbookGenerationJob model
   */
  readonly fields: TextbookGenerationJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TextbookGenerationJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TextbookGenerationJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    textbook<T extends TextbookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TextbookDefaultArgs<ExtArgs>>): Prisma__TextbookClient<$Result.GetResult<Prisma.$TextbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TextbookGenerationJob model
   */
  interface TextbookGenerationJobFieldRefs {
    readonly id: FieldRef<"TextbookGenerationJob", 'Int'>
    readonly textbook_id: FieldRef<"TextbookGenerationJob", 'Int'>
    readonly job_type: FieldRef<"TextbookGenerationJob", 'TextbookGenerationJobType'>
    readonly status: FieldRef<"TextbookGenerationJob", 'TextbookJobStatus'>
    readonly target_id: FieldRef<"TextbookGenerationJob", 'Int'>
    readonly input_data: FieldRef<"TextbookGenerationJob", 'Json'>
    readonly output_data: FieldRef<"TextbookGenerationJob", 'Json'>
    readonly error_message: FieldRef<"TextbookGenerationJob", 'String'>
    readonly progress: FieldRef<"TextbookGenerationJob", 'Int'>
    readonly started_at: FieldRef<"TextbookGenerationJob", 'DateTime'>
    readonly completed_at: FieldRef<"TextbookGenerationJob", 'DateTime'>
    readonly attempts: FieldRef<"TextbookGenerationJob", 'Int'>
    readonly max_attempts: FieldRef<"TextbookGenerationJob", 'Int'>
    readonly created_at: FieldRef<"TextbookGenerationJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TextbookGenerationJob findUnique
   */
  export type TextbookGenerationJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which TextbookGenerationJob to fetch.
     */
    where: TextbookGenerationJobWhereUniqueInput
  }

  /**
   * TextbookGenerationJob findUniqueOrThrow
   */
  export type TextbookGenerationJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which TextbookGenerationJob to fetch.
     */
    where: TextbookGenerationJobWhereUniqueInput
  }

  /**
   * TextbookGenerationJob findFirst
   */
  export type TextbookGenerationJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which TextbookGenerationJob to fetch.
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookGenerationJobs to fetch.
     */
    orderBy?: TextbookGenerationJobOrderByWithRelationInput | TextbookGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookGenerationJobs.
     */
    cursor?: TextbookGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookGenerationJobs.
     */
    distinct?: TextbookGenerationJobScalarFieldEnum | TextbookGenerationJobScalarFieldEnum[]
  }

  /**
   * TextbookGenerationJob findFirstOrThrow
   */
  export type TextbookGenerationJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which TextbookGenerationJob to fetch.
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookGenerationJobs to fetch.
     */
    orderBy?: TextbookGenerationJobOrderByWithRelationInput | TextbookGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TextbookGenerationJobs.
     */
    cursor?: TextbookGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TextbookGenerationJobs.
     */
    distinct?: TextbookGenerationJobScalarFieldEnum | TextbookGenerationJobScalarFieldEnum[]
  }

  /**
   * TextbookGenerationJob findMany
   */
  export type TextbookGenerationJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which TextbookGenerationJobs to fetch.
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TextbookGenerationJobs to fetch.
     */
    orderBy?: TextbookGenerationJobOrderByWithRelationInput | TextbookGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TextbookGenerationJobs.
     */
    cursor?: TextbookGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TextbookGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TextbookGenerationJobs.
     */
    skip?: number
    distinct?: TextbookGenerationJobScalarFieldEnum | TextbookGenerationJobScalarFieldEnum[]
  }

  /**
   * TextbookGenerationJob create
   */
  export type TextbookGenerationJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * The data needed to create a TextbookGenerationJob.
     */
    data: XOR<TextbookGenerationJobCreateInput, TextbookGenerationJobUncheckedCreateInput>
  }

  /**
   * TextbookGenerationJob createMany
   */
  export type TextbookGenerationJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TextbookGenerationJobs.
     */
    data: TextbookGenerationJobCreateManyInput | TextbookGenerationJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TextbookGenerationJob createManyAndReturn
   */
  export type TextbookGenerationJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * The data used to create many TextbookGenerationJobs.
     */
    data: TextbookGenerationJobCreateManyInput | TextbookGenerationJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookGenerationJob update
   */
  export type TextbookGenerationJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * The data needed to update a TextbookGenerationJob.
     */
    data: XOR<TextbookGenerationJobUpdateInput, TextbookGenerationJobUncheckedUpdateInput>
    /**
     * Choose, which TextbookGenerationJob to update.
     */
    where: TextbookGenerationJobWhereUniqueInput
  }

  /**
   * TextbookGenerationJob updateMany
   */
  export type TextbookGenerationJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TextbookGenerationJobs.
     */
    data: XOR<TextbookGenerationJobUpdateManyMutationInput, TextbookGenerationJobUncheckedUpdateManyInput>
    /**
     * Filter which TextbookGenerationJobs to update
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * Limit how many TextbookGenerationJobs to update.
     */
    limit?: number
  }

  /**
   * TextbookGenerationJob updateManyAndReturn
   */
  export type TextbookGenerationJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * The data used to update TextbookGenerationJobs.
     */
    data: XOR<TextbookGenerationJobUpdateManyMutationInput, TextbookGenerationJobUncheckedUpdateManyInput>
    /**
     * Filter which TextbookGenerationJobs to update
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * Limit how many TextbookGenerationJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TextbookGenerationJob upsert
   */
  export type TextbookGenerationJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * The filter to search for the TextbookGenerationJob to update in case it exists.
     */
    where: TextbookGenerationJobWhereUniqueInput
    /**
     * In case the TextbookGenerationJob found by the `where` argument doesn't exist, create a new TextbookGenerationJob with this data.
     */
    create: XOR<TextbookGenerationJobCreateInput, TextbookGenerationJobUncheckedCreateInput>
    /**
     * In case the TextbookGenerationJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TextbookGenerationJobUpdateInput, TextbookGenerationJobUncheckedUpdateInput>
  }

  /**
   * TextbookGenerationJob delete
   */
  export type TextbookGenerationJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
    /**
     * Filter which TextbookGenerationJob to delete.
     */
    where: TextbookGenerationJobWhereUniqueInput
  }

  /**
   * TextbookGenerationJob deleteMany
   */
  export type TextbookGenerationJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TextbookGenerationJobs to delete
     */
    where?: TextbookGenerationJobWhereInput
    /**
     * Limit how many TextbookGenerationJobs to delete.
     */
    limit?: number
  }

  /**
   * TextbookGenerationJob without action
   */
  export type TextbookGenerationJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TextbookGenerationJob
     */
    select?: TextbookGenerationJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TextbookGenerationJob
     */
    omit?: TextbookGenerationJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TextbookGenerationJobInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoryListScalarFieldEnum: {
    id: 'id',
    category: 'category',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id'
  };

  export type CategoryListScalarFieldEnum = (typeof CategoryListScalarFieldEnum)[keyof typeof CategoryListScalarFieldEnum]


  export const FileListScalarFieldEnum: {
    id: 'id',
    category: 'category',
    title: 'title',
    note: 'note',
    content_format: 'content_format',
    doc1: 'doc1',
    entry_date: 'entry_date',
    entry_date_real: 'entry_date_real',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    parsing_status: 'parsing_status',
    parsing_error: 'parsing_error',
    parsed_at: 'parsed_at'
  };

  export type FileListScalarFieldEnum = (typeof FileListScalarFieldEnum)[keyof typeof FileListScalarFieldEnum]


  export const DocumentPageScalarFieldEnum: {
    id: 'id',
    file_id: 'file_id',
    page_number: 'page_number',
    image_url: 'image_url',
    width: 'width',
    height: 'height',
    created_at: 'created_at'
  };

  export type DocumentPageScalarFieldEnum = (typeof DocumentPageScalarFieldEnum)[keyof typeof DocumentPageScalarFieldEnum]


  export const FileChunkScalarFieldEnum: {
    id: 'id',
    file_id: 'file_id',
    chunk_index: 'chunk_index',
    content: 'content',
    page_number: 'page_number',
    bbox: 'bbox',
    token_count: 'token_count',
    created_at: 'created_at'
  };

  export type FileChunkScalarFieldEnum = (typeof FileChunkScalarFieldEnum)[keyof typeof FileChunkScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password_hash: 'password_hash',
    role: 'role',
    is_active: 'is_active',
    last_login: 'last_login',
    created_at: 'created_at',
    email: 'email'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserEnrollmentScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    textbook_id: 'textbook_id',
    status: 'status',
    progress: 'progress',
    last_accessed_at: 'last_accessed_at',
    enrolled_at: 'enrolled_at',
    completed_at: 'completed_at'
  };

  export type UserEnrollmentScalarFieldEnum = (typeof UserEnrollmentScalarFieldEnum)[keyof typeof UserEnrollmentScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    created_at: 'created_at',
    updated_at: 'updated_at',
    last_message_at: 'last_message_at',
    message_count: 'message_count',
    is_pinned: 'is_pinned',
    is_archived: 'is_archived',
    subject_id: 'subject_id',
    chapter_id: 'chapter_id'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationMessageScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    role: 'role',
    content: 'content',
    sources: 'sources',
    token_count: 'token_count',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type ConversationMessageScalarFieldEnum = (typeof ConversationMessageScalarFieldEnum)[keyof typeof ConversationMessageScalarFieldEnum]


  export const AiApiKeyScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    label: 'label',
    api_key_enc: 'api_key_enc',
    active: 'active',
    priority: 'priority',
    success_count: 'success_count',
    error_count: 'error_count',
    last_used_at: 'last_used_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AiApiKeyScalarFieldEnum = (typeof AiApiKeyScalarFieldEnum)[keyof typeof AiApiKeyScalarFieldEnum]


  export const AiModelScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    name: 'name',
    label: 'label',
    active: 'active',
    priority: 'priority',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AiModelScalarFieldEnum = (typeof AiModelScalarFieldEnum)[keyof typeof AiModelScalarFieldEnum]


  export const App_settingsScalarFieldEnum: {
    key: 'key',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type App_settingsScalarFieldEnum = (typeof App_settingsScalarFieldEnum)[keyof typeof App_settingsScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    display_name: 'display_name',
    description: 'description',
    price_monthly: 'price_monthly',
    price_yearly: 'price_yearly',
    razorpay_plan_id_monthly: 'razorpay_plan_id_monthly',
    razorpay_plan_id_yearly: 'razorpay_plan_id_yearly',
    features: 'features',
    limits: 'limits',
    is_active: 'is_active',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    plan_id: 'plan_id',
    razorpay_subscription_id: 'razorpay_subscription_id',
    razorpay_customer_id: 'razorpay_customer_id',
    razorpay_order_id: 'razorpay_order_id',
    status: 'status',
    billing_cycle: 'billing_cycle',
    current_period_start: 'current_period_start',
    current_period_end: 'current_period_end',
    cancel_at_period_end: 'cancel_at_period_end',
    canceled_at: 'canceled_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const UsageTrackingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    usage_type: 'usage_type',
    count: 'count',
    period_start: 'period_start',
    period_end: 'period_end',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type UsageTrackingScalarFieldEnum = (typeof UsageTrackingScalarFieldEnum)[keyof typeof UsageTrackingScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    currency: 'currency',
    locale: 'locale',
    is_active: 'is_active'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    country_id: 'country_id',
    state: 'state',
    type: 'type',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const InstitutionScalarFieldEnum: {
    id: 'id',
    board_id: 'board_id',
    name: 'name',
    type: 'type',
    district: 'district',
    state: 'state',
    license_expiry: 'license_expiry',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    board_id: 'board_id',
    institution_id: 'institution_id',
    name: 'name',
    code: 'code',
    level: 'level',
    duration_years: 'duration_years',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    institution_id: 'institution_id',
    program_id: 'program_id',
    is_premium: 'is_premium',
    last_sync_at: 'last_sync_at'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    program_id: 'program_id',
    name: 'name',
    code: 'code',
    is_active: 'is_active',
    created_at: 'created_at',
    term: 'term'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    subject_id: 'subject_id',
    title: 'title',
    chapter_number: 'chapter_number',
    content_json: 'content_json',
    version_id: 'version_id',
    accessible_boards: 'accessible_boards',
    is_global: 'is_global',
    is_active: 'is_active',
    processing_status: 'processing_status',
    error_message: 'error_message',
    processed_at: 'processed_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    parsed_at: 'parsed_at'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const ChapterChunkScalarFieldEnum: {
    id: 'id',
    chapter_id: 'chapter_id',
    chunk_index: 'chunk_index',
    content: 'content',
    page_number: 'page_number',
    bbox: 'bbox',
    subject_id: 'subject_id',
    created_at: 'created_at'
  };

  export type ChapterChunkScalarFieldEnum = (typeof ChapterChunkScalarFieldEnum)[keyof typeof ChapterChunkScalarFieldEnum]


  export const ChapterChunkBoardScalarFieldEnum: {
    chunk_id: 'chunk_id',
    board_id: 'board_id'
  };

  export type ChapterChunkBoardScalarFieldEnum = (typeof ChapterChunkBoardScalarFieldEnum)[keyof typeof ChapterChunkBoardScalarFieldEnum]


  export const ChapterPageScalarFieldEnum: {
    id: 'id',
    chapter_id: 'chapter_id',
    page_number: 'page_number',
    image_url: 'image_url',
    width: 'width',
    height: 'height',
    created_at: 'created_at'
  };

  export type ChapterPageScalarFieldEnum = (typeof ChapterPageScalarFieldEnum)[keyof typeof ChapterPageScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    subject_id: 'subject_id',
    chapter_id: 'chapter_id',
    title: 'title',
    description: 'description',
    status: 'status',
    score: 'score',
    total_points: 'total_points',
    created_at: 'created_at',
    updated_at: 'updated_at',
    completed_at: 'completed_at'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    quiz_id: 'quiz_id',
    question_text: 'question_text',
    question_type: 'question_type',
    options: 'options',
    correct_answer: 'correct_answer',
    user_answer: 'user_answer',
    is_correct: 'is_correct',
    points: 'points',
    explanation: 'explanation',
    feedback: 'feedback'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    chapter_id: 'chapter_id',
    question_text: 'question_text',
    question_type: 'question_type',
    difficulty: 'difficulty',
    options: 'options',
    correct_answer: 'correct_answer',
    explanation: 'explanation',
    points: 'points',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const UserPointsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    points: 'points',
    reason: 'reason',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type UserPointsScalarFieldEnum = (typeof UserPointsScalarFieldEnum)[keyof typeof UserPointsScalarFieldEnum]


  export const StudyMaterialScalarFieldEnum: {
    id: 'id',
    chapter_id: 'chapter_id',
    summary: 'summary',
    definitions: 'definitions',
    flashcards: 'flashcards',
    mind_map: 'mind_map',
    video_queries: 'video_queries',
    curated_videos: 'curated_videos',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StudyMaterialScalarFieldEnum = (typeof StudyMaterialScalarFieldEnum)[keyof typeof StudyMaterialScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    program_id: 'program_id',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const StreakBadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    min_streak: 'min_streak',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StreakBadgeScalarFieldEnum = (typeof StreakBadgeScalarFieldEnum)[keyof typeof StreakBadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    badge_id: 'badge_id',
    earned_at: 'earned_at'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const LearningSessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    chapter_id: 'chapter_id',
    status: 'status',
    current_topic: 'current_topic',
    progress: 'progress',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LearningSessionScalarFieldEnum = (typeof LearningSessionScalarFieldEnum)[keyof typeof LearningSessionScalarFieldEnum]


  export const BattleScalarFieldEnum: {
    id: 'id',
    quiz_id: 'quiz_id',
    code: 'code',
    status: 'status',
    created_by: 'created_by',
    created_at: 'created_at',
    started_at: 'started_at',
    ended_at: 'ended_at',
    settings: 'settings'
  };

  export type BattleScalarFieldEnum = (typeof BattleScalarFieldEnum)[keyof typeof BattleScalarFieldEnum]


  export const BattleParticipantScalarFieldEnum: {
    id: 'id',
    battle_id: 'battle_id',
    user_id: 'user_id',
    score: 'score',
    current_q_index: 'current_q_index',
    finished: 'finished',
    joined_at: 'joined_at',
    last_active: 'last_active'
  };

  export type BattleParticipantScalarFieldEnum = (typeof BattleParticipantScalarFieldEnum)[keyof typeof BattleParticipantScalarFieldEnum]


  export const SyllabusScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    board: 'board',
    class_level: 'class_level',
    stream: 'stream',
    subject: 'subject',
    academic_year: 'academic_year',
    raw_text: 'raw_text',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SyllabusScalarFieldEnum = (typeof SyllabusScalarFieldEnum)[keyof typeof SyllabusScalarFieldEnum]


  export const SyllabusUnitScalarFieldEnum: {
    id: 'id',
    syllabus_id: 'syllabus_id',
    title: 'title',
    order: 'order',
    description: 'description'
  };

  export type SyllabusUnitScalarFieldEnum = (typeof SyllabusUnitScalarFieldEnum)[keyof typeof SyllabusUnitScalarFieldEnum]


  export const SyllabusChapterScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    chapter_number: 'chapter_number',
    title: 'title',
    order: 'order',
    subtopics: 'subtopics'
  };

  export type SyllabusChapterScalarFieldEnum = (typeof SyllabusChapterScalarFieldEnum)[keyof typeof SyllabusChapterScalarFieldEnum]


  export const TextbookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    class_level: 'class_level',
    stream: 'stream',
    subject_name: 'subject_name',
    board_id: 'board_id',
    academic_year: 'academic_year',
    author: 'author',
    syllabus_id: 'syllabus_id',
    raw_syllabus: 'raw_syllabus',
    status: 'status',
    progress: 'progress',
    cover_image_url: 'cover_image_url',
    pdf_url: 'pdf_url',
    compiled_pdf_url: 'compiled_pdf_url',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by'
  };

  export type TextbookScalarFieldEnum = (typeof TextbookScalarFieldEnum)[keyof typeof TextbookScalarFieldEnum]


  export const TextbookUnitScalarFieldEnum: {
    id: 'id',
    textbook_id: 'textbook_id',
    order: 'order',
    title: 'title',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TextbookUnitScalarFieldEnum = (typeof TextbookUnitScalarFieldEnum)[keyof typeof TextbookUnitScalarFieldEnum]


  export const TextbookChapterScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    chapter_number: 'chapter_number',
    title: 'title',
    order: 'order',
    raw_syllabus_text: 'raw_syllabus_text',
    subtopics: 'subtopics',
    content: 'content',
    content_markdown: 'content_markdown',
    content_html: 'content_html',
    summary: 'summary',
    learning_outcomes: 'learning_outcomes',
    key_takeaways: 'key_takeaways',
    pdf_url: 'pdf_url',
    generated_at: 'generated_at',
    neet_relevant: 'neet_relevant',
    jee_relevant: 'jee_relevant',
    cuet_relevant: 'cuet_relevant',
    exam_highlights: 'exam_highlights',
    mcq_questions: 'mcq_questions',
    short_questions: 'short_questions',
    long_questions: 'long_questions',
    model_used: 'model_used',
    tokens_used: 'tokens_used',
    generation_time_ms: 'generation_time_ms',
    status: 'status',
    generation_error: 'generation_error',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TextbookChapterScalarFieldEnum = (typeof TextbookChapterScalarFieldEnum)[keyof typeof TextbookChapterScalarFieldEnum]


  export const TextbookImageScalarFieldEnum: {
    id: 'id',
    chapter_id: 'chapter_id',
    type: 'type',
    prompt: 'prompt',
    alt_text: 'alt_text',
    url: 'url',
    image_url: 'image_url',
    order: 'order',
    placement: 'placement',
    caption: 'caption',
    status: 'status',
    model_used: 'model_used',
    generation_time_ms: 'generation_time_ms',
    generated_at: 'generated_at',
    created_at: 'created_at'
  };

  export type TextbookImageScalarFieldEnum = (typeof TextbookImageScalarFieldEnum)[keyof typeof TextbookImageScalarFieldEnum]


  export const TextbookGenerationJobScalarFieldEnum: {
    id: 'id',
    textbook_id: 'textbook_id',
    job_type: 'job_type',
    status: 'status',
    target_id: 'target_id',
    input_data: 'input_data',
    output_data: 'output_data',
    error_message: 'error_message',
    progress: 'progress',
    started_at: 'started_at',
    completed_at: 'completed_at',
    attempts: 'attempts',
    max_attempts: 'max_attempts',
    created_at: 'created_at'
  };

  export type TextbookGenerationJobScalarFieldEnum = (typeof TextbookGenerationJobScalarFieldEnum)[keyof typeof TextbookGenerationJobScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'MessageRole'
   */
  export type EnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole'>
    


  /**
   * Reference to a field of type 'MessageRole[]'
   */
  export type ListEnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole[]'>
    


  /**
   * Reference to a field of type 'Provider'
   */
  export type EnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider'>
    


  /**
   * Reference to a field of type 'Provider[]'
   */
  export type ListEnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'BillingCycle'
   */
  export type EnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle'>
    


  /**
   * Reference to a field of type 'BillingCycle[]'
   */
  export type ListEnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle[]'>
    


  /**
   * Reference to a field of type 'UsageType'
   */
  export type EnumUsageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsageType'>
    


  /**
   * Reference to a field of type 'UsageType[]'
   */
  export type ListEnumUsageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsageType[]'>
    


  /**
   * Reference to a field of type 'ChapterStatus'
   */
  export type EnumChapterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterStatus'>
    


  /**
   * Reference to a field of type 'ChapterStatus[]'
   */
  export type ListEnumChapterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterStatus[]'>
    


  /**
   * Reference to a field of type 'QuizStatus'
   */
  export type EnumQuizStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuizStatus'>
    


  /**
   * Reference to a field of type 'QuizStatus[]'
   */
  export type ListEnumQuizStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuizStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'BattleStatus'
   */
  export type EnumBattleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleStatus'>
    


  /**
   * Reference to a field of type 'BattleStatus[]'
   */
  export type ListEnumBattleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattleStatus[]'>
    


  /**
   * Reference to a field of type 'SyllabusStatus'
   */
  export type EnumSyllabusStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyllabusStatus'>
    


  /**
   * Reference to a field of type 'SyllabusStatus[]'
   */
  export type ListEnumSyllabusStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyllabusStatus[]'>
    


  /**
   * Reference to a field of type 'TextbookStatus'
   */
  export type EnumTextbookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookStatus'>
    


  /**
   * Reference to a field of type 'TextbookStatus[]'
   */
  export type ListEnumTextbookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookStatus[]'>
    


  /**
   * Reference to a field of type 'ChapterGenStatus'
   */
  export type EnumChapterGenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterGenStatus'>
    


  /**
   * Reference to a field of type 'ChapterGenStatus[]'
   */
  export type ListEnumChapterGenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterGenStatus[]'>
    


  /**
   * Reference to a field of type 'TextbookImageType'
   */
  export type EnumTextbookImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookImageType'>
    


  /**
   * Reference to a field of type 'TextbookImageType[]'
   */
  export type ListEnumTextbookImageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookImageType[]'>
    


  /**
   * Reference to a field of type 'ImageGenStatus'
   */
  export type EnumImageGenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageGenStatus'>
    


  /**
   * Reference to a field of type 'ImageGenStatus[]'
   */
  export type ListEnumImageGenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageGenStatus[]'>
    


  /**
   * Reference to a field of type 'TextbookGenerationJobType'
   */
  export type EnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookGenerationJobType'>
    


  /**
   * Reference to a field of type 'TextbookGenerationJobType[]'
   */
  export type ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookGenerationJobType[]'>
    


  /**
   * Reference to a field of type 'TextbookJobStatus'
   */
  export type EnumTextbookJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookJobStatus'>
    


  /**
   * Reference to a field of type 'TextbookJobStatus[]'
   */
  export type ListEnumTextbookJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextbookJobStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CategoryListWhereInput = {
    AND?: CategoryListWhereInput | CategoryListWhereInput[]
    OR?: CategoryListWhereInput[]
    NOT?: CategoryListWhereInput | CategoryListWhereInput[]
    id?: IntFilter<"CategoryList"> | number
    category?: StringFilter<"CategoryList"> | string
    created_at?: DateTimeNullableFilter<"CategoryList"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"CategoryList"> | Date | string | null
    user_id?: IntNullableFilter<"CategoryList"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type CategoryListOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type CategoryListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoryListWhereInput | CategoryListWhereInput[]
    OR?: CategoryListWhereInput[]
    NOT?: CategoryListWhereInput | CategoryListWhereInput[]
    category?: StringFilter<"CategoryList"> | string
    created_at?: DateTimeNullableFilter<"CategoryList"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"CategoryList"> | Date | string | null
    user_id?: IntNullableFilter<"CategoryList"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type CategoryListOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: CategoryListCountOrderByAggregateInput
    _avg?: CategoryListAvgOrderByAggregateInput
    _max?: CategoryListMaxOrderByAggregateInput
    _min?: CategoryListMinOrderByAggregateInput
    _sum?: CategoryListSumOrderByAggregateInput
  }

  export type CategoryListScalarWhereWithAggregatesInput = {
    AND?: CategoryListScalarWhereWithAggregatesInput | CategoryListScalarWhereWithAggregatesInput[]
    OR?: CategoryListScalarWhereWithAggregatesInput[]
    NOT?: CategoryListScalarWhereWithAggregatesInput | CategoryListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CategoryList"> | number
    category?: StringWithAggregatesFilter<"CategoryList"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"CategoryList"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"CategoryList"> | Date | string | null
    user_id?: IntNullableWithAggregatesFilter<"CategoryList"> | number | null
  }

  export type FileListWhereInput = {
    AND?: FileListWhereInput | FileListWhereInput[]
    OR?: FileListWhereInput[]
    NOT?: FileListWhereInput | FileListWhereInput[]
    id?: IntFilter<"FileList"> | number
    category?: StringFilter<"FileList"> | string
    title?: StringFilter<"FileList"> | string
    note?: StringNullableFilter<"FileList"> | string | null
    content_format?: StringNullableFilter<"FileList"> | string | null
    doc1?: StringNullableFilter<"FileList"> | string | null
    entry_date?: StringNullableFilter<"FileList"> | string | null
    entry_date_real?: DateTimeNullableFilter<"FileList"> | Date | string | null
    created_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    user_id?: IntNullableFilter<"FileList"> | number | null
    parsing_status?: StringNullableFilter<"FileList"> | string | null
    parsing_error?: StringNullableFilter<"FileList"> | string | null
    parsed_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    pages?: DocumentPageListRelationFilter
    chunks?: FileChunkListRelationFilter
  }

  export type FileListOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    note?: SortOrderInput | SortOrder
    content_format?: SortOrderInput | SortOrder
    doc1?: SortOrderInput | SortOrder
    entry_date?: SortOrderInput | SortOrder
    entry_date_real?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    parsing_status?: SortOrderInput | SortOrder
    parsing_error?: SortOrderInput | SortOrder
    parsed_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    pages?: DocumentPageOrderByRelationAggregateInput
    chunks?: FileChunkOrderByRelationAggregateInput
  }

  export type FileListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FileListWhereInput | FileListWhereInput[]
    OR?: FileListWhereInput[]
    NOT?: FileListWhereInput | FileListWhereInput[]
    category?: StringFilter<"FileList"> | string
    title?: StringFilter<"FileList"> | string
    note?: StringNullableFilter<"FileList"> | string | null
    content_format?: StringNullableFilter<"FileList"> | string | null
    doc1?: StringNullableFilter<"FileList"> | string | null
    entry_date?: StringNullableFilter<"FileList"> | string | null
    entry_date_real?: DateTimeNullableFilter<"FileList"> | Date | string | null
    created_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    user_id?: IntNullableFilter<"FileList"> | number | null
    parsing_status?: StringNullableFilter<"FileList"> | string | null
    parsing_error?: StringNullableFilter<"FileList"> | string | null
    parsed_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    pages?: DocumentPageListRelationFilter
    chunks?: FileChunkListRelationFilter
  }, "id">

  export type FileListOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    note?: SortOrderInput | SortOrder
    content_format?: SortOrderInput | SortOrder
    doc1?: SortOrderInput | SortOrder
    entry_date?: SortOrderInput | SortOrder
    entry_date_real?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    parsing_status?: SortOrderInput | SortOrder
    parsing_error?: SortOrderInput | SortOrder
    parsed_at?: SortOrderInput | SortOrder
    _count?: FileListCountOrderByAggregateInput
    _avg?: FileListAvgOrderByAggregateInput
    _max?: FileListMaxOrderByAggregateInput
    _min?: FileListMinOrderByAggregateInput
    _sum?: FileListSumOrderByAggregateInput
  }

  export type FileListScalarWhereWithAggregatesInput = {
    AND?: FileListScalarWhereWithAggregatesInput | FileListScalarWhereWithAggregatesInput[]
    OR?: FileListScalarWhereWithAggregatesInput[]
    NOT?: FileListScalarWhereWithAggregatesInput | FileListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FileList"> | number
    category?: StringWithAggregatesFilter<"FileList"> | string
    title?: StringWithAggregatesFilter<"FileList"> | string
    note?: StringNullableWithAggregatesFilter<"FileList"> | string | null
    content_format?: StringNullableWithAggregatesFilter<"FileList"> | string | null
    doc1?: StringNullableWithAggregatesFilter<"FileList"> | string | null
    entry_date?: StringNullableWithAggregatesFilter<"FileList"> | string | null
    entry_date_real?: DateTimeNullableWithAggregatesFilter<"FileList"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"FileList"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"FileList"> | Date | string | null
    user_id?: IntNullableWithAggregatesFilter<"FileList"> | number | null
    parsing_status?: StringNullableWithAggregatesFilter<"FileList"> | string | null
    parsing_error?: StringNullableWithAggregatesFilter<"FileList"> | string | null
    parsed_at?: DateTimeNullableWithAggregatesFilter<"FileList"> | Date | string | null
  }

  export type DocumentPageWhereInput = {
    AND?: DocumentPageWhereInput | DocumentPageWhereInput[]
    OR?: DocumentPageWhereInput[]
    NOT?: DocumentPageWhereInput | DocumentPageWhereInput[]
    id?: IntFilter<"DocumentPage"> | number
    file_id?: IntFilter<"DocumentPage"> | number
    page_number?: IntFilter<"DocumentPage"> | number
    image_url?: StringFilter<"DocumentPage"> | string
    width?: IntNullableFilter<"DocumentPage"> | number | null
    height?: IntNullableFilter<"DocumentPage"> | number | null
    created_at?: DateTimeFilter<"DocumentPage"> | Date | string
    file?: XOR<FileListScalarRelationFilter, FileListWhereInput>
  }

  export type DocumentPageOrderByWithRelationInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    created_at?: SortOrder
    file?: FileListOrderByWithRelationInput
  }

  export type DocumentPageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentPageWhereInput | DocumentPageWhereInput[]
    OR?: DocumentPageWhereInput[]
    NOT?: DocumentPageWhereInput | DocumentPageWhereInput[]
    file_id?: IntFilter<"DocumentPage"> | number
    page_number?: IntFilter<"DocumentPage"> | number
    image_url?: StringFilter<"DocumentPage"> | string
    width?: IntNullableFilter<"DocumentPage"> | number | null
    height?: IntNullableFilter<"DocumentPage"> | number | null
    created_at?: DateTimeFilter<"DocumentPage"> | Date | string
    file?: XOR<FileListScalarRelationFilter, FileListWhereInput>
  }, "id">

  export type DocumentPageOrderByWithAggregationInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: DocumentPageCountOrderByAggregateInput
    _avg?: DocumentPageAvgOrderByAggregateInput
    _max?: DocumentPageMaxOrderByAggregateInput
    _min?: DocumentPageMinOrderByAggregateInput
    _sum?: DocumentPageSumOrderByAggregateInput
  }

  export type DocumentPageScalarWhereWithAggregatesInput = {
    AND?: DocumentPageScalarWhereWithAggregatesInput | DocumentPageScalarWhereWithAggregatesInput[]
    OR?: DocumentPageScalarWhereWithAggregatesInput[]
    NOT?: DocumentPageScalarWhereWithAggregatesInput | DocumentPageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DocumentPage"> | number
    file_id?: IntWithAggregatesFilter<"DocumentPage"> | number
    page_number?: IntWithAggregatesFilter<"DocumentPage"> | number
    image_url?: StringWithAggregatesFilter<"DocumentPage"> | string
    width?: IntNullableWithAggregatesFilter<"DocumentPage"> | number | null
    height?: IntNullableWithAggregatesFilter<"DocumentPage"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"DocumentPage"> | Date | string
  }

  export type FileChunkWhereInput = {
    AND?: FileChunkWhereInput | FileChunkWhereInput[]
    OR?: FileChunkWhereInput[]
    NOT?: FileChunkWhereInput | FileChunkWhereInput[]
    id?: IntFilter<"FileChunk"> | number
    file_id?: IntFilter<"FileChunk"> | number
    chunk_index?: IntFilter<"FileChunk"> | number
    content?: StringFilter<"FileChunk"> | string
    page_number?: IntNullableFilter<"FileChunk"> | number | null
    bbox?: JsonNullableFilter<"FileChunk">
    token_count?: IntNullableFilter<"FileChunk"> | number | null
    created_at?: DateTimeFilter<"FileChunk"> | Date | string
    file?: XOR<FileListScalarRelationFilter, FileListWhereInput>
  }

  export type FileChunkOrderByWithRelationInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrderInput | SortOrder
    bbox?: SortOrderInput | SortOrder
    token_count?: SortOrderInput | SortOrder
    created_at?: SortOrder
    file?: FileListOrderByWithRelationInput
  }

  export type FileChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FileChunkWhereInput | FileChunkWhereInput[]
    OR?: FileChunkWhereInput[]
    NOT?: FileChunkWhereInput | FileChunkWhereInput[]
    file_id?: IntFilter<"FileChunk"> | number
    chunk_index?: IntFilter<"FileChunk"> | number
    content?: StringFilter<"FileChunk"> | string
    page_number?: IntNullableFilter<"FileChunk"> | number | null
    bbox?: JsonNullableFilter<"FileChunk">
    token_count?: IntNullableFilter<"FileChunk"> | number | null
    created_at?: DateTimeFilter<"FileChunk"> | Date | string
    file?: XOR<FileListScalarRelationFilter, FileListWhereInput>
  }, "id">

  export type FileChunkOrderByWithAggregationInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrderInput | SortOrder
    bbox?: SortOrderInput | SortOrder
    token_count?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: FileChunkCountOrderByAggregateInput
    _avg?: FileChunkAvgOrderByAggregateInput
    _max?: FileChunkMaxOrderByAggregateInput
    _min?: FileChunkMinOrderByAggregateInput
    _sum?: FileChunkSumOrderByAggregateInput
  }

  export type FileChunkScalarWhereWithAggregatesInput = {
    AND?: FileChunkScalarWhereWithAggregatesInput | FileChunkScalarWhereWithAggregatesInput[]
    OR?: FileChunkScalarWhereWithAggregatesInput[]
    NOT?: FileChunkScalarWhereWithAggregatesInput | FileChunkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FileChunk"> | number
    file_id?: IntWithAggregatesFilter<"FileChunk"> | number
    chunk_index?: IntWithAggregatesFilter<"FileChunk"> | number
    content?: StringWithAggregatesFilter<"FileChunk"> | string
    page_number?: IntNullableWithAggregatesFilter<"FileChunk"> | number | null
    bbox?: JsonNullableWithAggregatesFilter<"FileChunk">
    token_count?: IntNullableWithAggregatesFilter<"FileChunk"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"FileChunk"> | Date | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    password_hash?: StringNullableFilter<"user"> | string | null
    role?: EnumUserRoleFilter<"user"> | $Enums.UserRole
    is_active?: BoolNullableFilter<"user"> | boolean | null
    last_login?: DateTimeNullableFilter<"user"> | Date | string | null
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    email?: StringNullableFilter<"user"> | string | null
    categories?: CategoryListListRelationFilter
    conversations?: ConversationListRelationFilter
    files?: FileListListRelationFilter
    usage_tracking?: UsageTrackingListRelationFilter
    subscription?: XOR<UserSubscriptionNullableScalarRelationFilter, UserSubscriptionWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    quizzes?: QuizListRelationFilter
    points?: UserPointsListRelationFilter
    badges?: UserBadgeListRelationFilter
    learning_sessions?: LearningSessionListRelationFilter
    created_battles?: BattleListRelationFilter
    battle_participations?: BattleParticipantListRelationFilter
    textbooks_created?: TextbookListRelationFilter
    enrollments?: UserEnrollmentListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    role?: SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    categories?: CategoryListOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    files?: FileListOrderByRelationAggregateInput
    usage_tracking?: UsageTrackingOrderByRelationAggregateInput
    subscription?: UserSubscriptionOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    quizzes?: QuizOrderByRelationAggregateInput
    points?: UserPointsOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    learning_sessions?: LearningSessionOrderByRelationAggregateInput
    created_battles?: BattleOrderByRelationAggregateInput
    battle_participations?: BattleParticipantOrderByRelationAggregateInput
    textbooks_created?: TextbookOrderByRelationAggregateInput
    enrollments?: UserEnrollmentOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password_hash?: StringNullableFilter<"user"> | string | null
    role?: EnumUserRoleFilter<"user"> | $Enums.UserRole
    is_active?: BoolNullableFilter<"user"> | boolean | null
    last_login?: DateTimeNullableFilter<"user"> | Date | string | null
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    categories?: CategoryListListRelationFilter
    conversations?: ConversationListRelationFilter
    files?: FileListListRelationFilter
    usage_tracking?: UsageTrackingListRelationFilter
    subscription?: XOR<UserSubscriptionNullableScalarRelationFilter, UserSubscriptionWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    quizzes?: QuizListRelationFilter
    points?: UserPointsListRelationFilter
    badges?: UserBadgeListRelationFilter
    learning_sessions?: LearningSessionListRelationFilter
    created_battles?: BattleListRelationFilter
    battle_participations?: BattleParticipantListRelationFilter
    textbooks_created?: TextbookListRelationFilter
    enrollments?: UserEnrollmentListRelationFilter
  }, "id" | "username" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    role?: SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    username?: StringWithAggregatesFilter<"user"> | string
    password_hash?: StringNullableWithAggregatesFilter<"user"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"user"> | $Enums.UserRole
    is_active?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"user"> | string | null
  }

  export type UserEnrollmentWhereInput = {
    AND?: UserEnrollmentWhereInput | UserEnrollmentWhereInput[]
    OR?: UserEnrollmentWhereInput[]
    NOT?: UserEnrollmentWhereInput | UserEnrollmentWhereInput[]
    id?: IntFilter<"UserEnrollment"> | number
    user_id?: IntFilter<"UserEnrollment"> | number
    textbook_id?: IntFilter<"UserEnrollment"> | number
    status?: StringFilter<"UserEnrollment"> | string
    progress?: IntFilter<"UserEnrollment"> | number
    last_accessed_at?: DateTimeNullableFilter<"UserEnrollment"> | Date | string | null
    enrolled_at?: DateTimeFilter<"UserEnrollment"> | Date | string
    completed_at?: DateTimeNullableFilter<"UserEnrollment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    textbook?: XOR<TextbookScalarRelationFilter, TextbookWhereInput>
  }

  export type UserEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    last_accessed_at?: SortOrderInput | SortOrder
    enrolled_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    textbook?: TextbookOrderByWithRelationInput
  }

  export type UserEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_textbook_id?: UserEnrollmentUser_idTextbook_idCompoundUniqueInput
    AND?: UserEnrollmentWhereInput | UserEnrollmentWhereInput[]
    OR?: UserEnrollmentWhereInput[]
    NOT?: UserEnrollmentWhereInput | UserEnrollmentWhereInput[]
    user_id?: IntFilter<"UserEnrollment"> | number
    textbook_id?: IntFilter<"UserEnrollment"> | number
    status?: StringFilter<"UserEnrollment"> | string
    progress?: IntFilter<"UserEnrollment"> | number
    last_accessed_at?: DateTimeNullableFilter<"UserEnrollment"> | Date | string | null
    enrolled_at?: DateTimeFilter<"UserEnrollment"> | Date | string
    completed_at?: DateTimeNullableFilter<"UserEnrollment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    textbook?: XOR<TextbookScalarRelationFilter, TextbookWhereInput>
  }, "id" | "user_id_textbook_id">

  export type UserEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    last_accessed_at?: SortOrderInput | SortOrder
    enrolled_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: UserEnrollmentCountOrderByAggregateInput
    _avg?: UserEnrollmentAvgOrderByAggregateInput
    _max?: UserEnrollmentMaxOrderByAggregateInput
    _min?: UserEnrollmentMinOrderByAggregateInput
    _sum?: UserEnrollmentSumOrderByAggregateInput
  }

  export type UserEnrollmentScalarWhereWithAggregatesInput = {
    AND?: UserEnrollmentScalarWhereWithAggregatesInput | UserEnrollmentScalarWhereWithAggregatesInput[]
    OR?: UserEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: UserEnrollmentScalarWhereWithAggregatesInput | UserEnrollmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserEnrollment"> | number
    user_id?: IntWithAggregatesFilter<"UserEnrollment"> | number
    textbook_id?: IntWithAggregatesFilter<"UserEnrollment"> | number
    status?: StringWithAggregatesFilter<"UserEnrollment"> | string
    progress?: IntWithAggregatesFilter<"UserEnrollment"> | number
    last_accessed_at?: DateTimeNullableWithAggregatesFilter<"UserEnrollment"> | Date | string | null
    enrolled_at?: DateTimeWithAggregatesFilter<"UserEnrollment"> | Date | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"UserEnrollment"> | Date | string | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: IntFilter<"Conversation"> | number
    user_id?: IntFilter<"Conversation"> | number
    title?: StringFilter<"Conversation"> | string
    created_at?: DateTimeFilter<"Conversation"> | Date | string
    updated_at?: DateTimeFilter<"Conversation"> | Date | string
    last_message_at?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    message_count?: IntFilter<"Conversation"> | number
    is_pinned?: BoolFilter<"Conversation"> | boolean
    is_archived?: BoolFilter<"Conversation"> | boolean
    subject_id?: IntNullableFilter<"Conversation"> | number | null
    chapter_id?: BigIntNullableFilter<"Conversation"> | bigint | number | null
    messages?: ConversationMessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    chapter?: XOR<ChapterNullableScalarRelationFilter, ChapterWhereInput> | null
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_message_at?: SortOrderInput | SortOrder
    message_count?: SortOrder
    is_pinned?: SortOrder
    is_archived?: SortOrder
    subject_id?: SortOrderInput | SortOrder
    chapter_id?: SortOrderInput | SortOrder
    messages?: ConversationMessageOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    user_id?: IntFilter<"Conversation"> | number
    title?: StringFilter<"Conversation"> | string
    created_at?: DateTimeFilter<"Conversation"> | Date | string
    updated_at?: DateTimeFilter<"Conversation"> | Date | string
    last_message_at?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    message_count?: IntFilter<"Conversation"> | number
    is_pinned?: BoolFilter<"Conversation"> | boolean
    is_archived?: BoolFilter<"Conversation"> | boolean
    subject_id?: IntNullableFilter<"Conversation"> | number | null
    chapter_id?: BigIntNullableFilter<"Conversation"> | bigint | number | null
    messages?: ConversationMessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    chapter?: XOR<ChapterNullableScalarRelationFilter, ChapterWhereInput> | null
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_message_at?: SortOrderInput | SortOrder
    message_count?: SortOrder
    is_pinned?: SortOrder
    is_archived?: SortOrder
    subject_id?: SortOrderInput | SortOrder
    chapter_id?: SortOrderInput | SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conversation"> | number
    user_id?: IntWithAggregatesFilter<"Conversation"> | number
    title?: StringWithAggregatesFilter<"Conversation"> | string
    created_at?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    last_message_at?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    message_count?: IntWithAggregatesFilter<"Conversation"> | number
    is_pinned?: BoolWithAggregatesFilter<"Conversation"> | boolean
    is_archived?: BoolWithAggregatesFilter<"Conversation"> | boolean
    subject_id?: IntNullableWithAggregatesFilter<"Conversation"> | number | null
    chapter_id?: BigIntNullableWithAggregatesFilter<"Conversation"> | bigint | number | null
  }

  export type ConversationMessageWhereInput = {
    AND?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    OR?: ConversationMessageWhereInput[]
    NOT?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    id?: IntFilter<"ConversationMessage"> | number
    conversation_id?: IntFilter<"ConversationMessage"> | number
    role?: EnumMessageRoleFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringFilter<"ConversationMessage"> | string
    sources?: JsonNullableFilter<"ConversationMessage">
    token_count?: JsonNullableFilter<"ConversationMessage">
    metadata?: JsonNullableFilter<"ConversationMessage">
    created_at?: DateTimeFilter<"ConversationMessage"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type ConversationMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sources?: SortOrderInput | SortOrder
    token_count?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    OR?: ConversationMessageWhereInput[]
    NOT?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    conversation_id?: IntFilter<"ConversationMessage"> | number
    role?: EnumMessageRoleFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringFilter<"ConversationMessage"> | string
    sources?: JsonNullableFilter<"ConversationMessage">
    token_count?: JsonNullableFilter<"ConversationMessage">
    metadata?: JsonNullableFilter<"ConversationMessage">
    created_at?: DateTimeFilter<"ConversationMessage"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type ConversationMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sources?: SortOrderInput | SortOrder
    token_count?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ConversationMessageCountOrderByAggregateInput
    _avg?: ConversationMessageAvgOrderByAggregateInput
    _max?: ConversationMessageMaxOrderByAggregateInput
    _min?: ConversationMessageMinOrderByAggregateInput
    _sum?: ConversationMessageSumOrderByAggregateInput
  }

  export type ConversationMessageScalarWhereWithAggregatesInput = {
    AND?: ConversationMessageScalarWhereWithAggregatesInput | ConversationMessageScalarWhereWithAggregatesInput[]
    OR?: ConversationMessageScalarWhereWithAggregatesInput[]
    NOT?: ConversationMessageScalarWhereWithAggregatesInput | ConversationMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConversationMessage"> | number
    conversation_id?: IntWithAggregatesFilter<"ConversationMessage"> | number
    role?: EnumMessageRoleWithAggregatesFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringWithAggregatesFilter<"ConversationMessage"> | string
    sources?: JsonNullableWithAggregatesFilter<"ConversationMessage">
    token_count?: JsonNullableWithAggregatesFilter<"ConversationMessage">
    metadata?: JsonNullableWithAggregatesFilter<"ConversationMessage">
    created_at?: DateTimeWithAggregatesFilter<"ConversationMessage"> | Date | string
  }

  export type AiApiKeyWhereInput = {
    AND?: AiApiKeyWhereInput | AiApiKeyWhereInput[]
    OR?: AiApiKeyWhereInput[]
    NOT?: AiApiKeyWhereInput | AiApiKeyWhereInput[]
    id?: IntFilter<"AiApiKey"> | number
    provider?: EnumProviderFilter<"AiApiKey"> | $Enums.Provider
    label?: StringFilter<"AiApiKey"> | string
    api_key_enc?: StringFilter<"AiApiKey"> | string
    active?: BoolFilter<"AiApiKey"> | boolean
    priority?: IntFilter<"AiApiKey"> | number
    success_count?: IntFilter<"AiApiKey"> | number
    error_count?: IntFilter<"AiApiKey"> | number
    last_used_at?: DateTimeNullableFilter<"AiApiKey"> | Date | string | null
    created_at?: DateTimeFilter<"AiApiKey"> | Date | string
    updated_at?: DateTimeFilter<"AiApiKey"> | Date | string
  }

  export type AiApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    label?: SortOrder
    api_key_enc?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    last_used_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AiApiKeyWhereInput | AiApiKeyWhereInput[]
    OR?: AiApiKeyWhereInput[]
    NOT?: AiApiKeyWhereInput | AiApiKeyWhereInput[]
    provider?: EnumProviderFilter<"AiApiKey"> | $Enums.Provider
    label?: StringFilter<"AiApiKey"> | string
    api_key_enc?: StringFilter<"AiApiKey"> | string
    active?: BoolFilter<"AiApiKey"> | boolean
    priority?: IntFilter<"AiApiKey"> | number
    success_count?: IntFilter<"AiApiKey"> | number
    error_count?: IntFilter<"AiApiKey"> | number
    last_used_at?: DateTimeNullableFilter<"AiApiKey"> | Date | string | null
    created_at?: DateTimeFilter<"AiApiKey"> | Date | string
    updated_at?: DateTimeFilter<"AiApiKey"> | Date | string
  }, "id">

  export type AiApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    label?: SortOrder
    api_key_enc?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    last_used_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AiApiKeyCountOrderByAggregateInput
    _avg?: AiApiKeyAvgOrderByAggregateInput
    _max?: AiApiKeyMaxOrderByAggregateInput
    _min?: AiApiKeyMinOrderByAggregateInput
    _sum?: AiApiKeySumOrderByAggregateInput
  }

  export type AiApiKeyScalarWhereWithAggregatesInput = {
    AND?: AiApiKeyScalarWhereWithAggregatesInput | AiApiKeyScalarWhereWithAggregatesInput[]
    OR?: AiApiKeyScalarWhereWithAggregatesInput[]
    NOT?: AiApiKeyScalarWhereWithAggregatesInput | AiApiKeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiApiKey"> | number
    provider?: EnumProviderWithAggregatesFilter<"AiApiKey"> | $Enums.Provider
    label?: StringWithAggregatesFilter<"AiApiKey"> | string
    api_key_enc?: StringWithAggregatesFilter<"AiApiKey"> | string
    active?: BoolWithAggregatesFilter<"AiApiKey"> | boolean
    priority?: IntWithAggregatesFilter<"AiApiKey"> | number
    success_count?: IntWithAggregatesFilter<"AiApiKey"> | number
    error_count?: IntWithAggregatesFilter<"AiApiKey"> | number
    last_used_at?: DateTimeNullableWithAggregatesFilter<"AiApiKey"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"AiApiKey"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AiApiKey"> | Date | string
  }

  export type AiModelWhereInput = {
    AND?: AiModelWhereInput | AiModelWhereInput[]
    OR?: AiModelWhereInput[]
    NOT?: AiModelWhereInput | AiModelWhereInput[]
    id?: IntFilter<"AiModel"> | number
    provider?: EnumProviderFilter<"AiModel"> | $Enums.Provider
    name?: StringFilter<"AiModel"> | string
    label?: StringFilter<"AiModel"> | string
    active?: BoolFilter<"AiModel"> | boolean
    priority?: IntFilter<"AiModel"> | number
    created_at?: DateTimeFilter<"AiModel"> | Date | string
    updated_at?: DateTimeFilter<"AiModel"> | Date | string
  }

  export type AiModelOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    label?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    provider_name?: AiModelProviderNameCompoundUniqueInput
    AND?: AiModelWhereInput | AiModelWhereInput[]
    OR?: AiModelWhereInput[]
    NOT?: AiModelWhereInput | AiModelWhereInput[]
    provider?: EnumProviderFilter<"AiModel"> | $Enums.Provider
    name?: StringFilter<"AiModel"> | string
    label?: StringFilter<"AiModel"> | string
    active?: BoolFilter<"AiModel"> | boolean
    priority?: IntFilter<"AiModel"> | number
    created_at?: DateTimeFilter<"AiModel"> | Date | string
    updated_at?: DateTimeFilter<"AiModel"> | Date | string
  }, "id" | "provider_name">

  export type AiModelOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    label?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AiModelCountOrderByAggregateInput
    _avg?: AiModelAvgOrderByAggregateInput
    _max?: AiModelMaxOrderByAggregateInput
    _min?: AiModelMinOrderByAggregateInput
    _sum?: AiModelSumOrderByAggregateInput
  }

  export type AiModelScalarWhereWithAggregatesInput = {
    AND?: AiModelScalarWhereWithAggregatesInput | AiModelScalarWhereWithAggregatesInput[]
    OR?: AiModelScalarWhereWithAggregatesInput[]
    NOT?: AiModelScalarWhereWithAggregatesInput | AiModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiModel"> | number
    provider?: EnumProviderWithAggregatesFilter<"AiModel"> | $Enums.Provider
    name?: StringWithAggregatesFilter<"AiModel"> | string
    label?: StringWithAggregatesFilter<"AiModel"> | string
    active?: BoolWithAggregatesFilter<"AiModel"> | boolean
    priority?: IntWithAggregatesFilter<"AiModel"> | number
    created_at?: DateTimeWithAggregatesFilter<"AiModel"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AiModel"> | Date | string
  }

  export type app_settingsWhereInput = {
    AND?: app_settingsWhereInput | app_settingsWhereInput[]
    OR?: app_settingsWhereInput[]
    NOT?: app_settingsWhereInput | app_settingsWhereInput[]
    key?: StringFilter<"app_settings"> | string
    value?: StringFilter<"app_settings"> | string
    created_at?: DateTimeNullableFilter<"app_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"app_settings"> | Date | string | null
  }

  export type app_settingsOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type app_settingsWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: app_settingsWhereInput | app_settingsWhereInput[]
    OR?: app_settingsWhereInput[]
    NOT?: app_settingsWhereInput | app_settingsWhereInput[]
    value?: StringFilter<"app_settings"> | string
    created_at?: DateTimeNullableFilter<"app_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"app_settings"> | Date | string | null
  }, "key">

  export type app_settingsOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: app_settingsCountOrderByAggregateInput
    _max?: app_settingsMaxOrderByAggregateInput
    _min?: app_settingsMinOrderByAggregateInput
  }

  export type app_settingsScalarWhereWithAggregatesInput = {
    AND?: app_settingsScalarWhereWithAggregatesInput | app_settingsScalarWhereWithAggregatesInput[]
    OR?: app_settingsScalarWhereWithAggregatesInput[]
    NOT?: app_settingsScalarWhereWithAggregatesInput | app_settingsScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"app_settings"> | string
    value?: StringWithAggregatesFilter<"app_settings"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"app_settings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"app_settings"> | Date | string | null
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: IntFilter<"SubscriptionPlan"> | number
    name?: StringFilter<"SubscriptionPlan"> | string
    display_name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price_monthly?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    price_yearly?: DecimalNullableFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: StringNullableFilter<"SubscriptionPlan"> | string | null
    razorpay_plan_id_yearly?: StringNullableFilter<"SubscriptionPlan"> | string | null
    features?: JsonNullableFilter<"SubscriptionPlan">
    limits?: JsonFilter<"SubscriptionPlan">
    is_active?: BoolFilter<"SubscriptionPlan"> | boolean
    is_default?: BoolFilter<"SubscriptionPlan"> | boolean
    created_at?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updated_at?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: UserSubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    description?: SortOrderInput | SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrderInput | SortOrder
    razorpay_plan_id_monthly?: SortOrderInput | SortOrder
    razorpay_plan_id_yearly?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    limits?: SortOrder
    is_active?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subscriptions?: UserSubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    display_name?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    price_monthly?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    price_yearly?: DecimalNullableFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: StringNullableFilter<"SubscriptionPlan"> | string | null
    razorpay_plan_id_yearly?: StringNullableFilter<"SubscriptionPlan"> | string | null
    features?: JsonNullableFilter<"SubscriptionPlan">
    limits?: JsonFilter<"SubscriptionPlan">
    is_active?: BoolFilter<"SubscriptionPlan"> | boolean
    is_default?: BoolFilter<"SubscriptionPlan"> | boolean
    created_at?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    updated_at?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: UserSubscriptionListRelationFilter
  }, "id" | "name">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    description?: SortOrderInput | SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrderInput | SortOrder
    razorpay_plan_id_monthly?: SortOrderInput | SortOrder
    razorpay_plan_id_yearly?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    limits?: SortOrder
    is_active?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    display_name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    price_monthly?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    price_yearly?: DecimalNullableWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    razorpay_plan_id_yearly?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    features?: JsonNullableWithAggregatesFilter<"SubscriptionPlan">
    limits?: JsonWithAggregatesFilter<"SubscriptionPlan">
    is_active?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    is_default?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: IntFilter<"UserSubscription"> | number
    user_id?: IntFilter<"UserSubscription"> | number
    plan_id?: IntFilter<"UserSubscription"> | number
    razorpay_subscription_id?: StringNullableFilter<"UserSubscription"> | string | null
    razorpay_customer_id?: StringNullableFilter<"UserSubscription"> | string | null
    razorpay_order_id?: StringNullableFilter<"UserSubscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFilter<"UserSubscription"> | $Enums.BillingCycle
    current_period_start?: DateTimeFilter<"UserSubscription"> | Date | string
    current_period_end?: DateTimeFilter<"UserSubscription"> | Date | string
    cancel_at_period_end?: BoolFilter<"UserSubscription"> | boolean
    canceled_at?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    created_at?: DateTimeFilter<"UserSubscription"> | Date | string
    updated_at?: DateTimeFilter<"UserSubscription"> | Date | string
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_subscription_id?: SortOrderInput | SortOrder
    razorpay_customer_id?: SortOrderInput | SortOrder
    razorpay_order_id?: SortOrderInput | SortOrder
    status?: SortOrder
    billing_cycle?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    plan?: SubscriptionPlanOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    razorpay_subscription_id?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    plan_id?: IntFilter<"UserSubscription"> | number
    razorpay_customer_id?: StringNullableFilter<"UserSubscription"> | string | null
    razorpay_order_id?: StringNullableFilter<"UserSubscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFilter<"UserSubscription"> | $Enums.BillingCycle
    current_period_start?: DateTimeFilter<"UserSubscription"> | Date | string
    current_period_end?: DateTimeFilter<"UserSubscription"> | Date | string
    cancel_at_period_end?: BoolFilter<"UserSubscription"> | boolean
    canceled_at?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    created_at?: DateTimeFilter<"UserSubscription"> | Date | string
    updated_at?: DateTimeFilter<"UserSubscription"> | Date | string
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "user_id" | "razorpay_subscription_id">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_subscription_id?: SortOrderInput | SortOrder
    razorpay_customer_id?: SortOrderInput | SortOrder
    razorpay_order_id?: SortOrderInput | SortOrder
    status?: SortOrder
    billing_cycle?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _avg?: UserSubscriptionAvgOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
    _sum?: UserSubscriptionSumOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSubscription"> | number
    user_id?: IntWithAggregatesFilter<"UserSubscription"> | number
    plan_id?: IntWithAggregatesFilter<"UserSubscription"> | number
    razorpay_subscription_id?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    razorpay_customer_id?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    razorpay_order_id?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleWithAggregatesFilter<"UserSubscription"> | $Enums.BillingCycle
    current_period_start?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    current_period_end?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    cancel_at_period_end?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    canceled_at?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
  }

  export type UsageTrackingWhereInput = {
    AND?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    OR?: UsageTrackingWhereInput[]
    NOT?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    id?: IntFilter<"UsageTracking"> | number
    user_id?: IntFilter<"UsageTracking"> | number
    usage_type?: EnumUsageTypeFilter<"UsageTracking"> | $Enums.UsageType
    count?: IntFilter<"UsageTracking"> | number
    period_start?: DateTimeFilter<"UsageTracking"> | Date | string
    period_end?: DateTimeFilter<"UsageTracking"> | Date | string
    metadata?: JsonNullableFilter<"UsageTracking">
    created_at?: DateTimeFilter<"UsageTracking"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type UsageTrackingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    usage_type?: SortOrder
    count?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type UsageTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    OR?: UsageTrackingWhereInput[]
    NOT?: UsageTrackingWhereInput | UsageTrackingWhereInput[]
    user_id?: IntFilter<"UsageTracking"> | number
    usage_type?: EnumUsageTypeFilter<"UsageTracking"> | $Enums.UsageType
    count?: IntFilter<"UsageTracking"> | number
    period_start?: DateTimeFilter<"UsageTracking"> | Date | string
    period_end?: DateTimeFilter<"UsageTracking"> | Date | string
    metadata?: JsonNullableFilter<"UsageTracking">
    created_at?: DateTimeFilter<"UsageTracking"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type UsageTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    usage_type?: SortOrder
    count?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UsageTrackingCountOrderByAggregateInput
    _avg?: UsageTrackingAvgOrderByAggregateInput
    _max?: UsageTrackingMaxOrderByAggregateInput
    _min?: UsageTrackingMinOrderByAggregateInput
    _sum?: UsageTrackingSumOrderByAggregateInput
  }

  export type UsageTrackingScalarWhereWithAggregatesInput = {
    AND?: UsageTrackingScalarWhereWithAggregatesInput | UsageTrackingScalarWhereWithAggregatesInput[]
    OR?: UsageTrackingScalarWhereWithAggregatesInput[]
    NOT?: UsageTrackingScalarWhereWithAggregatesInput | UsageTrackingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UsageTracking"> | number
    user_id?: IntWithAggregatesFilter<"UsageTracking"> | number
    usage_type?: EnumUsageTypeWithAggregatesFilter<"UsageTracking"> | $Enums.UsageType
    count?: IntWithAggregatesFilter<"UsageTracking"> | number
    period_start?: DateTimeWithAggregatesFilter<"UsageTracking"> | Date | string
    period_end?: DateTimeWithAggregatesFilter<"UsageTracking"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"UsageTracking">
    created_at?: DateTimeWithAggregatesFilter<"UsageTracking"> | Date | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: StringFilter<"Country"> | string
    name?: StringFilter<"Country"> | string
    currency?: StringFilter<"Country"> | string
    locale?: StringFilter<"Country"> | string
    is_active?: BoolFilter<"Country"> | boolean
    boards?: BoardListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    is_active?: SortOrder
    boards?: BoardOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    currency?: StringFilter<"Country"> | string
    locale?: StringFilter<"Country"> | string
    is_active?: BoolFilter<"Country"> | boolean
    boards?: BoardListRelationFilter
  }, "id">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    is_active?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Country"> | string
    name?: StringWithAggregatesFilter<"Country"> | string
    currency?: StringWithAggregatesFilter<"Country"> | string
    locale?: StringWithAggregatesFilter<"Country"> | string
    is_active?: BoolWithAggregatesFilter<"Country"> | boolean
  }

  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: StringFilter<"Board"> | string
    name?: StringFilter<"Board"> | string
    country_id?: StringFilter<"Board"> | string
    state?: StringNullableFilter<"Board"> | string | null
    type?: StringFilter<"Board"> | string
    is_active?: BoolFilter<"Board"> | boolean
    created_at?: DateTimeFilter<"Board"> | Date | string
    updated_at?: DateTimeFilter<"Board"> | Date | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    institutions?: InstitutionListRelationFilter
    programs?: ProgramListRelationFilter
    chunkBoards?: ChapterChunkBoardListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    country_id?: SortOrder
    state?: SortOrderInput | SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    country?: CountryOrderByWithRelationInput
    institutions?: InstitutionOrderByRelationAggregateInput
    programs?: ProgramOrderByRelationAggregateInput
    chunkBoards?: ChapterChunkBoardOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    name?: StringFilter<"Board"> | string
    country_id?: StringFilter<"Board"> | string
    state?: StringNullableFilter<"Board"> | string | null
    type?: StringFilter<"Board"> | string
    is_active?: BoolFilter<"Board"> | boolean
    created_at?: DateTimeFilter<"Board"> | Date | string
    updated_at?: DateTimeFilter<"Board"> | Date | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    institutions?: InstitutionListRelationFilter
    programs?: ProgramListRelationFilter
    chunkBoards?: ChapterChunkBoardListRelationFilter
  }, "id">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    country_id?: SortOrder
    state?: SortOrderInput | SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Board"> | string
    name?: StringWithAggregatesFilter<"Board"> | string
    country_id?: StringWithAggregatesFilter<"Board"> | string
    state?: StringNullableWithAggregatesFilter<"Board"> | string | null
    type?: StringWithAggregatesFilter<"Board"> | string
    is_active?: BoolWithAggregatesFilter<"Board"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Board"> | Date | string
  }

  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: BigIntFilter<"Institution"> | bigint | number
    board_id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    type?: StringFilter<"Institution"> | string
    district?: StringNullableFilter<"Institution"> | string | null
    state?: StringNullableFilter<"Institution"> | string | null
    license_expiry?: DateTimeNullableFilter<"Institution"> | Date | string | null
    is_active?: BoolFilter<"Institution"> | boolean
    created_at?: DateTimeFilter<"Institution"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    programs?: ProgramListRelationFilter
    profiles?: ProfileListRelationFilter
  }

  export type InstitutionOrderByWithRelationInput = {
    id?: SortOrder
    board_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    district?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    license_expiry?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    board?: BoardOrderByWithRelationInput
    programs?: ProgramOrderByRelationAggregateInput
    profiles?: ProfileOrderByRelationAggregateInput
  }

  export type InstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    board_id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    type?: StringFilter<"Institution"> | string
    district?: StringNullableFilter<"Institution"> | string | null
    state?: StringNullableFilter<"Institution"> | string | null
    license_expiry?: DateTimeNullableFilter<"Institution"> | Date | string | null
    is_active?: BoolFilter<"Institution"> | boolean
    created_at?: DateTimeFilter<"Institution"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    programs?: ProgramListRelationFilter
    profiles?: ProfileListRelationFilter
  }, "id">

  export type InstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    board_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    district?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    license_expiry?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    _count?: InstitutionCountOrderByAggregateInput
    _avg?: InstitutionAvgOrderByAggregateInput
    _max?: InstitutionMaxOrderByAggregateInput
    _min?: InstitutionMinOrderByAggregateInput
    _sum?: InstitutionSumOrderByAggregateInput
  }

  export type InstitutionScalarWhereWithAggregatesInput = {
    AND?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    OR?: InstitutionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Institution"> | bigint | number
    board_id?: StringWithAggregatesFilter<"Institution"> | string
    name?: StringWithAggregatesFilter<"Institution"> | string
    type?: StringWithAggregatesFilter<"Institution"> | string
    district?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    state?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    license_expiry?: DateTimeNullableWithAggregatesFilter<"Institution"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"Institution"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: IntFilter<"Program"> | number
    board_id?: StringFilter<"Program"> | string
    institution_id?: BigIntNullableFilter<"Program"> | bigint | number | null
    name?: StringFilter<"Program"> | string
    code?: StringNullableFilter<"Program"> | string | null
    level?: StringNullableFilter<"Program"> | string | null
    duration_years?: IntNullableFilter<"Program"> | number | null
    is_active?: BoolFilter<"Program"> | boolean
    created_at?: DateTimeFilter<"Program"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    subjects?: SubjectListRelationFilter
    profiles?: ProfileListRelationFilter
    exams?: ExamListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    board_id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    duration_years?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    board?: BoardOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    profiles?: ProfileOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    board_id_institution_id_name?: ProgramBoard_idInstitution_idNameCompoundUniqueInput
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    board_id?: StringFilter<"Program"> | string
    institution_id?: BigIntNullableFilter<"Program"> | bigint | number | null
    name?: StringFilter<"Program"> | string
    code?: StringNullableFilter<"Program"> | string | null
    level?: StringNullableFilter<"Program"> | string | null
    duration_years?: IntNullableFilter<"Program"> | number | null
    is_active?: BoolFilter<"Program"> | boolean
    created_at?: DateTimeFilter<"Program"> | Date | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    subjects?: SubjectListRelationFilter
    profiles?: ProfileListRelationFilter
    exams?: ExamListRelationFilter
  }, "id" | "board_id_institution_id_name">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    board_id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    duration_years?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Program"> | number
    board_id?: StringWithAggregatesFilter<"Program"> | string
    institution_id?: BigIntNullableWithAggregatesFilter<"Program"> | bigint | number | null
    name?: StringWithAggregatesFilter<"Program"> | string
    code?: StringNullableWithAggregatesFilter<"Program"> | string | null
    level?: StringNullableWithAggregatesFilter<"Program"> | string | null
    duration_years?: IntNullableWithAggregatesFilter<"Program"> | number | null
    is_active?: BoolWithAggregatesFilter<"Program"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: IntFilter<"Profile"> | number
    user_id?: IntFilter<"Profile"> | number
    institution_id?: BigIntNullableFilter<"Profile"> | bigint | number | null
    program_id?: IntNullableFilter<"Profile"> | number | null
    is_premium?: BoolFilter<"Profile"> | boolean
    last_sync_at?: BigIntNullableFilter<"Profile"> | bigint | number | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    program_id?: SortOrderInput | SortOrder
    is_premium?: SortOrder
    last_sync_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    institution_id?: BigIntNullableFilter<"Profile"> | bigint | number | null
    program_id?: IntNullableFilter<"Profile"> | number | null
    is_premium?: BoolFilter<"Profile"> | boolean
    last_sync_at?: BigIntNullableFilter<"Profile"> | bigint | number | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }, "id" | "user_id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrderInput | SortOrder
    program_id?: SortOrderInput | SortOrder
    is_premium?: SortOrder
    last_sync_at?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profile"> | number
    user_id?: IntWithAggregatesFilter<"Profile"> | number
    institution_id?: BigIntNullableWithAggregatesFilter<"Profile"> | bigint | number | null
    program_id?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    is_premium?: BoolWithAggregatesFilter<"Profile"> | boolean
    last_sync_at?: BigIntNullableWithAggregatesFilter<"Profile"> | bigint | number | null
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: IntFilter<"Subject"> | number
    program_id?: IntFilter<"Subject"> | number
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    is_active?: BoolFilter<"Subject"> | boolean
    created_at?: DateTimeFilter<"Subject"> | Date | string
    term?: StringNullableFilter<"Subject"> | string | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    chapters?: ChapterListRelationFilter
    quizzes?: QuizListRelationFilter
    conversations?: ConversationListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    program_id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    term?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    program_id_name?: SubjectProgram_idNameCompoundUniqueInput
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    program_id?: IntFilter<"Subject"> | number
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    is_active?: BoolFilter<"Subject"> | boolean
    created_at?: DateTimeFilter<"Subject"> | Date | string
    term?: StringNullableFilter<"Subject"> | string | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    chapters?: ChapterListRelationFilter
    quizzes?: QuizListRelationFilter
    conversations?: ConversationListRelationFilter
  }, "id" | "program_id_name">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    program_id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    term?: SortOrderInput | SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subject"> | number
    program_id?: IntWithAggregatesFilter<"Subject"> | number
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    is_active?: BoolWithAggregatesFilter<"Subject"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    term?: StringNullableWithAggregatesFilter<"Subject"> | string | null
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: BigIntFilter<"Chapter"> | bigint | number
    subject_id?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    chapter_number?: IntNullableFilter<"Chapter"> | number | null
    content_json?: JsonFilter<"Chapter">
    version_id?: StringFilter<"Chapter"> | string
    accessible_boards?: StringNullableListFilter<"Chapter">
    is_global?: BoolFilter<"Chapter"> | boolean
    is_active?: BoolFilter<"Chapter"> | boolean
    processing_status?: EnumChapterStatusFilter<"Chapter"> | $Enums.ChapterStatus
    error_message?: StringNullableFilter<"Chapter"> | string | null
    processed_at?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    created_at?: DateTimeFilter<"Chapter"> | Date | string
    updated_at?: DateTimeFilter<"Chapter"> | Date | string
    parsed_at?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chunks?: ChapterChunkListRelationFilter
    pages?: ChapterPageListRelationFilter
    quizzes?: QuizListRelationFilter
    study_materials?: XOR<StudyMaterialNullableScalarRelationFilter, StudyMaterialWhereInput> | null
    learning_sessions?: LearningSessionListRelationFilter
    conversations?: ConversationListRelationFilter
    questions?: QuestionListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    chapter_number?: SortOrderInput | SortOrder
    content_json?: SortOrder
    version_id?: SortOrder
    accessible_boards?: SortOrder
    is_global?: SortOrder
    is_active?: SortOrder
    processing_status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    processed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parsed_at?: SortOrderInput | SortOrder
    subject?: SubjectOrderByWithRelationInput
    chunks?: ChapterChunkOrderByRelationAggregateInput
    pages?: ChapterPageOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    study_materials?: StudyMaterialOrderByWithRelationInput
    learning_sessions?: LearningSessionOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    questions?: QuestionOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    subject_id?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    chapter_number?: IntNullableFilter<"Chapter"> | number | null
    content_json?: JsonFilter<"Chapter">
    version_id?: StringFilter<"Chapter"> | string
    accessible_boards?: StringNullableListFilter<"Chapter">
    is_global?: BoolFilter<"Chapter"> | boolean
    is_active?: BoolFilter<"Chapter"> | boolean
    processing_status?: EnumChapterStatusFilter<"Chapter"> | $Enums.ChapterStatus
    error_message?: StringNullableFilter<"Chapter"> | string | null
    processed_at?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    created_at?: DateTimeFilter<"Chapter"> | Date | string
    updated_at?: DateTimeFilter<"Chapter"> | Date | string
    parsed_at?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chunks?: ChapterChunkListRelationFilter
    pages?: ChapterPageListRelationFilter
    quizzes?: QuizListRelationFilter
    study_materials?: XOR<StudyMaterialNullableScalarRelationFilter, StudyMaterialWhereInput> | null
    learning_sessions?: LearningSessionListRelationFilter
    conversations?: ConversationListRelationFilter
    questions?: QuestionListRelationFilter
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    chapter_number?: SortOrderInput | SortOrder
    content_json?: SortOrder
    version_id?: SortOrder
    accessible_boards?: SortOrder
    is_global?: SortOrder
    is_active?: SortOrder
    processing_status?: SortOrder
    error_message?: SortOrderInput | SortOrder
    processed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parsed_at?: SortOrderInput | SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Chapter"> | bigint | number
    subject_id?: IntWithAggregatesFilter<"Chapter"> | number
    title?: StringWithAggregatesFilter<"Chapter"> | string
    chapter_number?: IntNullableWithAggregatesFilter<"Chapter"> | number | null
    content_json?: JsonWithAggregatesFilter<"Chapter">
    version_id?: StringWithAggregatesFilter<"Chapter"> | string
    accessible_boards?: StringNullableListFilter<"Chapter">
    is_global?: BoolWithAggregatesFilter<"Chapter"> | boolean
    is_active?: BoolWithAggregatesFilter<"Chapter"> | boolean
    processing_status?: EnumChapterStatusWithAggregatesFilter<"Chapter"> | $Enums.ChapterStatus
    error_message?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    processed_at?: DateTimeNullableWithAggregatesFilter<"Chapter"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    parsed_at?: DateTimeNullableWithAggregatesFilter<"Chapter"> | Date | string | null
  }

  export type ChapterChunkWhereInput = {
    AND?: ChapterChunkWhereInput | ChapterChunkWhereInput[]
    OR?: ChapterChunkWhereInput[]
    NOT?: ChapterChunkWhereInput | ChapterChunkWhereInput[]
    id?: BigIntFilter<"ChapterChunk"> | bigint | number
    chapter_id?: BigIntFilter<"ChapterChunk"> | bigint | number
    chunk_index?: IntFilter<"ChapterChunk"> | number
    content?: StringFilter<"ChapterChunk"> | string
    page_number?: IntNullableFilter<"ChapterChunk"> | number | null
    bbox?: JsonNullableFilter<"ChapterChunk">
    subject_id?: IntNullableFilter<"ChapterChunk"> | number | null
    created_at?: DateTimeFilter<"ChapterChunk"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    chunkBoards?: ChapterChunkBoardListRelationFilter
  }

  export type ChapterChunkOrderByWithRelationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrderInput | SortOrder
    bbox?: SortOrderInput | SortOrder
    subject_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
    chunkBoards?: ChapterChunkBoardOrderByRelationAggregateInput
  }

  export type ChapterChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ChapterChunkWhereInput | ChapterChunkWhereInput[]
    OR?: ChapterChunkWhereInput[]
    NOT?: ChapterChunkWhereInput | ChapterChunkWhereInput[]
    chapter_id?: BigIntFilter<"ChapterChunk"> | bigint | number
    chunk_index?: IntFilter<"ChapterChunk"> | number
    content?: StringFilter<"ChapterChunk"> | string
    page_number?: IntNullableFilter<"ChapterChunk"> | number | null
    bbox?: JsonNullableFilter<"ChapterChunk">
    subject_id?: IntNullableFilter<"ChapterChunk"> | number | null
    created_at?: DateTimeFilter<"ChapterChunk"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    chunkBoards?: ChapterChunkBoardListRelationFilter
  }, "id">

  export type ChapterChunkOrderByWithAggregationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrderInput | SortOrder
    bbox?: SortOrderInput | SortOrder
    subject_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ChapterChunkCountOrderByAggregateInput
    _avg?: ChapterChunkAvgOrderByAggregateInput
    _max?: ChapterChunkMaxOrderByAggregateInput
    _min?: ChapterChunkMinOrderByAggregateInput
    _sum?: ChapterChunkSumOrderByAggregateInput
  }

  export type ChapterChunkScalarWhereWithAggregatesInput = {
    AND?: ChapterChunkScalarWhereWithAggregatesInput | ChapterChunkScalarWhereWithAggregatesInput[]
    OR?: ChapterChunkScalarWhereWithAggregatesInput[]
    NOT?: ChapterChunkScalarWhereWithAggregatesInput | ChapterChunkScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ChapterChunk"> | bigint | number
    chapter_id?: BigIntWithAggregatesFilter<"ChapterChunk"> | bigint | number
    chunk_index?: IntWithAggregatesFilter<"ChapterChunk"> | number
    content?: StringWithAggregatesFilter<"ChapterChunk"> | string
    page_number?: IntNullableWithAggregatesFilter<"ChapterChunk"> | number | null
    bbox?: JsonNullableWithAggregatesFilter<"ChapterChunk">
    subject_id?: IntNullableWithAggregatesFilter<"ChapterChunk"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"ChapterChunk"> | Date | string
  }

  export type ChapterChunkBoardWhereInput = {
    AND?: ChapterChunkBoardWhereInput | ChapterChunkBoardWhereInput[]
    OR?: ChapterChunkBoardWhereInput[]
    NOT?: ChapterChunkBoardWhereInput | ChapterChunkBoardWhereInput[]
    chunk_id?: BigIntFilter<"ChapterChunkBoard"> | bigint | number
    board_id?: StringFilter<"ChapterChunkBoard"> | string
    chunk?: XOR<ChapterChunkScalarRelationFilter, ChapterChunkWhereInput>
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
  }

  export type ChapterChunkBoardOrderByWithRelationInput = {
    chunk_id?: SortOrder
    board_id?: SortOrder
    chunk?: ChapterChunkOrderByWithRelationInput
    board?: BoardOrderByWithRelationInput
  }

  export type ChapterChunkBoardWhereUniqueInput = Prisma.AtLeast<{
    chunk_id_board_id?: ChapterChunkBoardChunk_idBoard_idCompoundUniqueInput
    AND?: ChapterChunkBoardWhereInput | ChapterChunkBoardWhereInput[]
    OR?: ChapterChunkBoardWhereInput[]
    NOT?: ChapterChunkBoardWhereInput | ChapterChunkBoardWhereInput[]
    chunk_id?: BigIntFilter<"ChapterChunkBoard"> | bigint | number
    board_id?: StringFilter<"ChapterChunkBoard"> | string
    chunk?: XOR<ChapterChunkScalarRelationFilter, ChapterChunkWhereInput>
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
  }, "chunk_id_board_id">

  export type ChapterChunkBoardOrderByWithAggregationInput = {
    chunk_id?: SortOrder
    board_id?: SortOrder
    _count?: ChapterChunkBoardCountOrderByAggregateInput
    _avg?: ChapterChunkBoardAvgOrderByAggregateInput
    _max?: ChapterChunkBoardMaxOrderByAggregateInput
    _min?: ChapterChunkBoardMinOrderByAggregateInput
    _sum?: ChapterChunkBoardSumOrderByAggregateInput
  }

  export type ChapterChunkBoardScalarWhereWithAggregatesInput = {
    AND?: ChapterChunkBoardScalarWhereWithAggregatesInput | ChapterChunkBoardScalarWhereWithAggregatesInput[]
    OR?: ChapterChunkBoardScalarWhereWithAggregatesInput[]
    NOT?: ChapterChunkBoardScalarWhereWithAggregatesInput | ChapterChunkBoardScalarWhereWithAggregatesInput[]
    chunk_id?: BigIntWithAggregatesFilter<"ChapterChunkBoard"> | bigint | number
    board_id?: StringWithAggregatesFilter<"ChapterChunkBoard"> | string
  }

  export type ChapterPageWhereInput = {
    AND?: ChapterPageWhereInput | ChapterPageWhereInput[]
    OR?: ChapterPageWhereInput[]
    NOT?: ChapterPageWhereInput | ChapterPageWhereInput[]
    id?: BigIntFilter<"ChapterPage"> | bigint | number
    chapter_id?: BigIntFilter<"ChapterPage"> | bigint | number
    page_number?: IntFilter<"ChapterPage"> | number
    image_url?: StringFilter<"ChapterPage"> | string
    width?: IntNullableFilter<"ChapterPage"> | number | null
    height?: IntNullableFilter<"ChapterPage"> | number | null
    created_at?: DateTimeFilter<"ChapterPage"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type ChapterPageOrderByWithRelationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    created_at?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
  }

  export type ChapterPageWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ChapterPageWhereInput | ChapterPageWhereInput[]
    OR?: ChapterPageWhereInput[]
    NOT?: ChapterPageWhereInput | ChapterPageWhereInput[]
    chapter_id?: BigIntFilter<"ChapterPage"> | bigint | number
    page_number?: IntFilter<"ChapterPage"> | number
    image_url?: StringFilter<"ChapterPage"> | string
    width?: IntNullableFilter<"ChapterPage"> | number | null
    height?: IntNullableFilter<"ChapterPage"> | number | null
    created_at?: DateTimeFilter<"ChapterPage"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "id">

  export type ChapterPageOrderByWithAggregationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ChapterPageCountOrderByAggregateInput
    _avg?: ChapterPageAvgOrderByAggregateInput
    _max?: ChapterPageMaxOrderByAggregateInput
    _min?: ChapterPageMinOrderByAggregateInput
    _sum?: ChapterPageSumOrderByAggregateInput
  }

  export type ChapterPageScalarWhereWithAggregatesInput = {
    AND?: ChapterPageScalarWhereWithAggregatesInput | ChapterPageScalarWhereWithAggregatesInput[]
    OR?: ChapterPageScalarWhereWithAggregatesInput[]
    NOT?: ChapterPageScalarWhereWithAggregatesInput | ChapterPageScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ChapterPage"> | bigint | number
    chapter_id?: BigIntWithAggregatesFilter<"ChapterPage"> | bigint | number
    page_number?: IntWithAggregatesFilter<"ChapterPage"> | number
    image_url?: StringWithAggregatesFilter<"ChapterPage"> | string
    width?: IntNullableWithAggregatesFilter<"ChapterPage"> | number | null
    height?: IntNullableWithAggregatesFilter<"ChapterPage"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"ChapterPage"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    type?: StringFilter<"SystemSetting"> | string
    created_at?: DateTimeFilter<"SystemSetting"> | Date | string
    updated_at?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    type?: StringFilter<"SystemSetting"> | string
    created_at?: DateTimeFilter<"SystemSetting"> | Date | string
    updated_at?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _avg?: SystemSettingAvgOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
    _sum?: SystemSettingSumOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSetting"> | number
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    type?: StringWithAggregatesFilter<"SystemSetting"> | string
    created_at?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    user_id?: IntFilter<"Quiz"> | number
    subject_id?: IntFilter<"Quiz"> | number
    chapter_id?: BigIntNullableFilter<"Quiz"> | bigint | number | null
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    status?: EnumQuizStatusFilter<"Quiz"> | $Enums.QuizStatus
    score?: IntFilter<"Quiz"> | number
    total_points?: IntFilter<"Quiz"> | number
    created_at?: DateTimeFilter<"Quiz"> | Date | string
    updated_at?: DateTimeFilter<"Quiz"> | Date | string
    completed_at?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chapter?: XOR<ChapterNullableScalarRelationFilter, ChapterWhereInput> | null
    questions?: QuizQuestionListRelationFilter
    battles?: BattleListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
    questions?: QuizQuestionOrderByRelationAggregateInput
    battles?: BattleOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    user_id?: IntFilter<"Quiz"> | number
    subject_id?: IntFilter<"Quiz"> | number
    chapter_id?: BigIntNullableFilter<"Quiz"> | bigint | number | null
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    status?: EnumQuizStatusFilter<"Quiz"> | $Enums.QuizStatus
    score?: IntFilter<"Quiz"> | number
    total_points?: IntFilter<"Quiz"> | number
    created_at?: DateTimeFilter<"Quiz"> | Date | string
    updated_at?: DateTimeFilter<"Quiz"> | Date | string
    completed_at?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chapter?: XOR<ChapterNullableScalarRelationFilter, ChapterWhereInput> | null
    questions?: QuizQuestionListRelationFilter
    battles?: BattleListRelationFilter
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    user_id?: IntWithAggregatesFilter<"Quiz"> | number
    subject_id?: IntWithAggregatesFilter<"Quiz"> | number
    chapter_id?: BigIntNullableWithAggregatesFilter<"Quiz"> | bigint | number | null
    title?: StringWithAggregatesFilter<"Quiz"> | string
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    status?: EnumQuizStatusWithAggregatesFilter<"Quiz"> | $Enums.QuizStatus
    score?: IntWithAggregatesFilter<"Quiz"> | number
    total_points?: IntWithAggregatesFilter<"Quiz"> | number
    created_at?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    quiz_id?: StringFilter<"QuizQuestion"> | string
    question_text?: StringFilter<"QuizQuestion"> | string
    question_type?: EnumQuestionTypeFilter<"QuizQuestion"> | $Enums.QuestionType
    options?: JsonNullableFilter<"QuizQuestion">
    correct_answer?: JsonFilter<"QuizQuestion">
    user_answer?: JsonNullableFilter<"QuizQuestion">
    is_correct?: BoolNullableFilter<"QuizQuestion"> | boolean | null
    points?: IntFilter<"QuizQuestion"> | number
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    feedback?: StringNullableFilter<"QuizQuestion"> | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    user_answer?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    points?: SortOrder
    explanation?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    quiz_id?: StringFilter<"QuizQuestion"> | string
    question_text?: StringFilter<"QuizQuestion"> | string
    question_type?: EnumQuestionTypeFilter<"QuizQuestion"> | $Enums.QuestionType
    options?: JsonNullableFilter<"QuizQuestion">
    correct_answer?: JsonFilter<"QuizQuestion">
    user_answer?: JsonNullableFilter<"QuizQuestion">
    is_correct?: BoolNullableFilter<"QuizQuestion"> | boolean | null
    points?: IntFilter<"QuizQuestion"> | number
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    feedback?: StringNullableFilter<"QuizQuestion"> | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    user_answer?: SortOrderInput | SortOrder
    is_correct?: SortOrderInput | SortOrder
    points?: SortOrder
    explanation?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizQuestion"> | string
    quiz_id?: StringWithAggregatesFilter<"QuizQuestion"> | string
    question_text?: StringWithAggregatesFilter<"QuizQuestion"> | string
    question_type?: EnumQuestionTypeWithAggregatesFilter<"QuizQuestion"> | $Enums.QuestionType
    options?: JsonNullableWithAggregatesFilter<"QuizQuestion">
    correct_answer?: JsonWithAggregatesFilter<"QuizQuestion">
    user_answer?: JsonNullableWithAggregatesFilter<"QuizQuestion">
    is_correct?: BoolNullableWithAggregatesFilter<"QuizQuestion"> | boolean | null
    points?: IntWithAggregatesFilter<"QuizQuestion"> | number
    explanation?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    feedback?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    chapter_id?: BigIntFilter<"Question"> | bigint | number
    question_text?: StringFilter<"Question"> | string
    question_type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    difficulty?: StringFilter<"Question"> | string
    options?: JsonNullableFilter<"Question">
    correct_answer?: JsonFilter<"Question">
    explanation?: StringNullableFilter<"Question"> | string | null
    points?: IntFilter<"Question"> | number
    is_active?: BoolFilter<"Question"> | boolean
    created_at?: DateTimeFilter<"Question"> | Date | string
    updated_at?: DateTimeFilter<"Question"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    difficulty?: SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    explanation?: SortOrderInput | SortOrder
    points?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    chapter_id?: BigIntFilter<"Question"> | bigint | number
    question_text?: StringFilter<"Question"> | string
    question_type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    difficulty?: StringFilter<"Question"> | string
    options?: JsonNullableFilter<"Question">
    correct_answer?: JsonFilter<"Question">
    explanation?: StringNullableFilter<"Question"> | string | null
    points?: IntFilter<"Question"> | number
    is_active?: BoolFilter<"Question"> | boolean
    created_at?: DateTimeFilter<"Question"> | Date | string
    updated_at?: DateTimeFilter<"Question"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    difficulty?: SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    explanation?: SortOrderInput | SortOrder
    points?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    chapter_id?: BigIntWithAggregatesFilter<"Question"> | bigint | number
    question_text?: StringWithAggregatesFilter<"Question"> | string
    question_type?: EnumQuestionTypeWithAggregatesFilter<"Question"> | $Enums.QuestionType
    difficulty?: StringWithAggregatesFilter<"Question"> | string
    options?: JsonNullableWithAggregatesFilter<"Question">
    correct_answer?: JsonWithAggregatesFilter<"Question">
    explanation?: StringNullableWithAggregatesFilter<"Question"> | string | null
    points?: IntWithAggregatesFilter<"Question"> | number
    is_active?: BoolWithAggregatesFilter<"Question"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type UserPointsWhereInput = {
    AND?: UserPointsWhereInput | UserPointsWhereInput[]
    OR?: UserPointsWhereInput[]
    NOT?: UserPointsWhereInput | UserPointsWhereInput[]
    id?: StringFilter<"UserPoints"> | string
    user_id?: IntFilter<"UserPoints"> | number
    points?: IntFilter<"UserPoints"> | number
    reason?: StringFilter<"UserPoints"> | string
    metadata?: JsonNullableFilter<"UserPoints">
    created_at?: DateTimeFilter<"UserPoints"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type UserPointsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type UserPointsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPointsWhereInput | UserPointsWhereInput[]
    OR?: UserPointsWhereInput[]
    NOT?: UserPointsWhereInput | UserPointsWhereInput[]
    user_id?: IntFilter<"UserPoints"> | number
    points?: IntFilter<"UserPoints"> | number
    reason?: StringFilter<"UserPoints"> | string
    metadata?: JsonNullableFilter<"UserPoints">
    created_at?: DateTimeFilter<"UserPoints"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type UserPointsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UserPointsCountOrderByAggregateInput
    _avg?: UserPointsAvgOrderByAggregateInput
    _max?: UserPointsMaxOrderByAggregateInput
    _min?: UserPointsMinOrderByAggregateInput
    _sum?: UserPointsSumOrderByAggregateInput
  }

  export type UserPointsScalarWhereWithAggregatesInput = {
    AND?: UserPointsScalarWhereWithAggregatesInput | UserPointsScalarWhereWithAggregatesInput[]
    OR?: UserPointsScalarWhereWithAggregatesInput[]
    NOT?: UserPointsScalarWhereWithAggregatesInput | UserPointsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPoints"> | string
    user_id?: IntWithAggregatesFilter<"UserPoints"> | number
    points?: IntWithAggregatesFilter<"UserPoints"> | number
    reason?: StringWithAggregatesFilter<"UserPoints"> | string
    metadata?: JsonNullableWithAggregatesFilter<"UserPoints">
    created_at?: DateTimeWithAggregatesFilter<"UserPoints"> | Date | string
  }

  export type StudyMaterialWhereInput = {
    AND?: StudyMaterialWhereInput | StudyMaterialWhereInput[]
    OR?: StudyMaterialWhereInput[]
    NOT?: StudyMaterialWhereInput | StudyMaterialWhereInput[]
    id?: BigIntFilter<"StudyMaterial"> | bigint | number
    chapter_id?: BigIntFilter<"StudyMaterial"> | bigint | number
    summary?: JsonNullableFilter<"StudyMaterial">
    definitions?: JsonNullableFilter<"StudyMaterial">
    flashcards?: JsonNullableFilter<"StudyMaterial">
    mind_map?: StringNullableFilter<"StudyMaterial"> | string | null
    video_queries?: StringNullableListFilter<"StudyMaterial">
    curated_videos?: JsonNullableFilter<"StudyMaterial">
    created_at?: DateTimeFilter<"StudyMaterial"> | Date | string
    updated_at?: DateTimeFilter<"StudyMaterial"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type StudyMaterialOrderByWithRelationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    summary?: SortOrderInput | SortOrder
    definitions?: SortOrderInput | SortOrder
    flashcards?: SortOrderInput | SortOrder
    mind_map?: SortOrderInput | SortOrder
    video_queries?: SortOrder
    curated_videos?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
  }

  export type StudyMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    chapter_id?: bigint | number
    AND?: StudyMaterialWhereInput | StudyMaterialWhereInput[]
    OR?: StudyMaterialWhereInput[]
    NOT?: StudyMaterialWhereInput | StudyMaterialWhereInput[]
    summary?: JsonNullableFilter<"StudyMaterial">
    definitions?: JsonNullableFilter<"StudyMaterial">
    flashcards?: JsonNullableFilter<"StudyMaterial">
    mind_map?: StringNullableFilter<"StudyMaterial"> | string | null
    video_queries?: StringNullableListFilter<"StudyMaterial">
    curated_videos?: JsonNullableFilter<"StudyMaterial">
    created_at?: DateTimeFilter<"StudyMaterial"> | Date | string
    updated_at?: DateTimeFilter<"StudyMaterial"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "id" | "chapter_id">

  export type StudyMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    summary?: SortOrderInput | SortOrder
    definitions?: SortOrderInput | SortOrder
    flashcards?: SortOrderInput | SortOrder
    mind_map?: SortOrderInput | SortOrder
    video_queries?: SortOrder
    curated_videos?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StudyMaterialCountOrderByAggregateInput
    _avg?: StudyMaterialAvgOrderByAggregateInput
    _max?: StudyMaterialMaxOrderByAggregateInput
    _min?: StudyMaterialMinOrderByAggregateInput
    _sum?: StudyMaterialSumOrderByAggregateInput
  }

  export type StudyMaterialScalarWhereWithAggregatesInput = {
    AND?: StudyMaterialScalarWhereWithAggregatesInput | StudyMaterialScalarWhereWithAggregatesInput[]
    OR?: StudyMaterialScalarWhereWithAggregatesInput[]
    NOT?: StudyMaterialScalarWhereWithAggregatesInput | StudyMaterialScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StudyMaterial"> | bigint | number
    chapter_id?: BigIntWithAggregatesFilter<"StudyMaterial"> | bigint | number
    summary?: JsonNullableWithAggregatesFilter<"StudyMaterial">
    definitions?: JsonNullableWithAggregatesFilter<"StudyMaterial">
    flashcards?: JsonNullableWithAggregatesFilter<"StudyMaterial">
    mind_map?: StringNullableWithAggregatesFilter<"StudyMaterial"> | string | null
    video_queries?: StringNullableListFilter<"StudyMaterial">
    curated_videos?: JsonNullableWithAggregatesFilter<"StudyMaterial">
    created_at?: DateTimeWithAggregatesFilter<"StudyMaterial"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"StudyMaterial"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    date?: DateTimeFilter<"Exam"> | Date | string
    program_id?: IntNullableFilter<"Exam"> | number | null
    is_active?: BoolFilter<"Exam"> | boolean
    created_at?: DateTimeFilter<"Exam"> | Date | string
    updated_at?: DateTimeFilter<"Exam"> | Date | string
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    program_id?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program?: ProgramOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    date?: DateTimeFilter<"Exam"> | Date | string
    program_id?: IntNullableFilter<"Exam"> | number | null
    is_active?: BoolFilter<"Exam"> | boolean
    created_at?: DateTimeFilter<"Exam"> | Date | string
    updated_at?: DateTimeFilter<"Exam"> | Date | string
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    program_id?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    description?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    program_id?: IntNullableWithAggregatesFilter<"Exam"> | number | null
    is_active?: BoolWithAggregatesFilter<"Exam"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type StreakBadgeWhereInput = {
    AND?: StreakBadgeWhereInput | StreakBadgeWhereInput[]
    OR?: StreakBadgeWhereInput[]
    NOT?: StreakBadgeWhereInput | StreakBadgeWhereInput[]
    id?: StringFilter<"StreakBadge"> | string
    name?: StringFilter<"StreakBadge"> | string
    icon?: StringFilter<"StreakBadge"> | string
    min_streak?: IntFilter<"StreakBadge"> | number
    is_active?: BoolFilter<"StreakBadge"> | boolean
    created_at?: DateTimeFilter<"StreakBadge"> | Date | string
    updated_at?: DateTimeFilter<"StreakBadge"> | Date | string
    user_badges?: UserBadgeListRelationFilter
  }

  export type StreakBadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    min_streak?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_badges?: UserBadgeOrderByRelationAggregateInput
  }

  export type StreakBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    min_streak?: number
    AND?: StreakBadgeWhereInput | StreakBadgeWhereInput[]
    OR?: StreakBadgeWhereInput[]
    NOT?: StreakBadgeWhereInput | StreakBadgeWhereInput[]
    name?: StringFilter<"StreakBadge"> | string
    icon?: StringFilter<"StreakBadge"> | string
    is_active?: BoolFilter<"StreakBadge"> | boolean
    created_at?: DateTimeFilter<"StreakBadge"> | Date | string
    updated_at?: DateTimeFilter<"StreakBadge"> | Date | string
    user_badges?: UserBadgeListRelationFilter
  }, "id" | "min_streak">

  export type StreakBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    min_streak?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StreakBadgeCountOrderByAggregateInput
    _avg?: StreakBadgeAvgOrderByAggregateInput
    _max?: StreakBadgeMaxOrderByAggregateInput
    _min?: StreakBadgeMinOrderByAggregateInput
    _sum?: StreakBadgeSumOrderByAggregateInput
  }

  export type StreakBadgeScalarWhereWithAggregatesInput = {
    AND?: StreakBadgeScalarWhereWithAggregatesInput | StreakBadgeScalarWhereWithAggregatesInput[]
    OR?: StreakBadgeScalarWhereWithAggregatesInput[]
    NOT?: StreakBadgeScalarWhereWithAggregatesInput | StreakBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StreakBadge"> | string
    name?: StringWithAggregatesFilter<"StreakBadge"> | string
    icon?: StringWithAggregatesFilter<"StreakBadge"> | string
    min_streak?: IntWithAggregatesFilter<"StreakBadge"> | number
    is_active?: BoolWithAggregatesFilter<"StreakBadge"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"StreakBadge"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"StreakBadge"> | Date | string
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    user_id?: IntFilter<"UserBadge"> | number
    badge_id?: StringFilter<"UserBadge"> | string
    earned_at?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    badge?: XOR<StreakBadgeScalarRelationFilter, StreakBadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    badge_id?: SortOrder
    earned_at?: SortOrder
    user?: userOrderByWithRelationInput
    badge?: StreakBadgeOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_badge_id?: UserBadgeUser_idBadge_idCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    user_id?: IntFilter<"UserBadge"> | number
    badge_id?: StringFilter<"UserBadge"> | string
    earned_at?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    badge?: XOR<StreakBadgeScalarRelationFilter, StreakBadgeWhereInput>
  }, "id" | "user_id_badge_id">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    badge_id?: SortOrder
    earned_at?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _avg?: UserBadgeAvgOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
    _sum?: UserBadgeSumOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    user_id?: IntWithAggregatesFilter<"UserBadge"> | number
    badge_id?: StringWithAggregatesFilter<"UserBadge"> | string
    earned_at?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type LearningSessionWhereInput = {
    AND?: LearningSessionWhereInput | LearningSessionWhereInput[]
    OR?: LearningSessionWhereInput[]
    NOT?: LearningSessionWhereInput | LearningSessionWhereInput[]
    id?: StringFilter<"LearningSession"> | string
    user_id?: IntFilter<"LearningSession"> | number
    chapter_id?: BigIntFilter<"LearningSession"> | bigint | number
    status?: StringFilter<"LearningSession"> | string
    current_topic?: StringNullableFilter<"LearningSession"> | string | null
    progress?: IntFilter<"LearningSession"> | number
    created_at?: DateTimeFilter<"LearningSession"> | Date | string
    updated_at?: DateTimeFilter<"LearningSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type LearningSessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    status?: SortOrder
    current_topic?: SortOrderInput | SortOrder
    progress?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
  }

  export type LearningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningSessionWhereInput | LearningSessionWhereInput[]
    OR?: LearningSessionWhereInput[]
    NOT?: LearningSessionWhereInput | LearningSessionWhereInput[]
    user_id?: IntFilter<"LearningSession"> | number
    chapter_id?: BigIntFilter<"LearningSession"> | bigint | number
    status?: StringFilter<"LearningSession"> | string
    current_topic?: StringNullableFilter<"LearningSession"> | string | null
    progress?: IntFilter<"LearningSession"> | number
    created_at?: DateTimeFilter<"LearningSession"> | Date | string
    updated_at?: DateTimeFilter<"LearningSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "id">

  export type LearningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    status?: SortOrder
    current_topic?: SortOrderInput | SortOrder
    progress?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: LearningSessionCountOrderByAggregateInput
    _avg?: LearningSessionAvgOrderByAggregateInput
    _max?: LearningSessionMaxOrderByAggregateInput
    _min?: LearningSessionMinOrderByAggregateInput
    _sum?: LearningSessionSumOrderByAggregateInput
  }

  export type LearningSessionScalarWhereWithAggregatesInput = {
    AND?: LearningSessionScalarWhereWithAggregatesInput | LearningSessionScalarWhereWithAggregatesInput[]
    OR?: LearningSessionScalarWhereWithAggregatesInput[]
    NOT?: LearningSessionScalarWhereWithAggregatesInput | LearningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningSession"> | string
    user_id?: IntWithAggregatesFilter<"LearningSession"> | number
    chapter_id?: BigIntWithAggregatesFilter<"LearningSession"> | bigint | number
    status?: StringWithAggregatesFilter<"LearningSession"> | string
    current_topic?: StringNullableWithAggregatesFilter<"LearningSession"> | string | null
    progress?: IntWithAggregatesFilter<"LearningSession"> | number
    created_at?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"LearningSession"> | Date | string
  }

  export type BattleWhereInput = {
    AND?: BattleWhereInput | BattleWhereInput[]
    OR?: BattleWhereInput[]
    NOT?: BattleWhereInput | BattleWhereInput[]
    id?: StringFilter<"Battle"> | string
    quiz_id?: StringFilter<"Battle"> | string
    code?: StringFilter<"Battle"> | string
    status?: EnumBattleStatusFilter<"Battle"> | $Enums.BattleStatus
    created_by?: IntFilter<"Battle"> | number
    created_at?: DateTimeFilter<"Battle"> | Date | string
    started_at?: DateTimeNullableFilter<"Battle"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"Battle"> | Date | string | null
    settings?: JsonNullableFilter<"Battle">
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    participants?: BattleParticipantListRelationFilter
  }

  export type BattleOrderByWithRelationInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    ended_at?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
    creator?: userOrderByWithRelationInput
    participants?: BattleParticipantOrderByRelationAggregateInput
  }

  export type BattleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BattleWhereInput | BattleWhereInput[]
    OR?: BattleWhereInput[]
    NOT?: BattleWhereInput | BattleWhereInput[]
    quiz_id?: StringFilter<"Battle"> | string
    status?: EnumBattleStatusFilter<"Battle"> | $Enums.BattleStatus
    created_by?: IntFilter<"Battle"> | number
    created_at?: DateTimeFilter<"Battle"> | Date | string
    started_at?: DateTimeNullableFilter<"Battle"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"Battle"> | Date | string | null
    settings?: JsonNullableFilter<"Battle">
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    participants?: BattleParticipantListRelationFilter
  }, "id" | "code">

  export type BattleOrderByWithAggregationInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    ended_at?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    _count?: BattleCountOrderByAggregateInput
    _avg?: BattleAvgOrderByAggregateInput
    _max?: BattleMaxOrderByAggregateInput
    _min?: BattleMinOrderByAggregateInput
    _sum?: BattleSumOrderByAggregateInput
  }

  export type BattleScalarWhereWithAggregatesInput = {
    AND?: BattleScalarWhereWithAggregatesInput | BattleScalarWhereWithAggregatesInput[]
    OR?: BattleScalarWhereWithAggregatesInput[]
    NOT?: BattleScalarWhereWithAggregatesInput | BattleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Battle"> | string
    quiz_id?: StringWithAggregatesFilter<"Battle"> | string
    code?: StringWithAggregatesFilter<"Battle"> | string
    status?: EnumBattleStatusWithAggregatesFilter<"Battle"> | $Enums.BattleStatus
    created_by?: IntWithAggregatesFilter<"Battle"> | number
    created_at?: DateTimeWithAggregatesFilter<"Battle"> | Date | string
    started_at?: DateTimeNullableWithAggregatesFilter<"Battle"> | Date | string | null
    ended_at?: DateTimeNullableWithAggregatesFilter<"Battle"> | Date | string | null
    settings?: JsonNullableWithAggregatesFilter<"Battle">
  }

  export type BattleParticipantWhereInput = {
    AND?: BattleParticipantWhereInput | BattleParticipantWhereInput[]
    OR?: BattleParticipantWhereInput[]
    NOT?: BattleParticipantWhereInput | BattleParticipantWhereInput[]
    id?: StringFilter<"BattleParticipant"> | string
    battle_id?: StringFilter<"BattleParticipant"> | string
    user_id?: IntFilter<"BattleParticipant"> | number
    score?: IntFilter<"BattleParticipant"> | number
    current_q_index?: IntFilter<"BattleParticipant"> | number
    finished?: BoolFilter<"BattleParticipant"> | boolean
    joined_at?: DateTimeFilter<"BattleParticipant"> | Date | string
    last_active?: DateTimeFilter<"BattleParticipant"> | Date | string
    battle?: XOR<BattleScalarRelationFilter, BattleWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type BattleParticipantOrderByWithRelationInput = {
    id?: SortOrder
    battle_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
    finished?: SortOrder
    joined_at?: SortOrder
    last_active?: SortOrder
    battle?: BattleOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type BattleParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    battle_id_user_id?: BattleParticipantBattle_idUser_idCompoundUniqueInput
    AND?: BattleParticipantWhereInput | BattleParticipantWhereInput[]
    OR?: BattleParticipantWhereInput[]
    NOT?: BattleParticipantWhereInput | BattleParticipantWhereInput[]
    battle_id?: StringFilter<"BattleParticipant"> | string
    user_id?: IntFilter<"BattleParticipant"> | number
    score?: IntFilter<"BattleParticipant"> | number
    current_q_index?: IntFilter<"BattleParticipant"> | number
    finished?: BoolFilter<"BattleParticipant"> | boolean
    joined_at?: DateTimeFilter<"BattleParticipant"> | Date | string
    last_active?: DateTimeFilter<"BattleParticipant"> | Date | string
    battle?: XOR<BattleScalarRelationFilter, BattleWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "battle_id_user_id">

  export type BattleParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    battle_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
    finished?: SortOrder
    joined_at?: SortOrder
    last_active?: SortOrder
    _count?: BattleParticipantCountOrderByAggregateInput
    _avg?: BattleParticipantAvgOrderByAggregateInput
    _max?: BattleParticipantMaxOrderByAggregateInput
    _min?: BattleParticipantMinOrderByAggregateInput
    _sum?: BattleParticipantSumOrderByAggregateInput
  }

  export type BattleParticipantScalarWhereWithAggregatesInput = {
    AND?: BattleParticipantScalarWhereWithAggregatesInput | BattleParticipantScalarWhereWithAggregatesInput[]
    OR?: BattleParticipantScalarWhereWithAggregatesInput[]
    NOT?: BattleParticipantScalarWhereWithAggregatesInput | BattleParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BattleParticipant"> | string
    battle_id?: StringWithAggregatesFilter<"BattleParticipant"> | string
    user_id?: IntWithAggregatesFilter<"BattleParticipant"> | number
    score?: IntWithAggregatesFilter<"BattleParticipant"> | number
    current_q_index?: IntWithAggregatesFilter<"BattleParticipant"> | number
    finished?: BoolWithAggregatesFilter<"BattleParticipant"> | boolean
    joined_at?: DateTimeWithAggregatesFilter<"BattleParticipant"> | Date | string
    last_active?: DateTimeWithAggregatesFilter<"BattleParticipant"> | Date | string
  }

  export type SyllabusWhereInput = {
    AND?: SyllabusWhereInput | SyllabusWhereInput[]
    OR?: SyllabusWhereInput[]
    NOT?: SyllabusWhereInput | SyllabusWhereInput[]
    id?: IntFilter<"Syllabus"> | number
    title?: StringFilter<"Syllabus"> | string
    description?: StringNullableFilter<"Syllabus"> | string | null
    board?: StringFilter<"Syllabus"> | string
    class_level?: StringFilter<"Syllabus"> | string
    stream?: StringNullableFilter<"Syllabus"> | string | null
    subject?: StringFilter<"Syllabus"> | string
    academic_year?: StringNullableFilter<"Syllabus"> | string | null
    raw_text?: StringNullableFilter<"Syllabus"> | string | null
    status?: EnumSyllabusStatusFilter<"Syllabus"> | $Enums.SyllabusStatus
    created_at?: DateTimeFilter<"Syllabus"> | Date | string
    updated_at?: DateTimeFilter<"Syllabus"> | Date | string
    units?: SyllabusUnitListRelationFilter
    textbooks?: TextbookListRelationFilter
  }

  export type SyllabusOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    board?: SortOrder
    class_level?: SortOrder
    stream?: SortOrderInput | SortOrder
    subject?: SortOrder
    academic_year?: SortOrderInput | SortOrder
    raw_text?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    units?: SyllabusUnitOrderByRelationAggregateInput
    textbooks?: TextbookOrderByRelationAggregateInput
  }

  export type SyllabusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SyllabusWhereInput | SyllabusWhereInput[]
    OR?: SyllabusWhereInput[]
    NOT?: SyllabusWhereInput | SyllabusWhereInput[]
    title?: StringFilter<"Syllabus"> | string
    description?: StringNullableFilter<"Syllabus"> | string | null
    board?: StringFilter<"Syllabus"> | string
    class_level?: StringFilter<"Syllabus"> | string
    stream?: StringNullableFilter<"Syllabus"> | string | null
    subject?: StringFilter<"Syllabus"> | string
    academic_year?: StringNullableFilter<"Syllabus"> | string | null
    raw_text?: StringNullableFilter<"Syllabus"> | string | null
    status?: EnumSyllabusStatusFilter<"Syllabus"> | $Enums.SyllabusStatus
    created_at?: DateTimeFilter<"Syllabus"> | Date | string
    updated_at?: DateTimeFilter<"Syllabus"> | Date | string
    units?: SyllabusUnitListRelationFilter
    textbooks?: TextbookListRelationFilter
  }, "id">

  export type SyllabusOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    board?: SortOrder
    class_level?: SortOrder
    stream?: SortOrderInput | SortOrder
    subject?: SortOrder
    academic_year?: SortOrderInput | SortOrder
    raw_text?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SyllabusCountOrderByAggregateInput
    _avg?: SyllabusAvgOrderByAggregateInput
    _max?: SyllabusMaxOrderByAggregateInput
    _min?: SyllabusMinOrderByAggregateInput
    _sum?: SyllabusSumOrderByAggregateInput
  }

  export type SyllabusScalarWhereWithAggregatesInput = {
    AND?: SyllabusScalarWhereWithAggregatesInput | SyllabusScalarWhereWithAggregatesInput[]
    OR?: SyllabusScalarWhereWithAggregatesInput[]
    NOT?: SyllabusScalarWhereWithAggregatesInput | SyllabusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Syllabus"> | number
    title?: StringWithAggregatesFilter<"Syllabus"> | string
    description?: StringNullableWithAggregatesFilter<"Syllabus"> | string | null
    board?: StringWithAggregatesFilter<"Syllabus"> | string
    class_level?: StringWithAggregatesFilter<"Syllabus"> | string
    stream?: StringNullableWithAggregatesFilter<"Syllabus"> | string | null
    subject?: StringWithAggregatesFilter<"Syllabus"> | string
    academic_year?: StringNullableWithAggregatesFilter<"Syllabus"> | string | null
    raw_text?: StringNullableWithAggregatesFilter<"Syllabus"> | string | null
    status?: EnumSyllabusStatusWithAggregatesFilter<"Syllabus"> | $Enums.SyllabusStatus
    created_at?: DateTimeWithAggregatesFilter<"Syllabus"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Syllabus"> | Date | string
  }

  export type SyllabusUnitWhereInput = {
    AND?: SyllabusUnitWhereInput | SyllabusUnitWhereInput[]
    OR?: SyllabusUnitWhereInput[]
    NOT?: SyllabusUnitWhereInput | SyllabusUnitWhereInput[]
    id?: IntFilter<"SyllabusUnit"> | number
    syllabus_id?: IntFilter<"SyllabusUnit"> | number
    title?: StringFilter<"SyllabusUnit"> | string
    order?: IntFilter<"SyllabusUnit"> | number
    description?: StringNullableFilter<"SyllabusUnit"> | string | null
    syllabus?: XOR<SyllabusScalarRelationFilter, SyllabusWhereInput>
    chapters?: SyllabusChapterListRelationFilter
  }

  export type SyllabusUnitOrderByWithRelationInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrderInput | SortOrder
    syllabus?: SyllabusOrderByWithRelationInput
    chapters?: SyllabusChapterOrderByRelationAggregateInput
  }

  export type SyllabusUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    syllabus_id_order?: SyllabusUnitSyllabus_idOrderCompoundUniqueInput
    AND?: SyllabusUnitWhereInput | SyllabusUnitWhereInput[]
    OR?: SyllabusUnitWhereInput[]
    NOT?: SyllabusUnitWhereInput | SyllabusUnitWhereInput[]
    syllabus_id?: IntFilter<"SyllabusUnit"> | number
    title?: StringFilter<"SyllabusUnit"> | string
    order?: IntFilter<"SyllabusUnit"> | number
    description?: StringNullableFilter<"SyllabusUnit"> | string | null
    syllabus?: XOR<SyllabusScalarRelationFilter, SyllabusWhereInput>
    chapters?: SyllabusChapterListRelationFilter
  }, "id" | "syllabus_id_order">

  export type SyllabusUnitOrderByWithAggregationInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SyllabusUnitCountOrderByAggregateInput
    _avg?: SyllabusUnitAvgOrderByAggregateInput
    _max?: SyllabusUnitMaxOrderByAggregateInput
    _min?: SyllabusUnitMinOrderByAggregateInput
    _sum?: SyllabusUnitSumOrderByAggregateInput
  }

  export type SyllabusUnitScalarWhereWithAggregatesInput = {
    AND?: SyllabusUnitScalarWhereWithAggregatesInput | SyllabusUnitScalarWhereWithAggregatesInput[]
    OR?: SyllabusUnitScalarWhereWithAggregatesInput[]
    NOT?: SyllabusUnitScalarWhereWithAggregatesInput | SyllabusUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyllabusUnit"> | number
    syllabus_id?: IntWithAggregatesFilter<"SyllabusUnit"> | number
    title?: StringWithAggregatesFilter<"SyllabusUnit"> | string
    order?: IntWithAggregatesFilter<"SyllabusUnit"> | number
    description?: StringNullableWithAggregatesFilter<"SyllabusUnit"> | string | null
  }

  export type SyllabusChapterWhereInput = {
    AND?: SyllabusChapterWhereInput | SyllabusChapterWhereInput[]
    OR?: SyllabusChapterWhereInput[]
    NOT?: SyllabusChapterWhereInput | SyllabusChapterWhereInput[]
    id?: IntFilter<"SyllabusChapter"> | number
    unit_id?: IntFilter<"SyllabusChapter"> | number
    chapter_number?: StringFilter<"SyllabusChapter"> | string
    title?: StringFilter<"SyllabusChapter"> | string
    order?: IntFilter<"SyllabusChapter"> | number
    subtopics?: JsonNullableFilter<"SyllabusChapter">
    unit?: XOR<SyllabusUnitScalarRelationFilter, SyllabusUnitWhereInput>
  }

  export type SyllabusChapterOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    subtopics?: SortOrderInput | SortOrder
    unit?: SyllabusUnitOrderByWithRelationInput
  }

  export type SyllabusChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    unit_id_order?: SyllabusChapterUnit_idOrderCompoundUniqueInput
    AND?: SyllabusChapterWhereInput | SyllabusChapterWhereInput[]
    OR?: SyllabusChapterWhereInput[]
    NOT?: SyllabusChapterWhereInput | SyllabusChapterWhereInput[]
    unit_id?: IntFilter<"SyllabusChapter"> | number
    chapter_number?: StringFilter<"SyllabusChapter"> | string
    title?: StringFilter<"SyllabusChapter"> | string
    order?: IntFilter<"SyllabusChapter"> | number
    subtopics?: JsonNullableFilter<"SyllabusChapter">
    unit?: XOR<SyllabusUnitScalarRelationFilter, SyllabusUnitWhereInput>
  }, "id" | "unit_id_order">

  export type SyllabusChapterOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    subtopics?: SortOrderInput | SortOrder
    _count?: SyllabusChapterCountOrderByAggregateInput
    _avg?: SyllabusChapterAvgOrderByAggregateInput
    _max?: SyllabusChapterMaxOrderByAggregateInput
    _min?: SyllabusChapterMinOrderByAggregateInput
    _sum?: SyllabusChapterSumOrderByAggregateInput
  }

  export type SyllabusChapterScalarWhereWithAggregatesInput = {
    AND?: SyllabusChapterScalarWhereWithAggregatesInput | SyllabusChapterScalarWhereWithAggregatesInput[]
    OR?: SyllabusChapterScalarWhereWithAggregatesInput[]
    NOT?: SyllabusChapterScalarWhereWithAggregatesInput | SyllabusChapterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyllabusChapter"> | number
    unit_id?: IntWithAggregatesFilter<"SyllabusChapter"> | number
    chapter_number?: StringWithAggregatesFilter<"SyllabusChapter"> | string
    title?: StringWithAggregatesFilter<"SyllabusChapter"> | string
    order?: IntWithAggregatesFilter<"SyllabusChapter"> | number
    subtopics?: JsonNullableWithAggregatesFilter<"SyllabusChapter">
  }

  export type TextbookWhereInput = {
    AND?: TextbookWhereInput | TextbookWhereInput[]
    OR?: TextbookWhereInput[]
    NOT?: TextbookWhereInput | TextbookWhereInput[]
    id?: IntFilter<"Textbook"> | number
    title?: StringFilter<"Textbook"> | string
    description?: StringNullableFilter<"Textbook"> | string | null
    class_level?: StringFilter<"Textbook"> | string
    stream?: StringNullableFilter<"Textbook"> | string | null
    subject_name?: StringNullableFilter<"Textbook"> | string | null
    board_id?: StringNullableFilter<"Textbook"> | string | null
    academic_year?: StringNullableFilter<"Textbook"> | string | null
    author?: StringNullableFilter<"Textbook"> | string | null
    syllabus_id?: IntNullableFilter<"Textbook"> | number | null
    raw_syllabus?: StringNullableFilter<"Textbook"> | string | null
    status?: EnumTextbookStatusFilter<"Textbook"> | $Enums.TextbookStatus
    progress?: IntFilter<"Textbook"> | number
    cover_image_url?: StringNullableFilter<"Textbook"> | string | null
    pdf_url?: StringNullableFilter<"Textbook"> | string | null
    compiled_pdf_url?: StringNullableFilter<"Textbook"> | string | null
    created_at?: DateTimeFilter<"Textbook"> | Date | string
    updated_at?: DateTimeFilter<"Textbook"> | Date | string
    created_by?: IntFilter<"Textbook"> | number
    syllabus?: XOR<SyllabusNullableScalarRelationFilter, SyllabusWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    units?: TextbookUnitListRelationFilter
    generation_jobs?: TextbookGenerationJobListRelationFilter
    enrollments?: UserEnrollmentListRelationFilter
  }

  export type TextbookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    class_level?: SortOrder
    stream?: SortOrderInput | SortOrder
    subject_name?: SortOrderInput | SortOrder
    board_id?: SortOrderInput | SortOrder
    academic_year?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    syllabus_id?: SortOrderInput | SortOrder
    raw_syllabus?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    cover_image_url?: SortOrderInput | SortOrder
    pdf_url?: SortOrderInput | SortOrder
    compiled_pdf_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    syllabus?: SyllabusOrderByWithRelationInput
    creator?: userOrderByWithRelationInput
    units?: TextbookUnitOrderByRelationAggregateInput
    generation_jobs?: TextbookGenerationJobOrderByRelationAggregateInput
    enrollments?: UserEnrollmentOrderByRelationAggregateInput
  }

  export type TextbookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TextbookWhereInput | TextbookWhereInput[]
    OR?: TextbookWhereInput[]
    NOT?: TextbookWhereInput | TextbookWhereInput[]
    title?: StringFilter<"Textbook"> | string
    description?: StringNullableFilter<"Textbook"> | string | null
    class_level?: StringFilter<"Textbook"> | string
    stream?: StringNullableFilter<"Textbook"> | string | null
    subject_name?: StringNullableFilter<"Textbook"> | string | null
    board_id?: StringNullableFilter<"Textbook"> | string | null
    academic_year?: StringNullableFilter<"Textbook"> | string | null
    author?: StringNullableFilter<"Textbook"> | string | null
    syllabus_id?: IntNullableFilter<"Textbook"> | number | null
    raw_syllabus?: StringNullableFilter<"Textbook"> | string | null
    status?: EnumTextbookStatusFilter<"Textbook"> | $Enums.TextbookStatus
    progress?: IntFilter<"Textbook"> | number
    cover_image_url?: StringNullableFilter<"Textbook"> | string | null
    pdf_url?: StringNullableFilter<"Textbook"> | string | null
    compiled_pdf_url?: StringNullableFilter<"Textbook"> | string | null
    created_at?: DateTimeFilter<"Textbook"> | Date | string
    updated_at?: DateTimeFilter<"Textbook"> | Date | string
    created_by?: IntFilter<"Textbook"> | number
    syllabus?: XOR<SyllabusNullableScalarRelationFilter, SyllabusWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, userWhereInput>
    units?: TextbookUnitListRelationFilter
    generation_jobs?: TextbookGenerationJobListRelationFilter
    enrollments?: UserEnrollmentListRelationFilter
  }, "id">

  export type TextbookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    class_level?: SortOrder
    stream?: SortOrderInput | SortOrder
    subject_name?: SortOrderInput | SortOrder
    board_id?: SortOrderInput | SortOrder
    academic_year?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    syllabus_id?: SortOrderInput | SortOrder
    raw_syllabus?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    cover_image_url?: SortOrderInput | SortOrder
    pdf_url?: SortOrderInput | SortOrder
    compiled_pdf_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    _count?: TextbookCountOrderByAggregateInput
    _avg?: TextbookAvgOrderByAggregateInput
    _max?: TextbookMaxOrderByAggregateInput
    _min?: TextbookMinOrderByAggregateInput
    _sum?: TextbookSumOrderByAggregateInput
  }

  export type TextbookScalarWhereWithAggregatesInput = {
    AND?: TextbookScalarWhereWithAggregatesInput | TextbookScalarWhereWithAggregatesInput[]
    OR?: TextbookScalarWhereWithAggregatesInput[]
    NOT?: TextbookScalarWhereWithAggregatesInput | TextbookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Textbook"> | number
    title?: StringWithAggregatesFilter<"Textbook"> | string
    description?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    class_level?: StringWithAggregatesFilter<"Textbook"> | string
    stream?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    subject_name?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    board_id?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    academic_year?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    author?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    syllabus_id?: IntNullableWithAggregatesFilter<"Textbook"> | number | null
    raw_syllabus?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    status?: EnumTextbookStatusWithAggregatesFilter<"Textbook"> | $Enums.TextbookStatus
    progress?: IntWithAggregatesFilter<"Textbook"> | number
    cover_image_url?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    pdf_url?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    compiled_pdf_url?: StringNullableWithAggregatesFilter<"Textbook"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Textbook"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Textbook"> | Date | string
    created_by?: IntWithAggregatesFilter<"Textbook"> | number
  }

  export type TextbookUnitWhereInput = {
    AND?: TextbookUnitWhereInput | TextbookUnitWhereInput[]
    OR?: TextbookUnitWhereInput[]
    NOT?: TextbookUnitWhereInput | TextbookUnitWhereInput[]
    id?: IntFilter<"TextbookUnit"> | number
    textbook_id?: IntFilter<"TextbookUnit"> | number
    order?: IntFilter<"TextbookUnit"> | number
    title?: StringFilter<"TextbookUnit"> | string
    description?: StringNullableFilter<"TextbookUnit"> | string | null
    created_at?: DateTimeFilter<"TextbookUnit"> | Date | string
    updated_at?: DateTimeFilter<"TextbookUnit"> | Date | string
    textbook?: XOR<TextbookScalarRelationFilter, TextbookWhereInput>
    chapters?: TextbookChapterListRelationFilter
  }

  export type TextbookUnitOrderByWithRelationInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    textbook?: TextbookOrderByWithRelationInput
    chapters?: TextbookChapterOrderByRelationAggregateInput
  }

  export type TextbookUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    textbook_id_order?: TextbookUnitTextbook_idOrderCompoundUniqueInput
    AND?: TextbookUnitWhereInput | TextbookUnitWhereInput[]
    OR?: TextbookUnitWhereInput[]
    NOT?: TextbookUnitWhereInput | TextbookUnitWhereInput[]
    textbook_id?: IntFilter<"TextbookUnit"> | number
    order?: IntFilter<"TextbookUnit"> | number
    title?: StringFilter<"TextbookUnit"> | string
    description?: StringNullableFilter<"TextbookUnit"> | string | null
    created_at?: DateTimeFilter<"TextbookUnit"> | Date | string
    updated_at?: DateTimeFilter<"TextbookUnit"> | Date | string
    textbook?: XOR<TextbookScalarRelationFilter, TextbookWhereInput>
    chapters?: TextbookChapterListRelationFilter
  }, "id" | "textbook_id_order">

  export type TextbookUnitOrderByWithAggregationInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TextbookUnitCountOrderByAggregateInput
    _avg?: TextbookUnitAvgOrderByAggregateInput
    _max?: TextbookUnitMaxOrderByAggregateInput
    _min?: TextbookUnitMinOrderByAggregateInput
    _sum?: TextbookUnitSumOrderByAggregateInput
  }

  export type TextbookUnitScalarWhereWithAggregatesInput = {
    AND?: TextbookUnitScalarWhereWithAggregatesInput | TextbookUnitScalarWhereWithAggregatesInput[]
    OR?: TextbookUnitScalarWhereWithAggregatesInput[]
    NOT?: TextbookUnitScalarWhereWithAggregatesInput | TextbookUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TextbookUnit"> | number
    textbook_id?: IntWithAggregatesFilter<"TextbookUnit"> | number
    order?: IntWithAggregatesFilter<"TextbookUnit"> | number
    title?: StringWithAggregatesFilter<"TextbookUnit"> | string
    description?: StringNullableWithAggregatesFilter<"TextbookUnit"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"TextbookUnit"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TextbookUnit"> | Date | string
  }

  export type TextbookChapterWhereInput = {
    AND?: TextbookChapterWhereInput | TextbookChapterWhereInput[]
    OR?: TextbookChapterWhereInput[]
    NOT?: TextbookChapterWhereInput | TextbookChapterWhereInput[]
    id?: IntFilter<"TextbookChapter"> | number
    unit_id?: IntFilter<"TextbookChapter"> | number
    chapter_number?: StringFilter<"TextbookChapter"> | string
    title?: StringFilter<"TextbookChapter"> | string
    order?: IntFilter<"TextbookChapter"> | number
    raw_syllabus_text?: StringNullableFilter<"TextbookChapter"> | string | null
    subtopics?: JsonNullableFilter<"TextbookChapter">
    content?: StringNullableFilter<"TextbookChapter"> | string | null
    content_markdown?: StringNullableFilter<"TextbookChapter"> | string | null
    content_html?: StringNullableFilter<"TextbookChapter"> | string | null
    summary?: StringNullableFilter<"TextbookChapter"> | string | null
    learning_outcomes?: JsonNullableFilter<"TextbookChapter">
    key_takeaways?: JsonNullableFilter<"TextbookChapter">
    pdf_url?: StringNullableFilter<"TextbookChapter"> | string | null
    generated_at?: DateTimeNullableFilter<"TextbookChapter"> | Date | string | null
    neet_relevant?: BoolFilter<"TextbookChapter"> | boolean
    jee_relevant?: BoolFilter<"TextbookChapter"> | boolean
    cuet_relevant?: BoolFilter<"TextbookChapter"> | boolean
    exam_highlights?: JsonNullableFilter<"TextbookChapter">
    mcq_questions?: JsonNullableFilter<"TextbookChapter">
    short_questions?: JsonNullableFilter<"TextbookChapter">
    long_questions?: JsonNullableFilter<"TextbookChapter">
    model_used?: StringNullableFilter<"TextbookChapter"> | string | null
    tokens_used?: JsonNullableFilter<"TextbookChapter">
    generation_time_ms?: IntNullableFilter<"TextbookChapter"> | number | null
    status?: EnumChapterGenStatusFilter<"TextbookChapter"> | $Enums.ChapterGenStatus
    generation_error?: StringNullableFilter<"TextbookChapter"> | string | null
    created_at?: DateTimeFilter<"TextbookChapter"> | Date | string
    updated_at?: DateTimeFilter<"TextbookChapter"> | Date | string
    unit?: XOR<TextbookUnitScalarRelationFilter, TextbookUnitWhereInput>
    images?: TextbookImageListRelationFilter
  }

  export type TextbookChapterOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    raw_syllabus_text?: SortOrderInput | SortOrder
    subtopics?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    content_markdown?: SortOrderInput | SortOrder
    content_html?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    learning_outcomes?: SortOrderInput | SortOrder
    key_takeaways?: SortOrderInput | SortOrder
    pdf_url?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    neet_relevant?: SortOrder
    jee_relevant?: SortOrder
    cuet_relevant?: SortOrder
    exam_highlights?: SortOrderInput | SortOrder
    mcq_questions?: SortOrderInput | SortOrder
    short_questions?: SortOrderInput | SortOrder
    long_questions?: SortOrderInput | SortOrder
    model_used?: SortOrderInput | SortOrder
    tokens_used?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    status?: SortOrder
    generation_error?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: TextbookUnitOrderByWithRelationInput
    images?: TextbookImageOrderByRelationAggregateInput
  }

  export type TextbookChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    unit_id_order?: TextbookChapterUnit_idOrderCompoundUniqueInput
    AND?: TextbookChapterWhereInput | TextbookChapterWhereInput[]
    OR?: TextbookChapterWhereInput[]
    NOT?: TextbookChapterWhereInput | TextbookChapterWhereInput[]
    unit_id?: IntFilter<"TextbookChapter"> | number
    chapter_number?: StringFilter<"TextbookChapter"> | string
    title?: StringFilter<"TextbookChapter"> | string
    order?: IntFilter<"TextbookChapter"> | number
    raw_syllabus_text?: StringNullableFilter<"TextbookChapter"> | string | null
    subtopics?: JsonNullableFilter<"TextbookChapter">
    content?: StringNullableFilter<"TextbookChapter"> | string | null
    content_markdown?: StringNullableFilter<"TextbookChapter"> | string | null
    content_html?: StringNullableFilter<"TextbookChapter"> | string | null
    summary?: StringNullableFilter<"TextbookChapter"> | string | null
    learning_outcomes?: JsonNullableFilter<"TextbookChapter">
    key_takeaways?: JsonNullableFilter<"TextbookChapter">
    pdf_url?: StringNullableFilter<"TextbookChapter"> | string | null
    generated_at?: DateTimeNullableFilter<"TextbookChapter"> | Date | string | null
    neet_relevant?: BoolFilter<"TextbookChapter"> | boolean
    jee_relevant?: BoolFilter<"TextbookChapter"> | boolean
    cuet_relevant?: BoolFilter<"TextbookChapter"> | boolean
    exam_highlights?: JsonNullableFilter<"TextbookChapter">
    mcq_questions?: JsonNullableFilter<"TextbookChapter">
    short_questions?: JsonNullableFilter<"TextbookChapter">
    long_questions?: JsonNullableFilter<"TextbookChapter">
    model_used?: StringNullableFilter<"TextbookChapter"> | string | null
    tokens_used?: JsonNullableFilter<"TextbookChapter">
    generation_time_ms?: IntNullableFilter<"TextbookChapter"> | number | null
    status?: EnumChapterGenStatusFilter<"TextbookChapter"> | $Enums.ChapterGenStatus
    generation_error?: StringNullableFilter<"TextbookChapter"> | string | null
    created_at?: DateTimeFilter<"TextbookChapter"> | Date | string
    updated_at?: DateTimeFilter<"TextbookChapter"> | Date | string
    unit?: XOR<TextbookUnitScalarRelationFilter, TextbookUnitWhereInput>
    images?: TextbookImageListRelationFilter
  }, "id" | "unit_id_order">

  export type TextbookChapterOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    raw_syllabus_text?: SortOrderInput | SortOrder
    subtopics?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    content_markdown?: SortOrderInput | SortOrder
    content_html?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    learning_outcomes?: SortOrderInput | SortOrder
    key_takeaways?: SortOrderInput | SortOrder
    pdf_url?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    neet_relevant?: SortOrder
    jee_relevant?: SortOrder
    cuet_relevant?: SortOrder
    exam_highlights?: SortOrderInput | SortOrder
    mcq_questions?: SortOrderInput | SortOrder
    short_questions?: SortOrderInput | SortOrder
    long_questions?: SortOrderInput | SortOrder
    model_used?: SortOrderInput | SortOrder
    tokens_used?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    status?: SortOrder
    generation_error?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TextbookChapterCountOrderByAggregateInput
    _avg?: TextbookChapterAvgOrderByAggregateInput
    _max?: TextbookChapterMaxOrderByAggregateInput
    _min?: TextbookChapterMinOrderByAggregateInput
    _sum?: TextbookChapterSumOrderByAggregateInput
  }

  export type TextbookChapterScalarWhereWithAggregatesInput = {
    AND?: TextbookChapterScalarWhereWithAggregatesInput | TextbookChapterScalarWhereWithAggregatesInput[]
    OR?: TextbookChapterScalarWhereWithAggregatesInput[]
    NOT?: TextbookChapterScalarWhereWithAggregatesInput | TextbookChapterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TextbookChapter"> | number
    unit_id?: IntWithAggregatesFilter<"TextbookChapter"> | number
    chapter_number?: StringWithAggregatesFilter<"TextbookChapter"> | string
    title?: StringWithAggregatesFilter<"TextbookChapter"> | string
    order?: IntWithAggregatesFilter<"TextbookChapter"> | number
    raw_syllabus_text?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    subtopics?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    content?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    content_markdown?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    content_html?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    summary?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    learning_outcomes?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    key_takeaways?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    pdf_url?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    generated_at?: DateTimeNullableWithAggregatesFilter<"TextbookChapter"> | Date | string | null
    neet_relevant?: BoolWithAggregatesFilter<"TextbookChapter"> | boolean
    jee_relevant?: BoolWithAggregatesFilter<"TextbookChapter"> | boolean
    cuet_relevant?: BoolWithAggregatesFilter<"TextbookChapter"> | boolean
    exam_highlights?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    mcq_questions?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    short_questions?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    long_questions?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    model_used?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    tokens_used?: JsonNullableWithAggregatesFilter<"TextbookChapter">
    generation_time_ms?: IntNullableWithAggregatesFilter<"TextbookChapter"> | number | null
    status?: EnumChapterGenStatusWithAggregatesFilter<"TextbookChapter"> | $Enums.ChapterGenStatus
    generation_error?: StringNullableWithAggregatesFilter<"TextbookChapter"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"TextbookChapter"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TextbookChapter"> | Date | string
  }

  export type TextbookImageWhereInput = {
    AND?: TextbookImageWhereInput | TextbookImageWhereInput[]
    OR?: TextbookImageWhereInput[]
    NOT?: TextbookImageWhereInput | TextbookImageWhereInput[]
    id?: IntFilter<"TextbookImage"> | number
    chapter_id?: IntFilter<"TextbookImage"> | number
    type?: EnumTextbookImageTypeFilter<"TextbookImage"> | $Enums.TextbookImageType
    prompt?: StringNullableFilter<"TextbookImage"> | string | null
    alt_text?: StringNullableFilter<"TextbookImage"> | string | null
    url?: StringNullableFilter<"TextbookImage"> | string | null
    image_url?: StringNullableFilter<"TextbookImage"> | string | null
    order?: IntFilter<"TextbookImage"> | number
    placement?: StringNullableFilter<"TextbookImage"> | string | null
    caption?: StringNullableFilter<"TextbookImage"> | string | null
    status?: EnumImageGenStatusFilter<"TextbookImage"> | $Enums.ImageGenStatus
    model_used?: StringNullableFilter<"TextbookImage"> | string | null
    generation_time_ms?: IntNullableFilter<"TextbookImage"> | number | null
    generated_at?: DateTimeNullableFilter<"TextbookImage"> | Date | string | null
    created_at?: DateTimeFilter<"TextbookImage"> | Date | string
    chapter?: XOR<TextbookChapterScalarRelationFilter, TextbookChapterWhereInput>
  }

  export type TextbookImageOrderByWithRelationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    type?: SortOrder
    prompt?: SortOrderInput | SortOrder
    alt_text?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    order?: SortOrder
    placement?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrder
    model_used?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    chapter?: TextbookChapterOrderByWithRelationInput
  }

  export type TextbookImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TextbookImageWhereInput | TextbookImageWhereInput[]
    OR?: TextbookImageWhereInput[]
    NOT?: TextbookImageWhereInput | TextbookImageWhereInput[]
    chapter_id?: IntFilter<"TextbookImage"> | number
    type?: EnumTextbookImageTypeFilter<"TextbookImage"> | $Enums.TextbookImageType
    prompt?: StringNullableFilter<"TextbookImage"> | string | null
    alt_text?: StringNullableFilter<"TextbookImage"> | string | null
    url?: StringNullableFilter<"TextbookImage"> | string | null
    image_url?: StringNullableFilter<"TextbookImage"> | string | null
    order?: IntFilter<"TextbookImage"> | number
    placement?: StringNullableFilter<"TextbookImage"> | string | null
    caption?: StringNullableFilter<"TextbookImage"> | string | null
    status?: EnumImageGenStatusFilter<"TextbookImage"> | $Enums.ImageGenStatus
    model_used?: StringNullableFilter<"TextbookImage"> | string | null
    generation_time_ms?: IntNullableFilter<"TextbookImage"> | number | null
    generated_at?: DateTimeNullableFilter<"TextbookImage"> | Date | string | null
    created_at?: DateTimeFilter<"TextbookImage"> | Date | string
    chapter?: XOR<TextbookChapterScalarRelationFilter, TextbookChapterWhereInput>
  }, "id">

  export type TextbookImageOrderByWithAggregationInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    type?: SortOrder
    prompt?: SortOrderInput | SortOrder
    alt_text?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    order?: SortOrder
    placement?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrder
    model_used?: SortOrderInput | SortOrder
    generation_time_ms?: SortOrderInput | SortOrder
    generated_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: TextbookImageCountOrderByAggregateInput
    _avg?: TextbookImageAvgOrderByAggregateInput
    _max?: TextbookImageMaxOrderByAggregateInput
    _min?: TextbookImageMinOrderByAggregateInput
    _sum?: TextbookImageSumOrderByAggregateInput
  }

  export type TextbookImageScalarWhereWithAggregatesInput = {
    AND?: TextbookImageScalarWhereWithAggregatesInput | TextbookImageScalarWhereWithAggregatesInput[]
    OR?: TextbookImageScalarWhereWithAggregatesInput[]
    NOT?: TextbookImageScalarWhereWithAggregatesInput | TextbookImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TextbookImage"> | number
    chapter_id?: IntWithAggregatesFilter<"TextbookImage"> | number
    type?: EnumTextbookImageTypeWithAggregatesFilter<"TextbookImage"> | $Enums.TextbookImageType
    prompt?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    alt_text?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    url?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    order?: IntWithAggregatesFilter<"TextbookImage"> | number
    placement?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    status?: EnumImageGenStatusWithAggregatesFilter<"TextbookImage"> | $Enums.ImageGenStatus
    model_used?: StringNullableWithAggregatesFilter<"TextbookImage"> | string | null
    generation_time_ms?: IntNullableWithAggregatesFilter<"TextbookImage"> | number | null
    generated_at?: DateTimeNullableWithAggregatesFilter<"TextbookImage"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"TextbookImage"> | Date | string
  }

  export type TextbookGenerationJobWhereInput = {
    AND?: TextbookGenerationJobWhereInput | TextbookGenerationJobWhereInput[]
    OR?: TextbookGenerationJobWhereInput[]
    NOT?: TextbookGenerationJobWhereInput | TextbookGenerationJobWhereInput[]
    id?: IntFilter<"TextbookGenerationJob"> | number
    textbook_id?: IntFilter<"TextbookGenerationJob"> | number
    job_type?: EnumTextbookGenerationJobTypeFilter<"TextbookGenerationJob"> | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFilter<"TextbookGenerationJob"> | $Enums.TextbookJobStatus
    target_id?: IntNullableFilter<"TextbookGenerationJob"> | number | null
    input_data?: JsonNullableFilter<"TextbookGenerationJob">
    output_data?: JsonNullableFilter<"TextbookGenerationJob">
    error_message?: StringNullableFilter<"TextbookGenerationJob"> | string | null
    progress?: IntFilter<"TextbookGenerationJob"> | number
    started_at?: DateTimeNullableFilter<"TextbookGenerationJob"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"TextbookGenerationJob"> | Date | string | null
    attempts?: IntFilter<"TextbookGenerationJob"> | number
    max_attempts?: IntFilter<"TextbookGenerationJob"> | number
    created_at?: DateTimeFilter<"TextbookGenerationJob"> | Date | string
    textbook?: XOR<TextbookScalarRelationFilter, TextbookWhereInput>
  }

  export type TextbookGenerationJobOrderByWithRelationInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    target_id?: SortOrderInput | SortOrder
    input_data?: SortOrderInput | SortOrder
    output_data?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    progress?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
    created_at?: SortOrder
    textbook?: TextbookOrderByWithRelationInput
  }

  export type TextbookGenerationJobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TextbookGenerationJobWhereInput | TextbookGenerationJobWhereInput[]
    OR?: TextbookGenerationJobWhereInput[]
    NOT?: TextbookGenerationJobWhereInput | TextbookGenerationJobWhereInput[]
    textbook_id?: IntFilter<"TextbookGenerationJob"> | number
    job_type?: EnumTextbookGenerationJobTypeFilter<"TextbookGenerationJob"> | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFilter<"TextbookGenerationJob"> | $Enums.TextbookJobStatus
    target_id?: IntNullableFilter<"TextbookGenerationJob"> | number | null
    input_data?: JsonNullableFilter<"TextbookGenerationJob">
    output_data?: JsonNullableFilter<"TextbookGenerationJob">
    error_message?: StringNullableFilter<"TextbookGenerationJob"> | string | null
    progress?: IntFilter<"TextbookGenerationJob"> | number
    started_at?: DateTimeNullableFilter<"TextbookGenerationJob"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"TextbookGenerationJob"> | Date | string | null
    attempts?: IntFilter<"TextbookGenerationJob"> | number
    max_attempts?: IntFilter<"TextbookGenerationJob"> | number
    created_at?: DateTimeFilter<"TextbookGenerationJob"> | Date | string
    textbook?: XOR<TextbookScalarRelationFilter, TextbookWhereInput>
  }, "id">

  export type TextbookGenerationJobOrderByWithAggregationInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    target_id?: SortOrderInput | SortOrder
    input_data?: SortOrderInput | SortOrder
    output_data?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    progress?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
    created_at?: SortOrder
    _count?: TextbookGenerationJobCountOrderByAggregateInput
    _avg?: TextbookGenerationJobAvgOrderByAggregateInput
    _max?: TextbookGenerationJobMaxOrderByAggregateInput
    _min?: TextbookGenerationJobMinOrderByAggregateInput
    _sum?: TextbookGenerationJobSumOrderByAggregateInput
  }

  export type TextbookGenerationJobScalarWhereWithAggregatesInput = {
    AND?: TextbookGenerationJobScalarWhereWithAggregatesInput | TextbookGenerationJobScalarWhereWithAggregatesInput[]
    OR?: TextbookGenerationJobScalarWhereWithAggregatesInput[]
    NOT?: TextbookGenerationJobScalarWhereWithAggregatesInput | TextbookGenerationJobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TextbookGenerationJob"> | number
    textbook_id?: IntWithAggregatesFilter<"TextbookGenerationJob"> | number
    job_type?: EnumTextbookGenerationJobTypeWithAggregatesFilter<"TextbookGenerationJob"> | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusWithAggregatesFilter<"TextbookGenerationJob"> | $Enums.TextbookJobStatus
    target_id?: IntNullableWithAggregatesFilter<"TextbookGenerationJob"> | number | null
    input_data?: JsonNullableWithAggregatesFilter<"TextbookGenerationJob">
    output_data?: JsonNullableWithAggregatesFilter<"TextbookGenerationJob">
    error_message?: StringNullableWithAggregatesFilter<"TextbookGenerationJob"> | string | null
    progress?: IntWithAggregatesFilter<"TextbookGenerationJob"> | number
    started_at?: DateTimeNullableWithAggregatesFilter<"TextbookGenerationJob"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"TextbookGenerationJob"> | Date | string | null
    attempts?: IntWithAggregatesFilter<"TextbookGenerationJob"> | number
    max_attempts?: IntWithAggregatesFilter<"TextbookGenerationJob"> | number
    created_at?: DateTimeWithAggregatesFilter<"TextbookGenerationJob"> | Date | string
  }

  export type CategoryListCreateInput = {
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user?: userCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryListUncheckedCreateInput = {
    id?: number
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: number | null
  }

  export type CategoryListUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutCategoriesNestedInput
  }

  export type CategoryListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryListCreateManyInput = {
    id?: number
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: number | null
  }

  export type CategoryListUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FileListCreateInput = {
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    user?: userCreateNestedOneWithoutFilesInput
    pages?: DocumentPageCreateNestedManyWithoutFileInput
    chunks?: FileChunkCreateNestedManyWithoutFileInput
  }

  export type FileListUncheckedCreateInput = {
    id?: number
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: number | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    pages?: DocumentPageUncheckedCreateNestedManyWithoutFileInput
    chunks?: FileChunkUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileListUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutFilesNestedInput
    pages?: DocumentPageUpdateManyWithoutFileNestedInput
    chunks?: FileChunkUpdateManyWithoutFileNestedInput
  }

  export type FileListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: DocumentPageUncheckedUpdateManyWithoutFileNestedInput
    chunks?: FileChunkUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileListCreateManyInput = {
    id?: number
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: number | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
  }

  export type FileListUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentPageCreateInput = {
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
    file: FileListCreateNestedOneWithoutPagesInput
  }

  export type DocumentPageUncheckedCreateInput = {
    id?: number
    file_id: number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type DocumentPageUpdateInput = {
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileListUpdateOneRequiredWithoutPagesNestedInput
  }

  export type DocumentPageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_id?: IntFieldUpdateOperationsInput | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageCreateManyInput = {
    id?: number
    file_id: number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type DocumentPageUpdateManyMutationInput = {
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_id?: IntFieldUpdateOperationsInput | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileChunkCreateInput = {
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: number | null
    created_at?: Date | string
    file: FileListCreateNestedOneWithoutChunksInput
  }

  export type FileChunkUncheckedCreateInput = {
    id?: number
    file_id: number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: number | null
    created_at?: Date | string
  }

  export type FileChunkUpdateInput = {
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileListUpdateOneRequiredWithoutChunksNestedInput
  }

  export type FileChunkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_id?: IntFieldUpdateOperationsInput | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileChunkCreateManyInput = {
    id?: number
    file_id: number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: number | null
    created_at?: Date | string
  }

  export type FileChunkUpdateManyMutationInput = {
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileChunkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_id?: IntFieldUpdateOperationsInput | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
  }

  export type userUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserEnrollmentCreateInput = {
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutEnrollmentsInput
    textbook: TextbookCreateNestedOneWithoutEnrollmentsInput
  }

  export type UserEnrollmentUncheckedCreateInput = {
    id?: number
    user_id: number
    textbook_id: number
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
  }

  export type UserEnrollmentUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutEnrollmentsNestedInput
    textbook?: TextbookUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type UserEnrollmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserEnrollmentCreateManyInput = {
    id?: number
    user_id: number
    textbook_id: number
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
  }

  export type UserEnrollmentUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserEnrollmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationCreateInput = {
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    messages?: ConversationMessageCreateNestedManyWithoutConversationInput
    user: userCreateNestedOneWithoutConversationsInput
    subject?: SubjectCreateNestedOneWithoutConversationsInput
    chapter?: ChapterCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
    chapter_id?: bigint | number | null
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
    user?: userUpdateOneRequiredWithoutConversationsNestedInput
    subject?: SubjectUpdateOneWithoutConversationsNestedInput
    chapter?: ChapterUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
    chapter_id?: bigint | number | null
  }

  export type ConversationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ConversationMessageCreateInput = {
    role: $Enums.MessageRole
    content: string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type ConversationMessageUncheckedCreateInput = {
    id?: number
    conversation_id: number
    role: $Enums.MessageRole
    content: string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ConversationMessageUpdateInput = {
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ConversationMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: IntFieldUpdateOperationsInput | number
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageCreateManyInput = {
    id?: number
    conversation_id: number
    role: $Enums.MessageRole
    content: string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ConversationMessageUpdateManyMutationInput = {
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversation_id?: IntFieldUpdateOperationsInput | number
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiApiKeyCreateInput = {
    provider: $Enums.Provider
    label: string
    api_key_enc: string
    active?: boolean
    priority?: number
    success_count?: number
    error_count?: number
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AiApiKeyUncheckedCreateInput = {
    id?: number
    provider: $Enums.Provider
    label: string
    api_key_enc: string
    active?: boolean
    priority?: number
    success_count?: number
    error_count?: number
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AiApiKeyUpdateInput = {
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    label?: StringFieldUpdateOperationsInput | string
    api_key_enc?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiApiKeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    label?: StringFieldUpdateOperationsInput | string
    api_key_enc?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiApiKeyCreateManyInput = {
    id?: number
    provider: $Enums.Provider
    label: string
    api_key_enc: string
    active?: boolean
    priority?: number
    success_count?: number
    error_count?: number
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AiApiKeyUpdateManyMutationInput = {
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    label?: StringFieldUpdateOperationsInput | string
    api_key_enc?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiApiKeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    label?: StringFieldUpdateOperationsInput | string
    api_key_enc?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiModelCreateInput = {
    provider: $Enums.Provider
    name: string
    label: string
    active?: boolean
    priority?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AiModelUncheckedCreateInput = {
    id?: number
    provider: $Enums.Provider
    name: string
    label: string
    active?: boolean
    priority?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AiModelUpdateInput = {
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiModelCreateManyInput = {
    id?: number
    provider: $Enums.Provider
    name: string
    label: string
    active?: boolean
    priority?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AiModelUpdateManyMutationInput = {
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_settingsCreateInput = {
    key: string
    value: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type app_settingsUncheckedCreateInput = {
    key: string
    value: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type app_settingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_settingsUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_settingsCreateManyInput = {
    key: string
    value: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type app_settingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type app_settingsUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionPlanCreateInput = {
    name: string
    display_name: string
    description?: string | null
    price_monthly: Decimal | DecimalJsLike | number | string
    price_yearly?: Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: string | null
    razorpay_plan_id_yearly?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    subscriptions?: UserSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: number
    name: string
    display_name: string
    description?: string | null
    price_monthly: Decimal | DecimalJsLike | number | string
    price_yearly?: Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: string | null
    razorpay_plan_id_yearly?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_monthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_yearly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_plan_id_yearly?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: UserSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_monthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_yearly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_plan_id_yearly?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: number
    name: string
    display_name: string
    description?: string | null
    price_monthly: Decimal | DecimalJsLike | number | string
    price_yearly?: Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: string | null
    razorpay_plan_id_yearly?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_monthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_yearly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_plan_id_yearly?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_monthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_yearly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_plan_id_yearly?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateInput = {
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
    user: userCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: number
    user_id: number
    plan_id: number
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserSubscriptionUpdateInput = {
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    user?: userUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyInput = {
    id?: number
    user_id: number
    plan_id: number
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingCreateInput = {
    usage_type: $Enums.UsageType
    count?: number
    period_start: Date | string
    period_end: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    user: userCreateNestedOneWithoutUsage_trackingInput
  }

  export type UsageTrackingUncheckedCreateInput = {
    id?: number
    user_id: number
    usage_type: $Enums.UsageType
    count?: number
    period_start: Date | string
    period_end: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UsageTrackingUpdateInput = {
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUsage_trackingNestedInput
  }

  export type UsageTrackingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingCreateManyInput = {
    id?: number
    user_id: number
    usage_type: $Enums.UsageType
    count?: number
    period_start: Date | string
    period_end: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UsageTrackingUpdateManyMutationInput = {
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    id: string
    name: string
    currency: string
    locale?: string
    is_active?: boolean
    boards?: BoardCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id: string
    name: string
    currency: string
    locale?: string
    is_active?: boolean
    boards?: BoardUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    boards?: BoardUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id: string
    name: string
    currency: string
    locale?: string
    is_active?: boolean
  }

  export type CountryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardCreateInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    country?: CountryCreateNestedOneWithoutBoardsInput
    institutions?: InstitutionCreateNestedManyWithoutBoardInput
    programs?: ProgramCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id: string
    name: string
    country_id?: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    institutions?: InstitutionUncheckedCreateNestedManyWithoutBoardInput
    programs?: ProgramUncheckedCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutBoardsNestedInput
    institutions?: InstitutionUpdateManyWithoutBoardNestedInput
    programs?: ProgramUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUncheckedUpdateManyWithoutBoardNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id: string
    name: string
    country_id?: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateInput = {
    id?: bigint | number
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutInstitutionsInput
    programs?: ProgramCreateNestedManyWithoutInstitutionInput
    profiles?: ProfileCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateInput = {
    id?: bigint | number
    board_id: string
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutInstitutionInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutInstitutionsNestedInput
    programs?: ProgramUpdateManyWithoutInstitutionNestedInput
    profiles?: ProfileUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutInstitutionNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateManyInput = {
    id?: bigint | number
    board_id: string
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type InstitutionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutProgramsInput
    institution?: InstitutionCreateNestedOneWithoutProgramsInput
    subjects?: SubjectCreateNestedManyWithoutProgramInput
    profiles?: ProfileCreateNestedManyWithoutProgramInput
    exams?: ExamCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: number
    board_id: string
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutProgramInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutProgramInput
    exams?: ExamUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutProgramsNestedInput
    institution?: InstitutionUpdateOneWithoutProgramsNestedInput
    subjects?: SubjectUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUpdateManyWithoutProgramNestedInput
    exams?: ExamUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutProgramNestedInput
    exams?: ExamUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: number
    board_id: string
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    is_premium?: boolean
    last_sync_at?: bigint | number | null
    user: userCreateNestedOneWithoutProfileInput
    institution?: InstitutionCreateNestedOneWithoutProfilesInput
    program?: ProgramCreateNestedOneWithoutProfilesInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    user_id: number
    institution_id?: bigint | number | null
    program_id?: number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ProfileUpdateInput = {
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    institution?: InstitutionUpdateOneWithoutProfilesNestedInput
    program?: ProgramUpdateOneWithoutProfilesNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ProfileCreateManyInput = {
    id?: number
    user_id: number
    institution_id?: bigint | number | null
    program_id?: number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ProfileUpdateManyMutationInput = {
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SubjectCreateInput = {
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    program: ProgramCreateNestedOneWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    quizzes?: QuizCreateNestedManyWithoutSubjectInput
    conversations?: ConversationCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: number
    program_id: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutSubjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    quizzes?: QuizUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: number
    program_id: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
  }

  export type SubjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterCreateInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
  }

  export type ChapterUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChapterChunkCreateInput = {
    id?: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
    chapter: ChapterCreateNestedOneWithoutChunksInput
    chunkBoards?: ChapterChunkBoardCreateNestedManyWithoutChunkInput
  }

  export type ChapterChunkUncheckedCreateInput = {
    id?: bigint | number
    chapter_id: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
    chunkBoards?: ChapterChunkBoardUncheckedCreateNestedManyWithoutChunkInput
  }

  export type ChapterChunkUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutChunksNestedInput
    chunkBoards?: ChapterChunkBoardUpdateManyWithoutChunkNestedInput
  }

  export type ChapterChunkUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chunkBoards?: ChapterChunkBoardUncheckedUpdateManyWithoutChunkNestedInput
  }

  export type ChapterChunkCreateManyInput = {
    id?: bigint | number
    chapter_id: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
  }

  export type ChapterChunkUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChunkUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChunkBoardCreateInput = {
    chunk: ChapterChunkCreateNestedOneWithoutChunkBoardsInput
    board: BoardCreateNestedOneWithoutChunkBoardsInput
  }

  export type ChapterChunkBoardUncheckedCreateInput = {
    chunk_id: bigint | number
    board_id: string
  }

  export type ChapterChunkBoardUpdateInput = {
    chunk?: ChapterChunkUpdateOneRequiredWithoutChunkBoardsNestedInput
    board?: BoardUpdateOneRequiredWithoutChunkBoardsNestedInput
  }

  export type ChapterChunkBoardUncheckedUpdateInput = {
    chunk_id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterChunkBoardCreateManyInput = {
    chunk_id: bigint | number
    board_id: string
  }

  export type ChapterChunkBoardUpdateManyMutationInput = {

  }

  export type ChapterChunkBoardUncheckedUpdateManyInput = {
    chunk_id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterPageCreateInput = {
    id?: bigint | number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
    chapter: ChapterCreateNestedOneWithoutPagesInput
  }

  export type ChapterPageUncheckedCreateInput = {
    id?: bigint | number
    chapter_id: bigint | number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type ChapterPageUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutPagesNestedInput
  }

  export type ChapterPageUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterPageCreateManyInput = {
    id?: bigint | number
    chapter_id: bigint | number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type ChapterPageUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterPageUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    key: string
    value: string
    type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: number
    key: string
    value: string
    type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutQuizzesInput
    subject: SubjectCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    battles?: BattleCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    user_id: number
    subject_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    battles?: BattleUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQuizzesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    battles?: BattleUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    battles?: BattleUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    user_id: number
    subject_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionCreateInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: boolean | null
    points?: number
    explanation?: string | null
    feedback?: string | null
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    quiz_id: string
    question_text: string
    question_type: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: boolean | null
    points?: number
    explanation?: string | null
    feedback?: string | null
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    quiz_id: string
    question_text: string
    question_type: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: boolean | null
    points?: number
    explanation?: string | null
    feedback?: string | null
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionCreateInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    points?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    chapter: ChapterCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    chapter_id: bigint | number
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    points?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyInput = {
    id?: string
    chapter_id: bigint | number
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    points?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPointsCreateInput = {
    id?: string
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    user: userCreateNestedOneWithoutPointsInput
  }

  export type UserPointsUncheckedCreateInput = {
    id?: string
    user_id: number
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPointsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutPointsNestedInput
  }

  export type UserPointsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPointsCreateManyInput = {
    id?: string
    user_id: number
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPointsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPointsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyMaterialCreateInput = {
    id?: bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: string | null
    video_queries?: StudyMaterialCreatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    chapter: ChapterCreateNestedOneWithoutStudy_materialsInput
  }

  export type StudyMaterialUncheckedCreateInput = {
    id?: bigint | number
    chapter_id: bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: string | null
    video_queries?: StudyMaterialCreatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StudyMaterialUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: NullableStringFieldUpdateOperationsInput | string | null
    video_queries?: StudyMaterialUpdatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutStudy_materialsNestedInput
  }

  export type StudyMaterialUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: NullableStringFieldUpdateOperationsInput | string | null
    video_queries?: StudyMaterialUpdatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyMaterialCreateManyInput = {
    id?: bigint | number
    chapter_id: bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: string | null
    video_queries?: StudyMaterialCreatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StudyMaterialUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: NullableStringFieldUpdateOperationsInput | string | null
    video_queries?: StudyMaterialUpdatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyMaterialUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: NullableStringFieldUpdateOperationsInput | string | null
    video_queries?: StudyMaterialUpdatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    program?: ProgramCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    program_id?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    program_id?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakBadgeCreateInput = {
    id?: string
    name: string
    icon: string
    min_streak: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user_badges?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type StreakBadgeUncheckedCreateInput = {
    id?: string
    name: string
    icon: string
    min_streak: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user_badges?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type StreakBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    min_streak?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_badges?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type StreakBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    min_streak?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_badges?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type StreakBadgeCreateManyInput = {
    id?: string
    name: string
    icon: string
    min_streak: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StreakBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    min_streak?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    min_streak?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateInput = {
    id?: string
    earned_at?: Date | string
    user: userCreateNestedOneWithoutBadgesInput
    badge: StreakBadgeCreateNestedOneWithoutUser_badgesInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    user_id: number
    badge_id: string
    earned_at?: Date | string
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutBadgesNestedInput
    badge?: StreakBadgeUpdateOneRequiredWithoutUser_badgesNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    badge_id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    user_id: number
    badge_id: string
    earned_at?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    badge_id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionCreateInput = {
    id?: string
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutLearning_sessionsInput
    chapter: ChapterCreateNestedOneWithoutLearning_sessionsInput
  }

  export type LearningSessionUncheckedCreateInput = {
    id?: string
    user_id: number
    chapter_id: bigint | number
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LearningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutLearning_sessionsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutLearning_sessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionCreateManyInput = {
    id?: string
    user_id: number
    chapter_id: bigint | number
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LearningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleCreateInput = {
    id?: string
    code: string
    status?: $Enums.BattleStatus
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    quiz: QuizCreateNestedOneWithoutBattlesInput
    creator: userCreateNestedOneWithoutCreated_battlesInput
    participants?: BattleParticipantCreateNestedManyWithoutBattleInput
  }

  export type BattleUncheckedCreateInput = {
    id?: string
    quiz_id: string
    code: string
    status?: $Enums.BattleStatus
    created_by: number
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    participants?: BattleParticipantUncheckedCreateNestedManyWithoutBattleInput
  }

  export type BattleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    quiz?: QuizUpdateOneRequiredWithoutBattlesNestedInput
    creator?: userUpdateOneRequiredWithoutCreated_battlesNestedInput
    participants?: BattleParticipantUpdateManyWithoutBattleNestedInput
  }

  export type BattleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    participants?: BattleParticipantUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type BattleCreateManyInput = {
    id?: string
    quiz_id: string
    code: string
    status?: $Enums.BattleStatus
    created_by: number
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BattleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BattleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BattleParticipantCreateInput = {
    id?: string
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
    battle: BattleCreateNestedOneWithoutParticipantsInput
    user: userCreateNestedOneWithoutBattle_participationsInput
  }

  export type BattleParticipantUncheckedCreateInput = {
    id?: string
    battle_id: string
    user_id: number
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
  }

  export type BattleParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: BattleUpdateOneRequiredWithoutParticipantsNestedInput
    user?: userUpdateOneRequiredWithoutBattle_participationsNestedInput
  }

  export type BattleParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    battle_id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleParticipantCreateManyInput = {
    id?: string
    battle_id: string
    user_id: number
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
  }

  export type BattleParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    battle_id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusCreateInput = {
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
    units?: SyllabusUnitCreateNestedManyWithoutSyllabusInput
    textbooks?: TextbookCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
    units?: SyllabusUnitUncheckedCreateNestedManyWithoutSyllabusInput
    textbooks?: TextbookUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: SyllabusUnitUpdateManyWithoutSyllabusNestedInput
    textbooks?: TextbookUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: SyllabusUnitUncheckedUpdateManyWithoutSyllabusNestedInput
    textbooks?: TextbookUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SyllabusUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusUnitCreateInput = {
    title: string
    order: number
    description?: string | null
    syllabus: SyllabusCreateNestedOneWithoutUnitsInput
    chapters?: SyllabusChapterCreateNestedManyWithoutUnitInput
  }

  export type SyllabusUnitUncheckedCreateInput = {
    id?: number
    syllabus_id: number
    title: string
    order: number
    description?: string | null
    chapters?: SyllabusChapterUncheckedCreateNestedManyWithoutUnitInput
  }

  export type SyllabusUnitUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus?: SyllabusUpdateOneRequiredWithoutUnitsNestedInput
    chapters?: SyllabusChapterUpdateManyWithoutUnitNestedInput
  }

  export type SyllabusUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabus_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: SyllabusChapterUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SyllabusUnitCreateManyInput = {
    id?: number
    syllabus_id: number
    title: string
    order: number
    description?: string | null
  }

  export type SyllabusUnitUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyllabusUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabus_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyllabusChapterCreateInput = {
    chapter_number: string
    title: string
    order: number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    unit: SyllabusUnitCreateNestedOneWithoutChaptersInput
  }

  export type SyllabusChapterUncheckedCreateInput = {
    id?: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUpdateInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    unit?: SyllabusUnitUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type SyllabusChapterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterCreateManyInput = {
    id?: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUpdateManyMutationInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TextbookCreateInput = {
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    syllabus?: SyllabusCreateNestedOneWithoutTextbooksInput
    creator: userCreateNestedOneWithoutTextbooks_createdInput
    units?: TextbookUnitCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
    units?: TextbookUnitUncheckedCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobUncheckedCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    syllabus?: SyllabusUpdateOneWithoutTextbooksNestedInput
    creator?: userUpdateOneRequiredWithoutTextbooks_createdNestedInput
    units?: TextbookUnitUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
    units?: TextbookUnitUncheckedUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUncheckedUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
  }

  export type TextbookUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
  }

  export type TextbookUnitCreateInput = {
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    textbook: TextbookCreateNestedOneWithoutUnitsInput
    chapters?: TextbookChapterCreateNestedManyWithoutUnitInput
  }

  export type TextbookUnitUncheckedCreateInput = {
    id?: number
    textbook_id: number
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    chapters?: TextbookChapterUncheckedCreateNestedManyWithoutUnitInput
  }

  export type TextbookUnitUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    textbook?: TextbookUpdateOneRequiredWithoutUnitsNestedInput
    chapters?: TextbookChapterUpdateManyWithoutUnitNestedInput
  }

  export type TextbookUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: TextbookChapterUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type TextbookUnitCreateManyInput = {
    id?: number
    textbook_id: number
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TextbookUnitUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookChapterCreateInput = {
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    unit: TextbookUnitCreateNestedOneWithoutChaptersInput
    images?: TextbookImageCreateNestedManyWithoutChapterInput
  }

  export type TextbookChapterUncheckedCreateInput = {
    id?: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: TextbookImageUncheckedCreateNestedManyWithoutChapterInput
  }

  export type TextbookChapterUpdateInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: TextbookUnitUpdateOneRequiredWithoutChaptersNestedInput
    images?: TextbookImageUpdateManyWithoutChapterNestedInput
  }

  export type TextbookChapterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: TextbookImageUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type TextbookChapterCreateManyInput = {
    id?: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TextbookChapterUpdateManyMutationInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookChapterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageCreateInput = {
    type: $Enums.TextbookImageType
    prompt?: string | null
    alt_text?: string | null
    url?: string | null
    image_url?: string | null
    order?: number
    placement?: string | null
    caption?: string | null
    status?: $Enums.ImageGenStatus
    model_used?: string | null
    generation_time_ms?: number | null
    generated_at?: Date | string | null
    created_at?: Date | string
    chapter: TextbookChapterCreateNestedOneWithoutImagesInput
  }

  export type TextbookImageUncheckedCreateInput = {
    id?: number
    chapter_id: number
    type: $Enums.TextbookImageType
    prompt?: string | null
    alt_text?: string | null
    url?: string | null
    image_url?: string | null
    order?: number
    placement?: string | null
    caption?: string | null
    status?: $Enums.ImageGenStatus
    model_used?: string | null
    generation_time_ms?: number | null
    generated_at?: Date | string | null
    created_at?: Date | string
  }

  export type TextbookImageUpdateInput = {
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: TextbookChapterUpdateOneRequiredWithoutImagesNestedInput
  }

  export type TextbookImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageCreateManyInput = {
    id?: number
    chapter_id: number
    type: $Enums.TextbookImageType
    prompt?: string | null
    alt_text?: string | null
    url?: string | null
    image_url?: string | null
    order?: number
    placement?: string | null
    caption?: string | null
    status?: $Enums.ImageGenStatus
    model_used?: string | null
    generation_time_ms?: number | null
    generated_at?: Date | string | null
    created_at?: Date | string
  }

  export type TextbookImageUpdateManyMutationInput = {
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapter_id?: IntFieldUpdateOperationsInput | number
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookGenerationJobCreateInput = {
    job_type: $Enums.TextbookGenerationJobType
    status?: $Enums.TextbookJobStatus
    target_id?: number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    progress?: number
    started_at?: Date | string | null
    completed_at?: Date | string | null
    attempts?: number
    max_attempts?: number
    created_at?: Date | string
    textbook: TextbookCreateNestedOneWithoutGeneration_jobsInput
  }

  export type TextbookGenerationJobUncheckedCreateInput = {
    id?: number
    textbook_id: number
    job_type: $Enums.TextbookGenerationJobType
    status?: $Enums.TextbookJobStatus
    target_id?: number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    progress?: number
    started_at?: Date | string | null
    completed_at?: Date | string | null
    attempts?: number
    max_attempts?: number
    created_at?: Date | string
  }

  export type TextbookGenerationJobUpdateInput = {
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    textbook?: TextbookUpdateOneRequiredWithoutGeneration_jobsNestedInput
  }

  export type TextbookGenerationJobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookGenerationJobCreateManyInput = {
    id?: number
    textbook_id: number
    job_type: $Enums.TextbookGenerationJobType
    status?: $Enums.TextbookJobStatus
    target_id?: number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    progress?: number
    started_at?: Date | string | null
    completed_at?: Date | string | null
    attempts?: number
    max_attempts?: number
    created_at?: Date | string
  }

  export type TextbookGenerationJobUpdateManyMutationInput = {
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookGenerationJobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CategoryListCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type CategoryListAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type CategoryListMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type CategoryListMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type CategoryListSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DocumentPageListRelationFilter = {
    every?: DocumentPageWhereInput
    some?: DocumentPageWhereInput
    none?: DocumentPageWhereInput
  }

  export type FileChunkListRelationFilter = {
    every?: FileChunkWhereInput
    some?: FileChunkWhereInput
    none?: FileChunkWhereInput
  }

  export type DocumentPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileListCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    note?: SortOrder
    content_format?: SortOrder
    doc1?: SortOrder
    entry_date?: SortOrder
    entry_date_real?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    parsing_status?: SortOrder
    parsing_error?: SortOrder
    parsed_at?: SortOrder
  }

  export type FileListAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type FileListMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    note?: SortOrder
    content_format?: SortOrder
    doc1?: SortOrder
    entry_date?: SortOrder
    entry_date_real?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    parsing_status?: SortOrder
    parsing_error?: SortOrder
    parsed_at?: SortOrder
  }

  export type FileListMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    note?: SortOrder
    content_format?: SortOrder
    doc1?: SortOrder
    entry_date?: SortOrder
    entry_date_real?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    parsing_status?: SortOrder
    parsing_error?: SortOrder
    parsed_at?: SortOrder
  }

  export type FileListSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FileListScalarRelationFilter = {
    is?: FileListWhereInput
    isNot?: FileListWhereInput
  }

  export type DocumentPageCountOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
  }

  export type DocumentPageAvgOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type DocumentPageMaxOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
  }

  export type DocumentPageMinOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
  }

  export type DocumentPageSumOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    page_number?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FileChunkCountOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrder
    bbox?: SortOrder
    token_count?: SortOrder
    created_at?: SortOrder
  }

  export type FileChunkAvgOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    page_number?: SortOrder
    token_count?: SortOrder
  }

  export type FileChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrder
    token_count?: SortOrder
    created_at?: SortOrder
  }

  export type FileChunkMinOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrder
    token_count?: SortOrder
    created_at?: SortOrder
  }

  export type FileChunkSumOrderByAggregateInput = {
    id?: SortOrder
    file_id?: SortOrder
    chunk_index?: SortOrder
    page_number?: SortOrder
    token_count?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CategoryListListRelationFilter = {
    every?: CategoryListWhereInput
    some?: CategoryListWhereInput
    none?: CategoryListWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type FileListListRelationFilter = {
    every?: FileListWhereInput
    some?: FileListWhereInput
    none?: FileListWhereInput
  }

  export type UsageTrackingListRelationFilter = {
    every?: UsageTrackingWhereInput
    some?: UsageTrackingWhereInput
    none?: UsageTrackingWhereInput
  }

  export type UserSubscriptionNullableScalarRelationFilter = {
    is?: UserSubscriptionWhereInput | null
    isNot?: UserSubscriptionWhereInput | null
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type UserPointsListRelationFilter = {
    every?: UserPointsWhereInput
    some?: UserPointsWhereInput
    none?: UserPointsWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type LearningSessionListRelationFilter = {
    every?: LearningSessionWhereInput
    some?: LearningSessionWhereInput
    none?: LearningSessionWhereInput
  }

  export type BattleListRelationFilter = {
    every?: BattleWhereInput
    some?: BattleWhereInput
    none?: BattleWhereInput
  }

  export type BattleParticipantListRelationFilter = {
    every?: BattleParticipantWhereInput
    some?: BattleParticipantWhereInput
    none?: BattleParticipantWhereInput
  }

  export type TextbookListRelationFilter = {
    every?: TextbookWhereInput
    some?: TextbookWhereInput
    none?: TextbookWhereInput
  }

  export type UserEnrollmentListRelationFilter = {
    every?: UserEnrollmentWhereInput
    some?: UserEnrollmentWhereInput
    none?: UserEnrollmentWhereInput
  }

  export type CategoryListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPointsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BattleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BattleParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TextbookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type TextbookScalarRelationFilter = {
    is?: TextbookWhereInput
    isNot?: TextbookWhereInput
  }

  export type UserEnrollmentUser_idTextbook_idCompoundUniqueInput = {
    user_id: number
    textbook_id: number
  }

  export type UserEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    last_accessed_at?: SortOrder
    enrolled_at?: SortOrder
    completed_at?: SortOrder
  }

  export type UserEnrollmentAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    progress?: SortOrder
  }

  export type UserEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    last_accessed_at?: SortOrder
    enrolled_at?: SortOrder
    completed_at?: SortOrder
  }

  export type UserEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    last_accessed_at?: SortOrder
    enrolled_at?: SortOrder
    completed_at?: SortOrder
  }

  export type UserEnrollmentSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    textbook_id?: SortOrder
    progress?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type ConversationMessageListRelationFilter = {
    every?: ConversationMessageWhereInput
    some?: ConversationMessageWhereInput
    none?: ConversationMessageWhereInput
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type ChapterNullableScalarRelationFilter = {
    is?: ChapterWhereInput | null
    isNot?: ChapterWhereInput | null
  }

  export type ConversationMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_message_at?: SortOrder
    message_count?: SortOrder
    is_pinned?: SortOrder
    is_archived?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message_count?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_message_at?: SortOrder
    message_count?: SortOrder
    is_pinned?: SortOrder
    is_archived?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_message_at?: SortOrder
    message_count?: SortOrder
    is_pinned?: SortOrder
    is_archived?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    message_count?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sources?: SortOrder
    token_count?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type ConversationMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type ConversationMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type ConversationMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type ConversationMessageSumOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
  }

  export type EnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type EnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type AiApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    label?: SortOrder
    api_key_enc?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiApiKeyAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
  }

  export type AiApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    label?: SortOrder
    api_key_enc?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    label?: SortOrder
    api_key_enc?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiApiKeySumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
  }

  export type EnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type AiModelProviderNameCompoundUniqueInput = {
    provider: $Enums.Provider
    name: string
  }

  export type AiModelCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    label?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiModelAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type AiModelMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    label?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiModelMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    label?: SortOrder
    active?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AiModelSumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type app_settingsCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type app_settingsMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type app_settingsMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserSubscriptionListRelationFilter = {
    every?: UserSubscriptionWhereInput
    some?: UserSubscriptionWhereInput
    none?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    description?: SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrder
    razorpay_plan_id_monthly?: SortOrder
    razorpay_plan_id_yearly?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    is_active?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    description?: SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrder
    razorpay_plan_id_monthly?: SortOrder
    razorpay_plan_id_yearly?: SortOrder
    is_active?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    description?: SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrder
    razorpay_plan_id_monthly?: SortOrder
    razorpay_plan_id_yearly?: SortOrder
    is_active?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    id?: SortOrder
    price_monthly?: SortOrder
    price_yearly?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type EnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type SubscriptionPlanScalarRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_subscription_id?: SortOrder
    razorpay_customer_id?: SortOrder
    razorpay_order_id?: SortOrder
    status?: SortOrder
    billing_cycle?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_subscription_id?: SortOrder
    razorpay_customer_id?: SortOrder
    razorpay_order_id?: SortOrder
    status?: SortOrder
    billing_cycle?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    razorpay_subscription_id?: SortOrder
    razorpay_customer_id?: SortOrder
    razorpay_order_id?: SortOrder
    status?: SortOrder
    billing_cycle?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type EnumUsageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeFilter<$PrismaModel> | $Enums.UsageType
  }

  export type UsageTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    usage_type?: SortOrder
    count?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type UsageTrackingAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    count?: SortOrder
  }

  export type UsageTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    usage_type?: SortOrder
    count?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    created_at?: SortOrder
  }

  export type UsageTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    usage_type?: SortOrder
    count?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    created_at?: SortOrder
  }

  export type UsageTrackingSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    count?: SortOrder
  }

  export type EnumUsageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeWithAggregatesFilter<$PrismaModel> | $Enums.UsageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsageTypeFilter<$PrismaModel>
    _max?: NestedEnumUsageTypeFilter<$PrismaModel>
  }

  export type BoardListRelationFilter = {
    every?: BoardWhereInput
    some?: BoardWhereInput
    none?: BoardWhereInput
  }

  export type BoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    is_active?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    is_active?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    is_active?: SortOrder
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type InstitutionListRelationFilter = {
    every?: InstitutionWhereInput
    some?: InstitutionWhereInput
    none?: InstitutionWhereInput
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type ChapterChunkBoardListRelationFilter = {
    every?: ChapterChunkBoardWhereInput
    some?: ChapterChunkBoardWhereInput
    none?: ChapterChunkBoardWhereInput
  }

  export type InstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterChunkBoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country_id?: SortOrder
    state?: SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country_id?: SortOrder
    state?: SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country_id?: SortOrder
    state?: SortOrder
    type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BoardScalarRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    district?: SortOrder
    state?: SortOrder
    license_expiry?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type InstitutionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    district?: SortOrder
    state?: SortOrder
    license_expiry?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type InstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    district?: SortOrder
    state?: SortOrder
    license_expiry?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type InstitutionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type InstitutionNullableScalarRelationFilter = {
    is?: InstitutionWhereInput | null
    isNot?: InstitutionWhereInput | null
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramBoard_idInstitution_idNameCompoundUniqueInput = {
    board_id: string
    institution_id: bigint | number
    name: string
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    institution_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    duration_years?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    duration_years?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    institution_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    duration_years?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    institution_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    duration_years?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    id?: SortOrder
    institution_id?: SortOrder
    duration_years?: SortOrder
  }

  export type ProgramNullableScalarRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    program_id?: SortOrder
    is_premium?: SortOrder
    last_sync_at?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    program_id?: SortOrder
    last_sync_at?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    program_id?: SortOrder
    is_premium?: SortOrder
    last_sync_at?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    program_id?: SortOrder
    is_premium?: SortOrder
    last_sync_at?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    institution_id?: SortOrder
    program_id?: SortOrder
    last_sync_at?: SortOrder
  }

  export type ProgramScalarRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectProgram_idNameCompoundUniqueInput = {
    program_id: number
    name: string
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    program_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    term?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    id?: SortOrder
    program_id?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    program_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    term?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    program_id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    term?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    id?: SortOrder
    program_id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumChapterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusFilter<$PrismaModel> | $Enums.ChapterStatus
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type ChapterChunkListRelationFilter = {
    every?: ChapterChunkWhereInput
    some?: ChapterChunkWhereInput
    none?: ChapterChunkWhereInput
  }

  export type ChapterPageListRelationFilter = {
    every?: ChapterPageWhereInput
    some?: ChapterPageWhereInput
    none?: ChapterPageWhereInput
  }

  export type StudyMaterialNullableScalarRelationFilter = {
    is?: StudyMaterialWhereInput | null
    isNot?: StudyMaterialWhereInput | null
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type ChapterChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    chapter_number?: SortOrder
    content_json?: SortOrder
    version_id?: SortOrder
    accessible_boards?: SortOrder
    is_global?: SortOrder
    is_active?: SortOrder
    processing_status?: SortOrder
    error_message?: SortOrder
    processed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parsed_at?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    chapter_number?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    chapter_number?: SortOrder
    version_id?: SortOrder
    is_global?: SortOrder
    is_active?: SortOrder
    processing_status?: SortOrder
    error_message?: SortOrder
    processed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parsed_at?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    title?: SortOrder
    chapter_number?: SortOrder
    version_id?: SortOrder
    is_global?: SortOrder
    is_active?: SortOrder
    processing_status?: SortOrder
    error_message?: SortOrder
    processed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parsed_at?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    id?: SortOrder
    subject_id?: SortOrder
    chapter_number?: SortOrder
  }

  export type EnumChapterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterStatusFilter<$PrismaModel>
  }

  export type ChapterScalarRelationFilter = {
    is?: ChapterWhereInput
    isNot?: ChapterWhereInput
  }

  export type ChapterChunkCountOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrder
    bbox?: SortOrder
    subject_id?: SortOrder
    created_at?: SortOrder
  }

  export type ChapterChunkAvgOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    page_number?: SortOrder
    subject_id?: SortOrder
  }

  export type ChapterChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrder
    subject_id?: SortOrder
    created_at?: SortOrder
  }

  export type ChapterChunkMinOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    content?: SortOrder
    page_number?: SortOrder
    subject_id?: SortOrder
    created_at?: SortOrder
  }

  export type ChapterChunkSumOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    chunk_index?: SortOrder
    page_number?: SortOrder
    subject_id?: SortOrder
  }

  export type ChapterChunkScalarRelationFilter = {
    is?: ChapterChunkWhereInput
    isNot?: ChapterChunkWhereInput
  }

  export type ChapterChunkBoardChunk_idBoard_idCompoundUniqueInput = {
    chunk_id: bigint | number
    board_id: string
  }

  export type ChapterChunkBoardCountOrderByAggregateInput = {
    chunk_id?: SortOrder
    board_id?: SortOrder
  }

  export type ChapterChunkBoardAvgOrderByAggregateInput = {
    chunk_id?: SortOrder
  }

  export type ChapterChunkBoardMaxOrderByAggregateInput = {
    chunk_id?: SortOrder
    board_id?: SortOrder
  }

  export type ChapterChunkBoardMinOrderByAggregateInput = {
    chunk_id?: SortOrder
    board_id?: SortOrder
  }

  export type ChapterChunkBoardSumOrderByAggregateInput = {
    chunk_id?: SortOrder
  }

  export type ChapterPageCountOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
  }

  export type ChapterPageAvgOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type ChapterPageMaxOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
  }

  export type ChapterPageMinOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    image_url?: SortOrder
    width?: SortOrder
    height?: SortOrder
    created_at?: SortOrder
  }

  export type ChapterPageSumOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    page_number?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumQuizStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizStatus | EnumQuizStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStatusFilter<$PrismaModel> | $Enums.QuizStatus
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    completed_at?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    completed_at?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    completed_at?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    user_id?: SortOrder
    subject_id?: SortOrder
    chapter_id?: SortOrder
    score?: SortOrder
    total_points?: SortOrder
  }

  export type EnumQuizStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizStatus | EnumQuizStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuizStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuizStatusFilter<$PrismaModel>
    _max?: NestedEnumQuizStatusFilter<$PrismaModel>
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    user_answer?: SortOrder
    is_correct?: SortOrder
    points?: SortOrder
    explanation?: SortOrder
    feedback?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    is_correct?: SortOrder
    points?: SortOrder
    explanation?: SortOrder
    feedback?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    is_correct?: SortOrder
    points?: SortOrder
    explanation?: SortOrder
    feedback?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    difficulty?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    explanation?: SortOrder
    points?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    chapter_id?: SortOrder
    points?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    difficulty?: SortOrder
    explanation?: SortOrder
    points?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    difficulty?: SortOrder
    explanation?: SortOrder
    points?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    chapter_id?: SortOrder
    points?: SortOrder
  }

  export type UserPointsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type UserPointsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    points?: SortOrder
  }

  export type UserPointsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type UserPointsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type UserPointsSumOrderByAggregateInput = {
    user_id?: SortOrder
    points?: SortOrder
  }

  export type StudyMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    summary?: SortOrder
    definitions?: SortOrder
    flashcards?: SortOrder
    mind_map?: SortOrder
    video_queries?: SortOrder
    curated_videos?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StudyMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
  }

  export type StudyMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    mind_map?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StudyMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    mind_map?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StudyMaterialSumOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    program_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    program_id?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    program_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    program_id?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    program_id?: SortOrder
  }

  export type StreakBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    min_streak?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StreakBadgeAvgOrderByAggregateInput = {
    min_streak?: SortOrder
  }

  export type StreakBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    min_streak?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StreakBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    min_streak?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StreakBadgeSumOrderByAggregateInput = {
    min_streak?: SortOrder
  }

  export type StreakBadgeScalarRelationFilter = {
    is?: StreakBadgeWhereInput
    isNot?: StreakBadgeWhereInput
  }

  export type UserBadgeUser_idBadge_idCompoundUniqueInput = {
    user_id: number
    badge_id: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    badge_id?: SortOrder
    earned_at?: SortOrder
  }

  export type UserBadgeAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    badge_id?: SortOrder
    earned_at?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    badge_id?: SortOrder
    earned_at?: SortOrder
  }

  export type UserBadgeSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type LearningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    status?: SortOrder
    current_topic?: SortOrder
    progress?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LearningSessionAvgOrderByAggregateInput = {
    user_id?: SortOrder
    chapter_id?: SortOrder
    progress?: SortOrder
  }

  export type LearningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    status?: SortOrder
    current_topic?: SortOrder
    progress?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LearningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    chapter_id?: SortOrder
    status?: SortOrder
    current_topic?: SortOrder
    progress?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type LearningSessionSumOrderByAggregateInput = {
    user_id?: SortOrder
    chapter_id?: SortOrder
    progress?: SortOrder
  }

  export type EnumBattleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusFilter<$PrismaModel> | $Enums.BattleStatus
  }

  export type BattleCountOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
    settings?: SortOrder
  }

  export type BattleAvgOrderByAggregateInput = {
    created_by?: SortOrder
  }

  export type BattleMaxOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
  }

  export type BattleMinOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    code?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrder
    ended_at?: SortOrder
  }

  export type BattleSumOrderByAggregateInput = {
    created_by?: SortOrder
  }

  export type EnumBattleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BattleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleStatusFilter<$PrismaModel>
    _max?: NestedEnumBattleStatusFilter<$PrismaModel>
  }

  export type BattleScalarRelationFilter = {
    is?: BattleWhereInput
    isNot?: BattleWhereInput
  }

  export type BattleParticipantBattle_idUser_idCompoundUniqueInput = {
    battle_id: string
    user_id: number
  }

  export type BattleParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    battle_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
    finished?: SortOrder
    joined_at?: SortOrder
    last_active?: SortOrder
  }

  export type BattleParticipantAvgOrderByAggregateInput = {
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
  }

  export type BattleParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    battle_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
    finished?: SortOrder
    joined_at?: SortOrder
    last_active?: SortOrder
  }

  export type BattleParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    battle_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
    finished?: SortOrder
    joined_at?: SortOrder
    last_active?: SortOrder
  }

  export type BattleParticipantSumOrderByAggregateInput = {
    user_id?: SortOrder
    score?: SortOrder
    current_q_index?: SortOrder
  }

  export type EnumSyllabusStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusStatus | EnumSyllabusStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyllabusStatusFilter<$PrismaModel> | $Enums.SyllabusStatus
  }

  export type SyllabusUnitListRelationFilter = {
    every?: SyllabusUnitWhereInput
    some?: SyllabusUnitWhereInput
    none?: SyllabusUnitWhereInput
  }

  export type SyllabusUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyllabusCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    board?: SortOrder
    class_level?: SortOrder
    stream?: SortOrder
    subject?: SortOrder
    academic_year?: SortOrder
    raw_text?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SyllabusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SyllabusMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    board?: SortOrder
    class_level?: SortOrder
    stream?: SortOrder
    subject?: SortOrder
    academic_year?: SortOrder
    raw_text?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SyllabusMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    board?: SortOrder
    class_level?: SortOrder
    stream?: SortOrder
    subject?: SortOrder
    academic_year?: SortOrder
    raw_text?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SyllabusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSyllabusStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusStatus | EnumSyllabusStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyllabusStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyllabusStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyllabusStatusFilter<$PrismaModel>
    _max?: NestedEnumSyllabusStatusFilter<$PrismaModel>
  }

  export type SyllabusScalarRelationFilter = {
    is?: SyllabusWhereInput
    isNot?: SyllabusWhereInput
  }

  export type SyllabusChapterListRelationFilter = {
    every?: SyllabusChapterWhereInput
    some?: SyllabusChapterWhereInput
    none?: SyllabusChapterWhereInput
  }

  export type SyllabusChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyllabusUnitSyllabus_idOrderCompoundUniqueInput = {
    syllabus_id: number
    order: number
  }

  export type SyllabusUnitCountOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrder
  }

  export type SyllabusUnitAvgOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    order?: SortOrder
  }

  export type SyllabusUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrder
  }

  export type SyllabusUnitMinOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    description?: SortOrder
  }

  export type SyllabusUnitSumOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    order?: SortOrder
  }

  export type SyllabusUnitScalarRelationFilter = {
    is?: SyllabusUnitWhereInput
    isNot?: SyllabusUnitWhereInput
  }

  export type SyllabusChapterUnit_idOrderCompoundUniqueInput = {
    unit_id: number
    order: number
  }

  export type SyllabusChapterCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    subtopics?: SortOrder
  }

  export type SyllabusChapterAvgOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    order?: SortOrder
  }

  export type SyllabusChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type SyllabusChapterMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type SyllabusChapterSumOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    order?: SortOrder
  }

  export type EnumTextbookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookStatus | EnumTextbookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookStatusFilter<$PrismaModel> | $Enums.TextbookStatus
  }

  export type SyllabusNullableScalarRelationFilter = {
    is?: SyllabusWhereInput | null
    isNot?: SyllabusWhereInput | null
  }

  export type TextbookUnitListRelationFilter = {
    every?: TextbookUnitWhereInput
    some?: TextbookUnitWhereInput
    none?: TextbookUnitWhereInput
  }

  export type TextbookGenerationJobListRelationFilter = {
    every?: TextbookGenerationJobWhereInput
    some?: TextbookGenerationJobWhereInput
    none?: TextbookGenerationJobWhereInput
  }

  export type TextbookUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TextbookGenerationJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TextbookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    class_level?: SortOrder
    stream?: SortOrder
    subject_name?: SortOrder
    board_id?: SortOrder
    academic_year?: SortOrder
    author?: SortOrder
    syllabus_id?: SortOrder
    raw_syllabus?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cover_image_url?: SortOrder
    pdf_url?: SortOrder
    compiled_pdf_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type TextbookAvgOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    progress?: SortOrder
    created_by?: SortOrder
  }

  export type TextbookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    class_level?: SortOrder
    stream?: SortOrder
    subject_name?: SortOrder
    board_id?: SortOrder
    academic_year?: SortOrder
    author?: SortOrder
    syllabus_id?: SortOrder
    raw_syllabus?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cover_image_url?: SortOrder
    pdf_url?: SortOrder
    compiled_pdf_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type TextbookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    class_level?: SortOrder
    stream?: SortOrder
    subject_name?: SortOrder
    board_id?: SortOrder
    academic_year?: SortOrder
    author?: SortOrder
    syllabus_id?: SortOrder
    raw_syllabus?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    cover_image_url?: SortOrder
    pdf_url?: SortOrder
    compiled_pdf_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type TextbookSumOrderByAggregateInput = {
    id?: SortOrder
    syllabus_id?: SortOrder
    progress?: SortOrder
    created_by?: SortOrder
  }

  export type EnumTextbookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookStatus | EnumTextbookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookStatusWithAggregatesFilter<$PrismaModel> | $Enums.TextbookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookStatusFilter<$PrismaModel>
    _max?: NestedEnumTextbookStatusFilter<$PrismaModel>
  }

  export type TextbookChapterListRelationFilter = {
    every?: TextbookChapterWhereInput
    some?: TextbookChapterWhereInput
    none?: TextbookChapterWhereInput
  }

  export type TextbookChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TextbookUnitTextbook_idOrderCompoundUniqueInput = {
    textbook_id: number
    order: number
  }

  export type TextbookUnitCountOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TextbookUnitAvgOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
  }

  export type TextbookUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TextbookUnitMinOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TextbookUnitSumOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    order?: SortOrder
  }

  export type EnumChapterGenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterGenStatus | EnumChapterGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterGenStatusFilter<$PrismaModel> | $Enums.ChapterGenStatus
  }

  export type TextbookUnitScalarRelationFilter = {
    is?: TextbookUnitWhereInput
    isNot?: TextbookUnitWhereInput
  }

  export type TextbookImageListRelationFilter = {
    every?: TextbookImageWhereInput
    some?: TextbookImageWhereInput
    none?: TextbookImageWhereInput
  }

  export type TextbookImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TextbookChapterUnit_idOrderCompoundUniqueInput = {
    unit_id: number
    order: number
  }

  export type TextbookChapterCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    raw_syllabus_text?: SortOrder
    subtopics?: SortOrder
    content?: SortOrder
    content_markdown?: SortOrder
    content_html?: SortOrder
    summary?: SortOrder
    learning_outcomes?: SortOrder
    key_takeaways?: SortOrder
    pdf_url?: SortOrder
    generated_at?: SortOrder
    neet_relevant?: SortOrder
    jee_relevant?: SortOrder
    cuet_relevant?: SortOrder
    exam_highlights?: SortOrder
    mcq_questions?: SortOrder
    short_questions?: SortOrder
    long_questions?: SortOrder
    model_used?: SortOrder
    tokens_used?: SortOrder
    generation_time_ms?: SortOrder
    status?: SortOrder
    generation_error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TextbookChapterAvgOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    order?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type TextbookChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    raw_syllabus_text?: SortOrder
    content?: SortOrder
    content_markdown?: SortOrder
    content_html?: SortOrder
    summary?: SortOrder
    pdf_url?: SortOrder
    generated_at?: SortOrder
    neet_relevant?: SortOrder
    jee_relevant?: SortOrder
    cuet_relevant?: SortOrder
    model_used?: SortOrder
    generation_time_ms?: SortOrder
    status?: SortOrder
    generation_error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TextbookChapterMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    chapter_number?: SortOrder
    title?: SortOrder
    order?: SortOrder
    raw_syllabus_text?: SortOrder
    content?: SortOrder
    content_markdown?: SortOrder
    content_html?: SortOrder
    summary?: SortOrder
    pdf_url?: SortOrder
    generated_at?: SortOrder
    neet_relevant?: SortOrder
    jee_relevant?: SortOrder
    cuet_relevant?: SortOrder
    model_used?: SortOrder
    generation_time_ms?: SortOrder
    status?: SortOrder
    generation_error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TextbookChapterSumOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    order?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type EnumChapterGenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterGenStatus | EnumChapterGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterGenStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterGenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterGenStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterGenStatusFilter<$PrismaModel>
  }

  export type EnumTextbookImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookImageType | EnumTextbookImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookImageTypeFilter<$PrismaModel> | $Enums.TextbookImageType
  }

  export type EnumImageGenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageGenStatus | EnumImageGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImageGenStatusFilter<$PrismaModel> | $Enums.ImageGenStatus
  }

  export type TextbookChapterScalarRelationFilter = {
    is?: TextbookChapterWhereInput
    isNot?: TextbookChapterWhereInput
  }

  export type TextbookImageCountOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    alt_text?: SortOrder
    url?: SortOrder
    image_url?: SortOrder
    order?: SortOrder
    placement?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    model_used?: SortOrder
    generation_time_ms?: SortOrder
    generated_at?: SortOrder
    created_at?: SortOrder
  }

  export type TextbookImageAvgOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    order?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type TextbookImageMaxOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    alt_text?: SortOrder
    url?: SortOrder
    image_url?: SortOrder
    order?: SortOrder
    placement?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    model_used?: SortOrder
    generation_time_ms?: SortOrder
    generated_at?: SortOrder
    created_at?: SortOrder
  }

  export type TextbookImageMinOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    alt_text?: SortOrder
    url?: SortOrder
    image_url?: SortOrder
    order?: SortOrder
    placement?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    model_used?: SortOrder
    generation_time_ms?: SortOrder
    generated_at?: SortOrder
    created_at?: SortOrder
  }

  export type TextbookImageSumOrderByAggregateInput = {
    id?: SortOrder
    chapter_id?: SortOrder
    order?: SortOrder
    generation_time_ms?: SortOrder
  }

  export type EnumTextbookImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookImageType | EnumTextbookImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.TextbookImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookImageTypeFilter<$PrismaModel>
    _max?: NestedEnumTextbookImageTypeFilter<$PrismaModel>
  }

  export type EnumImageGenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageGenStatus | EnumImageGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImageGenStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImageGenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageGenStatusFilter<$PrismaModel>
    _max?: NestedEnumImageGenStatusFilter<$PrismaModel>
  }

  export type EnumTextbookGenerationJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookGenerationJobType | EnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel> | $Enums.TextbookGenerationJobType
  }

  export type EnumTextbookJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookJobStatus | EnumTextbookJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookJobStatusFilter<$PrismaModel> | $Enums.TextbookJobStatus
  }

  export type TextbookGenerationJobCountOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    target_id?: SortOrder
    input_data?: SortOrder
    output_data?: SortOrder
    error_message?: SortOrder
    progress?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
    created_at?: SortOrder
  }

  export type TextbookGenerationJobAvgOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    target_id?: SortOrder
    progress?: SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
  }

  export type TextbookGenerationJobMaxOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    target_id?: SortOrder
    error_message?: SortOrder
    progress?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
    created_at?: SortOrder
  }

  export type TextbookGenerationJobMinOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    target_id?: SortOrder
    error_message?: SortOrder
    progress?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
    created_at?: SortOrder
  }

  export type TextbookGenerationJobSumOrderByAggregateInput = {
    id?: SortOrder
    textbook_id?: SortOrder
    target_id?: SortOrder
    progress?: SortOrder
    attempts?: SortOrder
    max_attempts?: SortOrder
  }

  export type EnumTextbookGenerationJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookGenerationJobType | EnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookGenerationJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.TextbookGenerationJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel>
    _max?: NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel>
  }

  export type EnumTextbookJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookJobStatus | EnumTextbookJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.TextbookJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookJobStatusFilter<$PrismaModel>
    _max?: NestedEnumTextbookJobStatusFilter<$PrismaModel>
  }

  export type userCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<userCreateWithoutCategoriesInput, userUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: userCreateOrConnectWithoutCategoriesInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<userCreateWithoutCategoriesInput, userUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: userCreateOrConnectWithoutCategoriesInput
    upsert?: userUpsertWithoutCategoriesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCategoriesInput, userUpdateWithoutCategoriesInput>, userUncheckedUpdateWithoutCategoriesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutFilesInput = {
    create?: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
    connectOrCreate?: userCreateOrConnectWithoutFilesInput
    connect?: userWhereUniqueInput
  }

  export type DocumentPageCreateNestedManyWithoutFileInput = {
    create?: XOR<DocumentPageCreateWithoutFileInput, DocumentPageUncheckedCreateWithoutFileInput> | DocumentPageCreateWithoutFileInput[] | DocumentPageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutFileInput | DocumentPageCreateOrConnectWithoutFileInput[]
    createMany?: DocumentPageCreateManyFileInputEnvelope
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
  }

  export type FileChunkCreateNestedManyWithoutFileInput = {
    create?: XOR<FileChunkCreateWithoutFileInput, FileChunkUncheckedCreateWithoutFileInput> | FileChunkCreateWithoutFileInput[] | FileChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileChunkCreateOrConnectWithoutFileInput | FileChunkCreateOrConnectWithoutFileInput[]
    createMany?: FileChunkCreateManyFileInputEnvelope
    connect?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
  }

  export type DocumentPageUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<DocumentPageCreateWithoutFileInput, DocumentPageUncheckedCreateWithoutFileInput> | DocumentPageCreateWithoutFileInput[] | DocumentPageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutFileInput | DocumentPageCreateOrConnectWithoutFileInput[]
    createMany?: DocumentPageCreateManyFileInputEnvelope
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
  }

  export type FileChunkUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<FileChunkCreateWithoutFileInput, FileChunkUncheckedCreateWithoutFileInput> | FileChunkCreateWithoutFileInput[] | FileChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileChunkCreateOrConnectWithoutFileInput | FileChunkCreateOrConnectWithoutFileInput[]
    createMany?: FileChunkCreateManyFileInputEnvelope
    connect?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userUpdateOneWithoutFilesNestedInput = {
    create?: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
    connectOrCreate?: userCreateOrConnectWithoutFilesInput
    upsert?: userUpsertWithoutFilesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFilesInput, userUpdateWithoutFilesInput>, userUncheckedUpdateWithoutFilesInput>
  }

  export type DocumentPageUpdateManyWithoutFileNestedInput = {
    create?: XOR<DocumentPageCreateWithoutFileInput, DocumentPageUncheckedCreateWithoutFileInput> | DocumentPageCreateWithoutFileInput[] | DocumentPageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutFileInput | DocumentPageCreateOrConnectWithoutFileInput[]
    upsert?: DocumentPageUpsertWithWhereUniqueWithoutFileInput | DocumentPageUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DocumentPageCreateManyFileInputEnvelope
    set?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    disconnect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    delete?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    update?: DocumentPageUpdateWithWhereUniqueWithoutFileInput | DocumentPageUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DocumentPageUpdateManyWithWhereWithoutFileInput | DocumentPageUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
  }

  export type FileChunkUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileChunkCreateWithoutFileInput, FileChunkUncheckedCreateWithoutFileInput> | FileChunkCreateWithoutFileInput[] | FileChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileChunkCreateOrConnectWithoutFileInput | FileChunkCreateOrConnectWithoutFileInput[]
    upsert?: FileChunkUpsertWithWhereUniqueWithoutFileInput | FileChunkUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileChunkCreateManyFileInputEnvelope
    set?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    disconnect?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    delete?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    connect?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    update?: FileChunkUpdateWithWhereUniqueWithoutFileInput | FileChunkUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileChunkUpdateManyWithWhereWithoutFileInput | FileChunkUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileChunkScalarWhereInput | FileChunkScalarWhereInput[]
  }

  export type DocumentPageUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<DocumentPageCreateWithoutFileInput, DocumentPageUncheckedCreateWithoutFileInput> | DocumentPageCreateWithoutFileInput[] | DocumentPageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutFileInput | DocumentPageCreateOrConnectWithoutFileInput[]
    upsert?: DocumentPageUpsertWithWhereUniqueWithoutFileInput | DocumentPageUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DocumentPageCreateManyFileInputEnvelope
    set?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    disconnect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    delete?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    update?: DocumentPageUpdateWithWhereUniqueWithoutFileInput | DocumentPageUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DocumentPageUpdateManyWithWhereWithoutFileInput | DocumentPageUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
  }

  export type FileChunkUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileChunkCreateWithoutFileInput, FileChunkUncheckedCreateWithoutFileInput> | FileChunkCreateWithoutFileInput[] | FileChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileChunkCreateOrConnectWithoutFileInput | FileChunkCreateOrConnectWithoutFileInput[]
    upsert?: FileChunkUpsertWithWhereUniqueWithoutFileInput | FileChunkUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileChunkCreateManyFileInputEnvelope
    set?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    disconnect?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    delete?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    connect?: FileChunkWhereUniqueInput | FileChunkWhereUniqueInput[]
    update?: FileChunkUpdateWithWhereUniqueWithoutFileInput | FileChunkUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileChunkUpdateManyWithWhereWithoutFileInput | FileChunkUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileChunkScalarWhereInput | FileChunkScalarWhereInput[]
  }

  export type FileListCreateNestedOneWithoutPagesInput = {
    create?: XOR<FileListCreateWithoutPagesInput, FileListUncheckedCreateWithoutPagesInput>
    connectOrCreate?: FileListCreateOrConnectWithoutPagesInput
    connect?: FileListWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FileListUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<FileListCreateWithoutPagesInput, FileListUncheckedCreateWithoutPagesInput>
    connectOrCreate?: FileListCreateOrConnectWithoutPagesInput
    upsert?: FileListUpsertWithoutPagesInput
    connect?: FileListWhereUniqueInput
    update?: XOR<XOR<FileListUpdateToOneWithWhereWithoutPagesInput, FileListUpdateWithoutPagesInput>, FileListUncheckedUpdateWithoutPagesInput>
  }

  export type FileListCreateNestedOneWithoutChunksInput = {
    create?: XOR<FileListCreateWithoutChunksInput, FileListUncheckedCreateWithoutChunksInput>
    connectOrCreate?: FileListCreateOrConnectWithoutChunksInput
    connect?: FileListWhereUniqueInput
  }

  export type FileListUpdateOneRequiredWithoutChunksNestedInput = {
    create?: XOR<FileListCreateWithoutChunksInput, FileListUncheckedCreateWithoutChunksInput>
    connectOrCreate?: FileListCreateOrConnectWithoutChunksInput
    upsert?: FileListUpsertWithoutChunksInput
    connect?: FileListWhereUniqueInput
    update?: XOR<XOR<FileListUpdateToOneWithWhereWithoutChunksInput, FileListUpdateWithoutChunksInput>, FileListUncheckedUpdateWithoutChunksInput>
  }

  export type CategoryListCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryListCreateWithoutUserInput, CategoryListUncheckedCreateWithoutUserInput> | CategoryListCreateWithoutUserInput[] | CategoryListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryListCreateOrConnectWithoutUserInput | CategoryListCreateOrConnectWithoutUserInput[]
    createMany?: CategoryListCreateManyUserInputEnvelope
    connect?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type FileListCreateNestedManyWithoutUserInput = {
    create?: XOR<FileListCreateWithoutUserInput, FileListUncheckedCreateWithoutUserInput> | FileListCreateWithoutUserInput[] | FileListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileListCreateOrConnectWithoutUserInput | FileListCreateOrConnectWithoutUserInput[]
    createMany?: FileListCreateManyUserInputEnvelope
    connect?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
  }

  export type UsageTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type QuizCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserPointsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPointsCreateWithoutUserInput, UserPointsUncheckedCreateWithoutUserInput> | UserPointsCreateWithoutUserInput[] | UserPointsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPointsCreateOrConnectWithoutUserInput | UserPointsCreateOrConnectWithoutUserInput[]
    createMany?: UserPointsCreateManyUserInputEnvelope
    connect?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type LearningSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<BattleCreateWithoutCreatorInput, BattleUncheckedCreateWithoutCreatorInput> | BattleCreateWithoutCreatorInput[] | BattleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutCreatorInput | BattleCreateOrConnectWithoutCreatorInput[]
    createMany?: BattleCreateManyCreatorInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<BattleParticipantCreateWithoutUserInput, BattleParticipantUncheckedCreateWithoutUserInput> | BattleParticipantCreateWithoutUserInput[] | BattleParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutUserInput | BattleParticipantCreateOrConnectWithoutUserInput[]
    createMany?: BattleParticipantCreateManyUserInputEnvelope
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
  }

  export type TextbookCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TextbookCreateWithoutCreatorInput, TextbookUncheckedCreateWithoutCreatorInput> | TextbookCreateWithoutCreatorInput[] | TextbookUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutCreatorInput | TextbookCreateOrConnectWithoutCreatorInput[]
    createMany?: TextbookCreateManyCreatorInputEnvelope
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
  }

  export type UserEnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEnrollmentCreateWithoutUserInput, UserEnrollmentUncheckedCreateWithoutUserInput> | UserEnrollmentCreateWithoutUserInput[] | UserEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutUserInput | UserEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: UserEnrollmentCreateManyUserInputEnvelope
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
  }

  export type CategoryListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryListCreateWithoutUserInput, CategoryListUncheckedCreateWithoutUserInput> | CategoryListCreateWithoutUserInput[] | CategoryListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryListCreateOrConnectWithoutUserInput | CategoryListCreateOrConnectWithoutUserInput[]
    createMany?: CategoryListCreateManyUserInputEnvelope
    connect?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type FileListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileListCreateWithoutUserInput, FileListUncheckedCreateWithoutUserInput> | FileListCreateWithoutUserInput[] | FileListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileListCreateOrConnectWithoutUserInput | FileListCreateOrConnectWithoutUserInput[]
    createMany?: FileListCreateManyUserInputEnvelope
    connect?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
  }

  export type UsageTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    connect?: UserSubscriptionWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type QuizUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserPointsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPointsCreateWithoutUserInput, UserPointsUncheckedCreateWithoutUserInput> | UserPointsCreateWithoutUserInput[] | UserPointsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPointsCreateOrConnectWithoutUserInput | UserPointsCreateOrConnectWithoutUserInput[]
    createMany?: UserPointsCreateManyUserInputEnvelope
    connect?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type LearningSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<BattleCreateWithoutCreatorInput, BattleUncheckedCreateWithoutCreatorInput> | BattleCreateWithoutCreatorInput[] | BattleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutCreatorInput | BattleCreateOrConnectWithoutCreatorInput[]
    createMany?: BattleCreateManyCreatorInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type BattleParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BattleParticipantCreateWithoutUserInput, BattleParticipantUncheckedCreateWithoutUserInput> | BattleParticipantCreateWithoutUserInput[] | BattleParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutUserInput | BattleParticipantCreateOrConnectWithoutUserInput[]
    createMany?: BattleParticipantCreateManyUserInputEnvelope
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
  }

  export type TextbookUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TextbookCreateWithoutCreatorInput, TextbookUncheckedCreateWithoutCreatorInput> | TextbookCreateWithoutCreatorInput[] | TextbookUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutCreatorInput | TextbookCreateOrConnectWithoutCreatorInput[]
    createMany?: TextbookCreateManyCreatorInputEnvelope
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
  }

  export type UserEnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEnrollmentCreateWithoutUserInput, UserEnrollmentUncheckedCreateWithoutUserInput> | UserEnrollmentCreateWithoutUserInput[] | UserEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutUserInput | UserEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: UserEnrollmentCreateManyUserInputEnvelope
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CategoryListUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryListCreateWithoutUserInput, CategoryListUncheckedCreateWithoutUserInput> | CategoryListCreateWithoutUserInput[] | CategoryListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryListCreateOrConnectWithoutUserInput | CategoryListCreateOrConnectWithoutUserInput[]
    upsert?: CategoryListUpsertWithWhereUniqueWithoutUserInput | CategoryListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryListCreateManyUserInputEnvelope
    set?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    disconnect?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    delete?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    connect?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    update?: CategoryListUpdateWithWhereUniqueWithoutUserInput | CategoryListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryListUpdateManyWithWhereWithoutUserInput | CategoryListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryListScalarWhereInput | CategoryListScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type FileListUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileListCreateWithoutUserInput, FileListUncheckedCreateWithoutUserInput> | FileListCreateWithoutUserInput[] | FileListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileListCreateOrConnectWithoutUserInput | FileListCreateOrConnectWithoutUserInput[]
    upsert?: FileListUpsertWithWhereUniqueWithoutUserInput | FileListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileListCreateManyUserInputEnvelope
    set?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    disconnect?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    delete?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    connect?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    update?: FileListUpdateWithWhereUniqueWithoutUserInput | FileListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileListUpdateManyWithWhereWithoutUserInput | FileListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileListScalarWhereInput | FileListScalarWhereInput[]
  }

  export type UsageTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    upsert?: UsageTrackingUpsertWithWhereUniqueWithoutUserInput | UsageTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    set?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    disconnect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    delete?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    update?: UsageTrackingUpdateWithWhereUniqueWithoutUserInput | UsageTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageTrackingUpdateManyWithWhereWithoutUserInput | UsageTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
  }

  export type UserSubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    upsert?: UserSubscriptionUpsertWithoutUserInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUserInput, UserSubscriptionUpdateWithoutUserInput>, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type QuizUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutUserInput | QuizUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutUserInput | QuizUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutUserInput | QuizUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserPointsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPointsCreateWithoutUserInput, UserPointsUncheckedCreateWithoutUserInput> | UserPointsCreateWithoutUserInput[] | UserPointsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPointsCreateOrConnectWithoutUserInput | UserPointsCreateOrConnectWithoutUserInput[]
    upsert?: UserPointsUpsertWithWhereUniqueWithoutUserInput | UserPointsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPointsCreateManyUserInputEnvelope
    set?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    disconnect?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    delete?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    connect?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    update?: UserPointsUpdateWithWhereUniqueWithoutUserInput | UserPointsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPointsUpdateManyWithWhereWithoutUserInput | UserPointsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPointsScalarWhereInput | UserPointsScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type LearningSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutUserInput | LearningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutUserInput | LearningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutUserInput | LearningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<BattleCreateWithoutCreatorInput, BattleUncheckedCreateWithoutCreatorInput> | BattleCreateWithoutCreatorInput[] | BattleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutCreatorInput | BattleCreateOrConnectWithoutCreatorInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutCreatorInput | BattleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: BattleCreateManyCreatorInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutCreatorInput | BattleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutCreatorInput | BattleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<BattleParticipantCreateWithoutUserInput, BattleParticipantUncheckedCreateWithoutUserInput> | BattleParticipantCreateWithoutUserInput[] | BattleParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutUserInput | BattleParticipantCreateOrConnectWithoutUserInput[]
    upsert?: BattleParticipantUpsertWithWhereUniqueWithoutUserInput | BattleParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BattleParticipantCreateManyUserInputEnvelope
    set?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    disconnect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    delete?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    update?: BattleParticipantUpdateWithWhereUniqueWithoutUserInput | BattleParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BattleParticipantUpdateManyWithWhereWithoutUserInput | BattleParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BattleParticipantScalarWhereInput | BattleParticipantScalarWhereInput[]
  }

  export type TextbookUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TextbookCreateWithoutCreatorInput, TextbookUncheckedCreateWithoutCreatorInput> | TextbookCreateWithoutCreatorInput[] | TextbookUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutCreatorInput | TextbookCreateOrConnectWithoutCreatorInput[]
    upsert?: TextbookUpsertWithWhereUniqueWithoutCreatorInput | TextbookUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TextbookCreateManyCreatorInputEnvelope
    set?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    disconnect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    delete?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    update?: TextbookUpdateWithWhereUniqueWithoutCreatorInput | TextbookUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TextbookUpdateManyWithWhereWithoutCreatorInput | TextbookUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TextbookScalarWhereInput | TextbookScalarWhereInput[]
  }

  export type UserEnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEnrollmentCreateWithoutUserInput, UserEnrollmentUncheckedCreateWithoutUserInput> | UserEnrollmentCreateWithoutUserInput[] | UserEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutUserInput | UserEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: UserEnrollmentUpsertWithWhereUniqueWithoutUserInput | UserEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEnrollmentCreateManyUserInputEnvelope
    set?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    disconnect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    delete?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    update?: UserEnrollmentUpdateWithWhereUniqueWithoutUserInput | UserEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEnrollmentUpdateManyWithWhereWithoutUserInput | UserEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEnrollmentScalarWhereInput | UserEnrollmentScalarWhereInput[]
  }

  export type CategoryListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryListCreateWithoutUserInput, CategoryListUncheckedCreateWithoutUserInput> | CategoryListCreateWithoutUserInput[] | CategoryListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryListCreateOrConnectWithoutUserInput | CategoryListCreateOrConnectWithoutUserInput[]
    upsert?: CategoryListUpsertWithWhereUniqueWithoutUserInput | CategoryListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryListCreateManyUserInputEnvelope
    set?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    disconnect?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    delete?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    connect?: CategoryListWhereUniqueInput | CategoryListWhereUniqueInput[]
    update?: CategoryListUpdateWithWhereUniqueWithoutUserInput | CategoryListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryListUpdateManyWithWhereWithoutUserInput | CategoryListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryListScalarWhereInput | CategoryListScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type FileListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileListCreateWithoutUserInput, FileListUncheckedCreateWithoutUserInput> | FileListCreateWithoutUserInput[] | FileListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileListCreateOrConnectWithoutUserInput | FileListCreateOrConnectWithoutUserInput[]
    upsert?: FileListUpsertWithWhereUniqueWithoutUserInput | FileListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileListCreateManyUserInputEnvelope
    set?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    disconnect?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    delete?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    connect?: FileListWhereUniqueInput | FileListWhereUniqueInput[]
    update?: FileListUpdateWithWhereUniqueWithoutUserInput | FileListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileListUpdateManyWithWhereWithoutUserInput | FileListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileListScalarWhereInput | FileListScalarWhereInput[]
  }

  export type UsageTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput> | UsageTrackingCreateWithoutUserInput[] | UsageTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageTrackingCreateOrConnectWithoutUserInput | UsageTrackingCreateOrConnectWithoutUserInput[]
    upsert?: UsageTrackingUpsertWithWhereUniqueWithoutUserInput | UsageTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageTrackingCreateManyUserInputEnvelope
    set?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    disconnect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    delete?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    connect?: UsageTrackingWhereUniqueInput | UsageTrackingWhereUniqueInput[]
    update?: UsageTrackingUpdateWithWhereUniqueWithoutUserInput | UsageTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageTrackingUpdateManyWithWhereWithoutUserInput | UsageTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput
    upsert?: UserSubscriptionUpsertWithoutUserInput
    disconnect?: UserSubscriptionWhereInput | boolean
    delete?: UserSubscriptionWhereInput | boolean
    connect?: UserSubscriptionWhereUniqueInput
    update?: XOR<XOR<UserSubscriptionUpdateToOneWithWhereWithoutUserInput, UserSubscriptionUpdateWithoutUserInput>, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type QuizUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput> | QuizCreateWithoutUserInput[] | QuizUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutUserInput | QuizCreateOrConnectWithoutUserInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutUserInput | QuizUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizCreateManyUserInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutUserInput | QuizUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutUserInput | QuizUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserPointsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPointsCreateWithoutUserInput, UserPointsUncheckedCreateWithoutUserInput> | UserPointsCreateWithoutUserInput[] | UserPointsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPointsCreateOrConnectWithoutUserInput | UserPointsCreateOrConnectWithoutUserInput[]
    upsert?: UserPointsUpsertWithWhereUniqueWithoutUserInput | UserPointsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPointsCreateManyUserInputEnvelope
    set?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    disconnect?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    delete?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    connect?: UserPointsWhereUniqueInput | UserPointsWhereUniqueInput[]
    update?: UserPointsUpdateWithWhereUniqueWithoutUserInput | UserPointsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPointsUpdateManyWithWhereWithoutUserInput | UserPointsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPointsScalarWhereInput | UserPointsScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type LearningSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput> | LearningSessionCreateWithoutUserInput[] | LearningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutUserInput | LearningSessionCreateOrConnectWithoutUserInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutUserInput | LearningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningSessionCreateManyUserInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutUserInput | LearningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutUserInput | LearningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<BattleCreateWithoutCreatorInput, BattleUncheckedCreateWithoutCreatorInput> | BattleCreateWithoutCreatorInput[] | BattleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutCreatorInput | BattleCreateOrConnectWithoutCreatorInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutCreatorInput | BattleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: BattleCreateManyCreatorInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutCreatorInput | BattleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutCreatorInput | BattleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type BattleParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BattleParticipantCreateWithoutUserInput, BattleParticipantUncheckedCreateWithoutUserInput> | BattleParticipantCreateWithoutUserInput[] | BattleParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutUserInput | BattleParticipantCreateOrConnectWithoutUserInput[]
    upsert?: BattleParticipantUpsertWithWhereUniqueWithoutUserInput | BattleParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BattleParticipantCreateManyUserInputEnvelope
    set?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    disconnect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    delete?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    update?: BattleParticipantUpdateWithWhereUniqueWithoutUserInput | BattleParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BattleParticipantUpdateManyWithWhereWithoutUserInput | BattleParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BattleParticipantScalarWhereInput | BattleParticipantScalarWhereInput[]
  }

  export type TextbookUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TextbookCreateWithoutCreatorInput, TextbookUncheckedCreateWithoutCreatorInput> | TextbookCreateWithoutCreatorInput[] | TextbookUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutCreatorInput | TextbookCreateOrConnectWithoutCreatorInput[]
    upsert?: TextbookUpsertWithWhereUniqueWithoutCreatorInput | TextbookUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TextbookCreateManyCreatorInputEnvelope
    set?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    disconnect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    delete?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    update?: TextbookUpdateWithWhereUniqueWithoutCreatorInput | TextbookUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TextbookUpdateManyWithWhereWithoutCreatorInput | TextbookUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TextbookScalarWhereInput | TextbookScalarWhereInput[]
  }

  export type UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEnrollmentCreateWithoutUserInput, UserEnrollmentUncheckedCreateWithoutUserInput> | UserEnrollmentCreateWithoutUserInput[] | UserEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutUserInput | UserEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: UserEnrollmentUpsertWithWhereUniqueWithoutUserInput | UserEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEnrollmentCreateManyUserInputEnvelope
    set?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    disconnect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    delete?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    update?: UserEnrollmentUpdateWithWhereUniqueWithoutUserInput | UserEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEnrollmentUpdateManyWithWhereWithoutUserInput | UserEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEnrollmentScalarWhereInput | UserEnrollmentScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<userCreateWithoutEnrollmentsInput, userUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: userCreateOrConnectWithoutEnrollmentsInput
    connect?: userWhereUniqueInput
  }

  export type TextbookCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<TextbookCreateWithoutEnrollmentsInput, TextbookUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TextbookCreateOrConnectWithoutEnrollmentsInput
    connect?: TextbookWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<userCreateWithoutEnrollmentsInput, userUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: userCreateOrConnectWithoutEnrollmentsInput
    upsert?: userUpsertWithoutEnrollmentsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEnrollmentsInput, userUpdateWithoutEnrollmentsInput>, userUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type TextbookUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<TextbookCreateWithoutEnrollmentsInput, TextbookUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: TextbookCreateOrConnectWithoutEnrollmentsInput
    upsert?: TextbookUpsertWithoutEnrollmentsInput
    connect?: TextbookWhereUniqueInput
    update?: XOR<XOR<TextbookUpdateToOneWithWhereWithoutEnrollmentsInput, TextbookUpdateWithoutEnrollmentsInput>, TextbookUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ConversationMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutConversationsInput = {
    create?: XOR<userCreateWithoutConversationsInput, userUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: userCreateOrConnectWithoutConversationsInput
    connect?: userWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutConversationsInput = {
    create?: XOR<SubjectCreateWithoutConversationsInput, SubjectUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutConversationsInput
    connect?: SubjectWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ChapterCreateWithoutConversationsInput, ChapterUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutConversationsInput
    connect?: ChapterWhereUniqueInput
  }

  export type ConversationMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ConversationMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutConversationInput | ConversationMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutConversationInput | ConversationMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutConversationInput | ConversationMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<userCreateWithoutConversationsInput, userUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: userCreateOrConnectWithoutConversationsInput
    upsert?: userUpsertWithoutConversationsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutConversationsInput, userUpdateWithoutConversationsInput>, userUncheckedUpdateWithoutConversationsInput>
  }

  export type SubjectUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<SubjectCreateWithoutConversationsInput, SubjectUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutConversationsInput
    upsert?: SubjectUpsertWithoutConversationsInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutConversationsInput, SubjectUpdateWithoutConversationsInput>, SubjectUncheckedUpdateWithoutConversationsInput>
  }

  export type ChapterUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<ChapterCreateWithoutConversationsInput, ChapterUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutConversationsInput
    upsert?: ChapterUpsertWithoutConversationsInput
    disconnect?: ChapterWhereInput | boolean
    delete?: ChapterWhereInput | boolean
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutConversationsInput, ChapterUpdateWithoutConversationsInput>, ChapterUncheckedUpdateWithoutConversationsInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutConversationInput | ConversationMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutConversationInput | ConversationMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutConversationInput | ConversationMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumMessageRoleFieldUpdateOperationsInput = {
    set?: $Enums.MessageRole
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type EnumProviderFieldUpdateOperationsInput = {
    set?: $Enums.Provider
  }

  export type UserSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: userCreateOrConnectWithoutSubscriptionInput
    connect?: userWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type EnumBillingCycleFieldUpdateOperationsInput = {
    set?: $Enums.BillingCycle
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type userUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: userCreateOrConnectWithoutSubscriptionInput
    upsert?: userUpsertWithoutSubscriptionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSubscriptionInput, userUpdateWithoutSubscriptionInput>, userUncheckedUpdateWithoutSubscriptionInput>
  }

  export type userCreateNestedOneWithoutUsage_trackingInput = {
    create?: XOR<userCreateWithoutUsage_trackingInput, userUncheckedCreateWithoutUsage_trackingInput>
    connectOrCreate?: userCreateOrConnectWithoutUsage_trackingInput
    connect?: userWhereUniqueInput
  }

  export type EnumUsageTypeFieldUpdateOperationsInput = {
    set?: $Enums.UsageType
  }

  export type userUpdateOneRequiredWithoutUsage_trackingNestedInput = {
    create?: XOR<userCreateWithoutUsage_trackingInput, userUncheckedCreateWithoutUsage_trackingInput>
    connectOrCreate?: userCreateOrConnectWithoutUsage_trackingInput
    upsert?: userUpsertWithoutUsage_trackingInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUsage_trackingInput, userUpdateWithoutUsage_trackingInput>, userUncheckedUpdateWithoutUsage_trackingInput>
  }

  export type BoardCreateNestedManyWithoutCountryInput = {
    create?: XOR<BoardCreateWithoutCountryInput, BoardUncheckedCreateWithoutCountryInput> | BoardCreateWithoutCountryInput[] | BoardUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutCountryInput | BoardCreateOrConnectWithoutCountryInput[]
    createMany?: BoardCreateManyCountryInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type BoardUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<BoardCreateWithoutCountryInput, BoardUncheckedCreateWithoutCountryInput> | BoardCreateWithoutCountryInput[] | BoardUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutCountryInput | BoardCreateOrConnectWithoutCountryInput[]
    createMany?: BoardCreateManyCountryInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type BoardUpdateManyWithoutCountryNestedInput = {
    create?: XOR<BoardCreateWithoutCountryInput, BoardUncheckedCreateWithoutCountryInput> | BoardCreateWithoutCountryInput[] | BoardUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutCountryInput | BoardCreateOrConnectWithoutCountryInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutCountryInput | BoardUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: BoardCreateManyCountryInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutCountryInput | BoardUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutCountryInput | BoardUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type BoardUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<BoardCreateWithoutCountryInput, BoardUncheckedCreateWithoutCountryInput> | BoardCreateWithoutCountryInput[] | BoardUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutCountryInput | BoardCreateOrConnectWithoutCountryInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutCountryInput | BoardUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: BoardCreateManyCountryInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutCountryInput | BoardUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutCountryInput | BoardUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutBoardsInput = {
    create?: XOR<CountryCreateWithoutBoardsInput, CountryUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutBoardsInput
    connect?: CountryWhereUniqueInput
  }

  export type InstitutionCreateNestedManyWithoutBoardInput = {
    create?: XOR<InstitutionCreateWithoutBoardInput, InstitutionUncheckedCreateWithoutBoardInput> | InstitutionCreateWithoutBoardInput[] | InstitutionUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutBoardInput | InstitutionCreateOrConnectWithoutBoardInput[]
    createMany?: InstitutionCreateManyBoardInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutBoardInput = {
    create?: XOR<ProgramCreateWithoutBoardInput, ProgramUncheckedCreateWithoutBoardInput> | ProgramCreateWithoutBoardInput[] | ProgramUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutBoardInput | ProgramCreateOrConnectWithoutBoardInput[]
    createMany?: ProgramCreateManyBoardInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ChapterChunkBoardCreateNestedManyWithoutBoardInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutBoardInput, ChapterChunkBoardUncheckedCreateWithoutBoardInput> | ChapterChunkBoardCreateWithoutBoardInput[] | ChapterChunkBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutBoardInput | ChapterChunkBoardCreateOrConnectWithoutBoardInput[]
    createMany?: ChapterChunkBoardCreateManyBoardInputEnvelope
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
  }

  export type InstitutionUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<InstitutionCreateWithoutBoardInput, InstitutionUncheckedCreateWithoutBoardInput> | InstitutionCreateWithoutBoardInput[] | InstitutionUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutBoardInput | InstitutionCreateOrConnectWithoutBoardInput[]
    createMany?: InstitutionCreateManyBoardInputEnvelope
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<ProgramCreateWithoutBoardInput, ProgramUncheckedCreateWithoutBoardInput> | ProgramCreateWithoutBoardInput[] | ProgramUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutBoardInput | ProgramCreateOrConnectWithoutBoardInput[]
    createMany?: ProgramCreateManyBoardInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ChapterChunkBoardUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutBoardInput, ChapterChunkBoardUncheckedCreateWithoutBoardInput> | ChapterChunkBoardCreateWithoutBoardInput[] | ChapterChunkBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutBoardInput | ChapterChunkBoardCreateOrConnectWithoutBoardInput[]
    createMany?: ChapterChunkBoardCreateManyBoardInputEnvelope
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<CountryCreateWithoutBoardsInput, CountryUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutBoardsInput
    upsert?: CountryUpsertWithoutBoardsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutBoardsInput, CountryUpdateWithoutBoardsInput>, CountryUncheckedUpdateWithoutBoardsInput>
  }

  export type InstitutionUpdateManyWithoutBoardNestedInput = {
    create?: XOR<InstitutionCreateWithoutBoardInput, InstitutionUncheckedCreateWithoutBoardInput> | InstitutionCreateWithoutBoardInput[] | InstitutionUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutBoardInput | InstitutionCreateOrConnectWithoutBoardInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutBoardInput | InstitutionUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: InstitutionCreateManyBoardInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutBoardInput | InstitutionUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutBoardInput | InstitutionUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ProgramCreateWithoutBoardInput, ProgramUncheckedCreateWithoutBoardInput> | ProgramCreateWithoutBoardInput[] | ProgramUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutBoardInput | ProgramCreateOrConnectWithoutBoardInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutBoardInput | ProgramUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ProgramCreateManyBoardInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutBoardInput | ProgramUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutBoardInput | ProgramUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ChapterChunkBoardUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutBoardInput, ChapterChunkBoardUncheckedCreateWithoutBoardInput> | ChapterChunkBoardCreateWithoutBoardInput[] | ChapterChunkBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutBoardInput | ChapterChunkBoardCreateOrConnectWithoutBoardInput[]
    upsert?: ChapterChunkBoardUpsertWithWhereUniqueWithoutBoardInput | ChapterChunkBoardUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ChapterChunkBoardCreateManyBoardInputEnvelope
    set?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    disconnect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    delete?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    update?: ChapterChunkBoardUpdateWithWhereUniqueWithoutBoardInput | ChapterChunkBoardUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ChapterChunkBoardUpdateManyWithWhereWithoutBoardInput | ChapterChunkBoardUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ChapterChunkBoardScalarWhereInput | ChapterChunkBoardScalarWhereInput[]
  }

  export type InstitutionUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<InstitutionCreateWithoutBoardInput, InstitutionUncheckedCreateWithoutBoardInput> | InstitutionCreateWithoutBoardInput[] | InstitutionUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: InstitutionCreateOrConnectWithoutBoardInput | InstitutionCreateOrConnectWithoutBoardInput[]
    upsert?: InstitutionUpsertWithWhereUniqueWithoutBoardInput | InstitutionUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: InstitutionCreateManyBoardInputEnvelope
    set?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    disconnect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    delete?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    connect?: InstitutionWhereUniqueInput | InstitutionWhereUniqueInput[]
    update?: InstitutionUpdateWithWhereUniqueWithoutBoardInput | InstitutionUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: InstitutionUpdateManyWithWhereWithoutBoardInput | InstitutionUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ProgramCreateWithoutBoardInput, ProgramUncheckedCreateWithoutBoardInput> | ProgramCreateWithoutBoardInput[] | ProgramUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutBoardInput | ProgramCreateOrConnectWithoutBoardInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutBoardInput | ProgramUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ProgramCreateManyBoardInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutBoardInput | ProgramUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutBoardInput | ProgramUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ChapterChunkBoardUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutBoardInput, ChapterChunkBoardUncheckedCreateWithoutBoardInput> | ChapterChunkBoardCreateWithoutBoardInput[] | ChapterChunkBoardUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutBoardInput | ChapterChunkBoardCreateOrConnectWithoutBoardInput[]
    upsert?: ChapterChunkBoardUpsertWithWhereUniqueWithoutBoardInput | ChapterChunkBoardUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ChapterChunkBoardCreateManyBoardInputEnvelope
    set?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    disconnect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    delete?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    update?: ChapterChunkBoardUpdateWithWhereUniqueWithoutBoardInput | ChapterChunkBoardUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ChapterChunkBoardUpdateManyWithWhereWithoutBoardInput | ChapterChunkBoardUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ChapterChunkBoardScalarWhereInput | ChapterChunkBoardScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutInstitutionsInput = {
    create?: XOR<BoardCreateWithoutInstitutionsInput, BoardUncheckedCreateWithoutInstitutionsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutInstitutionsInput
    connect?: BoardWhereUniqueInput
  }

  export type ProgramCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ProgramCreateWithoutInstitutionInput, ProgramUncheckedCreateWithoutInstitutionInput> | ProgramCreateWithoutInstitutionInput[] | ProgramUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutInstitutionInput | ProgramCreateOrConnectWithoutInstitutionInput[]
    createMany?: ProgramCreateManyInstitutionInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ProfileCreateWithoutInstitutionInput, ProfileUncheckedCreateWithoutInstitutionInput> | ProfileCreateWithoutInstitutionInput[] | ProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInstitutionInput | ProfileCreateOrConnectWithoutInstitutionInput[]
    createMany?: ProfileCreateManyInstitutionInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ProgramCreateWithoutInstitutionInput, ProgramUncheckedCreateWithoutInstitutionInput> | ProgramCreateWithoutInstitutionInput[] | ProgramUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutInstitutionInput | ProgramCreateOrConnectWithoutInstitutionInput[]
    createMany?: ProgramCreateManyInstitutionInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ProfileCreateWithoutInstitutionInput, ProfileUncheckedCreateWithoutInstitutionInput> | ProfileCreateWithoutInstitutionInput[] | ProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInstitutionInput | ProfileCreateOrConnectWithoutInstitutionInput[]
    createMany?: ProfileCreateManyInstitutionInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoardUpdateOneRequiredWithoutInstitutionsNestedInput = {
    create?: XOR<BoardCreateWithoutInstitutionsInput, BoardUncheckedCreateWithoutInstitutionsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutInstitutionsInput
    upsert?: BoardUpsertWithoutInstitutionsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutInstitutionsInput, BoardUpdateWithoutInstitutionsInput>, BoardUncheckedUpdateWithoutInstitutionsInput>
  }

  export type ProgramUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ProgramCreateWithoutInstitutionInput, ProgramUncheckedCreateWithoutInstitutionInput> | ProgramCreateWithoutInstitutionInput[] | ProgramUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutInstitutionInput | ProgramCreateOrConnectWithoutInstitutionInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutInstitutionInput | ProgramUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ProgramCreateManyInstitutionInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutInstitutionInput | ProgramUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutInstitutionInput | ProgramUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ProfileCreateWithoutInstitutionInput, ProfileUncheckedCreateWithoutInstitutionInput> | ProfileCreateWithoutInstitutionInput[] | ProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInstitutionInput | ProfileCreateOrConnectWithoutInstitutionInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutInstitutionInput | ProfileUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ProfileCreateManyInstitutionInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutInstitutionInput | ProfileUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutInstitutionInput | ProfileUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ProgramCreateWithoutInstitutionInput, ProgramUncheckedCreateWithoutInstitutionInput> | ProgramCreateWithoutInstitutionInput[] | ProgramUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutInstitutionInput | ProgramCreateOrConnectWithoutInstitutionInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutInstitutionInput | ProgramUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ProgramCreateManyInstitutionInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutInstitutionInput | ProgramUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutInstitutionInput | ProgramUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ProfileCreateWithoutInstitutionInput, ProfileUncheckedCreateWithoutInstitutionInput> | ProfileCreateWithoutInstitutionInput[] | ProfileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInstitutionInput | ProfileCreateOrConnectWithoutInstitutionInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutInstitutionInput | ProfileUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ProfileCreateManyInstitutionInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutInstitutionInput | ProfileUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutInstitutionInput | ProfileUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutProgramsInput = {
    create?: XOR<BoardCreateWithoutProgramsInput, BoardUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutProgramsInput
    connect?: BoardWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutProgramsInput = {
    create?: XOR<InstitutionCreateWithoutProgramsInput, InstitutionUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutProgramsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutProgramInput = {
    create?: XOR<SubjectCreateWithoutProgramInput, SubjectUncheckedCreateWithoutProgramInput> | SubjectCreateWithoutProgramInput[] | SubjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutProgramInput | SubjectCreateOrConnectWithoutProgramInput[]
    createMany?: SubjectCreateManyProgramInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProfileCreateWithoutProgramInput, ProfileUncheckedCreateWithoutProgramInput> | ProfileCreateWithoutProgramInput[] | ProfileUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutProgramInput | ProfileCreateOrConnectWithoutProgramInput[]
    createMany?: ProfileCreateManyProgramInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutProgramInput = {
    create?: XOR<ExamCreateWithoutProgramInput, ExamUncheckedCreateWithoutProgramInput> | ExamCreateWithoutProgramInput[] | ExamUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutProgramInput | ExamCreateOrConnectWithoutProgramInput[]
    createMany?: ExamCreateManyProgramInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<SubjectCreateWithoutProgramInput, SubjectUncheckedCreateWithoutProgramInput> | SubjectCreateWithoutProgramInput[] | SubjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutProgramInput | SubjectCreateOrConnectWithoutProgramInput[]
    createMany?: SubjectCreateManyProgramInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProfileCreateWithoutProgramInput, ProfileUncheckedCreateWithoutProgramInput> | ProfileCreateWithoutProgramInput[] | ProfileUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutProgramInput | ProfileCreateOrConnectWithoutProgramInput[]
    createMany?: ProfileCreateManyProgramInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ExamCreateWithoutProgramInput, ExamUncheckedCreateWithoutProgramInput> | ExamCreateWithoutProgramInput[] | ExamUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutProgramInput | ExamCreateOrConnectWithoutProgramInput[]
    createMany?: ExamCreateManyProgramInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type BoardUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<BoardCreateWithoutProgramsInput, BoardUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutProgramsInput
    upsert?: BoardUpsertWithoutProgramsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutProgramsInput, BoardUpdateWithoutProgramsInput>, BoardUncheckedUpdateWithoutProgramsInput>
  }

  export type InstitutionUpdateOneWithoutProgramsNestedInput = {
    create?: XOR<InstitutionCreateWithoutProgramsInput, InstitutionUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutProgramsInput
    upsert?: InstitutionUpsertWithoutProgramsInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutProgramsInput, InstitutionUpdateWithoutProgramsInput>, InstitutionUncheckedUpdateWithoutProgramsInput>
  }

  export type SubjectUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SubjectCreateWithoutProgramInput, SubjectUncheckedCreateWithoutProgramInput> | SubjectCreateWithoutProgramInput[] | SubjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutProgramInput | SubjectCreateOrConnectWithoutProgramInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutProgramInput | SubjectUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SubjectCreateManyProgramInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutProgramInput | SubjectUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutProgramInput | SubjectUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProfileCreateWithoutProgramInput, ProfileUncheckedCreateWithoutProgramInput> | ProfileCreateWithoutProgramInput[] | ProfileUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutProgramInput | ProfileCreateOrConnectWithoutProgramInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutProgramInput | ProfileUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProfileCreateManyProgramInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutProgramInput | ProfileUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutProgramInput | ProfileUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ExamCreateWithoutProgramInput, ExamUncheckedCreateWithoutProgramInput> | ExamCreateWithoutProgramInput[] | ExamUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutProgramInput | ExamCreateOrConnectWithoutProgramInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutProgramInput | ExamUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ExamCreateManyProgramInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutProgramInput | ExamUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutProgramInput | ExamUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SubjectCreateWithoutProgramInput, SubjectUncheckedCreateWithoutProgramInput> | SubjectCreateWithoutProgramInput[] | SubjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutProgramInput | SubjectCreateOrConnectWithoutProgramInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutProgramInput | SubjectUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SubjectCreateManyProgramInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutProgramInput | SubjectUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutProgramInput | SubjectUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProfileCreateWithoutProgramInput, ProfileUncheckedCreateWithoutProgramInput> | ProfileCreateWithoutProgramInput[] | ProfileUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutProgramInput | ProfileCreateOrConnectWithoutProgramInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutProgramInput | ProfileUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProfileCreateManyProgramInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutProgramInput | ProfileUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutProgramInput | ProfileUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ExamCreateWithoutProgramInput, ExamUncheckedCreateWithoutProgramInput> | ExamCreateWithoutProgramInput[] | ExamUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutProgramInput | ExamCreateOrConnectWithoutProgramInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutProgramInput | ExamUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ExamCreateManyProgramInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutProgramInput | ExamUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutProgramInput | ExamUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutProfileInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    connect?: userWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutProfilesInput = {
    create?: XOR<InstitutionCreateWithoutProfilesInput, InstitutionUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutProfilesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutProfilesInput = {
    create?: XOR<ProgramCreateWithoutProfilesInput, ProgramUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProfilesInput
    connect?: ProgramWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    upsert?: userUpsertWithoutProfileInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProfileInput, userUpdateWithoutProfileInput>, userUncheckedUpdateWithoutProfileInput>
  }

  export type InstitutionUpdateOneWithoutProfilesNestedInput = {
    create?: XOR<InstitutionCreateWithoutProfilesInput, InstitutionUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutProfilesInput
    upsert?: InstitutionUpsertWithoutProfilesInput
    disconnect?: InstitutionWhereInput | boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutProfilesInput, InstitutionUpdateWithoutProfilesInput>, InstitutionUncheckedUpdateWithoutProfilesInput>
  }

  export type ProgramUpdateOneWithoutProfilesNestedInput = {
    create?: XOR<ProgramCreateWithoutProfilesInput, ProgramUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProfilesInput
    upsert?: ProgramUpsertWithoutProfilesInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutProfilesInput, ProgramUpdateWithoutProfilesInput>, ProgramUncheckedUpdateWithoutProfilesInput>
  }

  export type ProgramCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<ProgramCreateWithoutSubjectsInput, ProgramUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSubjectsInput
    connect?: ProgramWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutSubjectInput = {
    create?: XOR<QuizCreateWithoutSubjectInput, QuizUncheckedCreateWithoutSubjectInput> | QuizCreateWithoutSubjectInput[] | QuizUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutSubjectInput | QuizCreateOrConnectWithoutSubjectInput[]
    createMany?: QuizCreateManySubjectInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ConversationCreateWithoutSubjectInput, ConversationUncheckedCreateWithoutSubjectInput> | ConversationCreateWithoutSubjectInput[] | ConversationUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSubjectInput | ConversationCreateOrConnectWithoutSubjectInput[]
    createMany?: ConversationCreateManySubjectInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<QuizCreateWithoutSubjectInput, QuizUncheckedCreateWithoutSubjectInput> | QuizCreateWithoutSubjectInput[] | QuizUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutSubjectInput | QuizCreateOrConnectWithoutSubjectInput[]
    createMany?: QuizCreateManySubjectInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ConversationCreateWithoutSubjectInput, ConversationUncheckedCreateWithoutSubjectInput> | ConversationCreateWithoutSubjectInput[] | ConversationUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSubjectInput | ConversationCreateOrConnectWithoutSubjectInput[]
    createMany?: ConversationCreateManySubjectInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ProgramUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<ProgramCreateWithoutSubjectsInput, ProgramUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSubjectsInput
    upsert?: ProgramUpsertWithoutSubjectsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutSubjectsInput, ProgramUpdateWithoutSubjectsInput>, ProgramUncheckedUpdateWithoutSubjectsInput>
  }

  export type ChapterUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<QuizCreateWithoutSubjectInput, QuizUncheckedCreateWithoutSubjectInput> | QuizCreateWithoutSubjectInput[] | QuizUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutSubjectInput | QuizCreateOrConnectWithoutSubjectInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutSubjectInput | QuizUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: QuizCreateManySubjectInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutSubjectInput | QuizUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutSubjectInput | QuizUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ConversationCreateWithoutSubjectInput, ConversationUncheckedCreateWithoutSubjectInput> | ConversationCreateWithoutSubjectInput[] | ConversationUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSubjectInput | ConversationCreateOrConnectWithoutSubjectInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutSubjectInput | ConversationUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ConversationCreateManySubjectInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutSubjectInput | ConversationUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutSubjectInput | ConversationUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<QuizCreateWithoutSubjectInput, QuizUncheckedCreateWithoutSubjectInput> | QuizCreateWithoutSubjectInput[] | QuizUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutSubjectInput | QuizCreateOrConnectWithoutSubjectInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutSubjectInput | QuizUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: QuizCreateManySubjectInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutSubjectInput | QuizUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutSubjectInput | QuizUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ConversationCreateWithoutSubjectInput, ConversationUncheckedCreateWithoutSubjectInput> | ConversationCreateWithoutSubjectInput[] | ConversationUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutSubjectInput | ConversationCreateOrConnectWithoutSubjectInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutSubjectInput | ConversationUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ConversationCreateManySubjectInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutSubjectInput | ConversationUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutSubjectInput | ConversationUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ChapterCreateaccessible_boardsInput = {
    set: string[]
  }

  export type SubjectCreateNestedOneWithoutChaptersInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
  }

  export type ChapterChunkCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterChunkCreateWithoutChapterInput, ChapterChunkUncheckedCreateWithoutChapterInput> | ChapterChunkCreateWithoutChapterInput[] | ChapterChunkUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChunkCreateOrConnectWithoutChapterInput | ChapterChunkCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterChunkCreateManyChapterInputEnvelope
    connect?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
  }

  export type ChapterPageCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterPageCreateWithoutChapterInput, ChapterPageUncheckedCreateWithoutChapterInput> | ChapterPageCreateWithoutChapterInput[] | ChapterPageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterPageCreateOrConnectWithoutChapterInput | ChapterPageCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterPageCreateManyChapterInputEnvelope
    connect?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutChapterInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type StudyMaterialCreateNestedOneWithoutChapterInput = {
    create?: XOR<StudyMaterialCreateWithoutChapterInput, StudyMaterialUncheckedCreateWithoutChapterInput>
    connectOrCreate?: StudyMaterialCreateOrConnectWithoutChapterInput
    connect?: StudyMaterialWhereUniqueInput
  }

  export type LearningSessionCreateNestedManyWithoutChapterInput = {
    create?: XOR<LearningSessionCreateWithoutChapterInput, LearningSessionUncheckedCreateWithoutChapterInput> | LearningSessionCreateWithoutChapterInput[] | LearningSessionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutChapterInput | LearningSessionCreateOrConnectWithoutChapterInput[]
    createMany?: LearningSessionCreateManyChapterInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutChapterInput = {
    create?: XOR<ConversationCreateWithoutChapterInput, ConversationUncheckedCreateWithoutChapterInput> | ConversationCreateWithoutChapterInput[] | ConversationUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutChapterInput | ConversationCreateOrConnectWithoutChapterInput[]
    createMany?: ConversationCreateManyChapterInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutChapterInput = {
    create?: XOR<QuestionCreateWithoutChapterInput, QuestionUncheckedCreateWithoutChapterInput> | QuestionCreateWithoutChapterInput[] | QuestionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutChapterInput | QuestionCreateOrConnectWithoutChapterInput[]
    createMany?: QuestionCreateManyChapterInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ChapterChunkUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterChunkCreateWithoutChapterInput, ChapterChunkUncheckedCreateWithoutChapterInput> | ChapterChunkCreateWithoutChapterInput[] | ChapterChunkUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChunkCreateOrConnectWithoutChapterInput | ChapterChunkCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterChunkCreateManyChapterInputEnvelope
    connect?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
  }

  export type ChapterPageUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterPageCreateWithoutChapterInput, ChapterPageUncheckedCreateWithoutChapterInput> | ChapterPageCreateWithoutChapterInput[] | ChapterPageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterPageCreateOrConnectWithoutChapterInput | ChapterPageCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterPageCreateManyChapterInputEnvelope
    connect?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type StudyMaterialUncheckedCreateNestedOneWithoutChapterInput = {
    create?: XOR<StudyMaterialCreateWithoutChapterInput, StudyMaterialUncheckedCreateWithoutChapterInput>
    connectOrCreate?: StudyMaterialCreateOrConnectWithoutChapterInput
    connect?: StudyMaterialWhereUniqueInput
  }

  export type LearningSessionUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<LearningSessionCreateWithoutChapterInput, LearningSessionUncheckedCreateWithoutChapterInput> | LearningSessionCreateWithoutChapterInput[] | LearningSessionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutChapterInput | LearningSessionCreateOrConnectWithoutChapterInput[]
    createMany?: LearningSessionCreateManyChapterInputEnvelope
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ConversationCreateWithoutChapterInput, ConversationUncheckedCreateWithoutChapterInput> | ConversationCreateWithoutChapterInput[] | ConversationUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutChapterInput | ConversationCreateOrConnectWithoutChapterInput[]
    createMany?: ConversationCreateManyChapterInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<QuestionCreateWithoutChapterInput, QuestionUncheckedCreateWithoutChapterInput> | QuestionCreateWithoutChapterInput[] | QuestionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutChapterInput | QuestionCreateOrConnectWithoutChapterInput[]
    createMany?: QuestionCreateManyChapterInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ChapterUpdateaccessible_boardsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumChapterStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChapterStatus
  }

  export type SubjectUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    upsert?: SubjectUpsertWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutChaptersInput, SubjectUpdateWithoutChaptersInput>, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type ChapterChunkUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterChunkCreateWithoutChapterInput, ChapterChunkUncheckedCreateWithoutChapterInput> | ChapterChunkCreateWithoutChapterInput[] | ChapterChunkUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChunkCreateOrConnectWithoutChapterInput | ChapterChunkCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterChunkUpsertWithWhereUniqueWithoutChapterInput | ChapterChunkUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterChunkCreateManyChapterInputEnvelope
    set?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    disconnect?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    delete?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    connect?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    update?: ChapterChunkUpdateWithWhereUniqueWithoutChapterInput | ChapterChunkUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterChunkUpdateManyWithWhereWithoutChapterInput | ChapterChunkUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterChunkScalarWhereInput | ChapterChunkScalarWhereInput[]
  }

  export type ChapterPageUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterPageCreateWithoutChapterInput, ChapterPageUncheckedCreateWithoutChapterInput> | ChapterPageCreateWithoutChapterInput[] | ChapterPageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterPageCreateOrConnectWithoutChapterInput | ChapterPageCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterPageUpsertWithWhereUniqueWithoutChapterInput | ChapterPageUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterPageCreateManyChapterInputEnvelope
    set?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    disconnect?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    delete?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    connect?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    update?: ChapterPageUpdateWithWhereUniqueWithoutChapterInput | ChapterPageUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterPageUpdateManyWithWhereWithoutChapterInput | ChapterPageUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterPageScalarWhereInput | ChapterPageScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutChapterNestedInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutChapterInput | QuizUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutChapterInput | QuizUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutChapterInput | QuizUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type StudyMaterialUpdateOneWithoutChapterNestedInput = {
    create?: XOR<StudyMaterialCreateWithoutChapterInput, StudyMaterialUncheckedCreateWithoutChapterInput>
    connectOrCreate?: StudyMaterialCreateOrConnectWithoutChapterInput
    upsert?: StudyMaterialUpsertWithoutChapterInput
    disconnect?: StudyMaterialWhereInput | boolean
    delete?: StudyMaterialWhereInput | boolean
    connect?: StudyMaterialWhereUniqueInput
    update?: XOR<XOR<StudyMaterialUpdateToOneWithWhereWithoutChapterInput, StudyMaterialUpdateWithoutChapterInput>, StudyMaterialUncheckedUpdateWithoutChapterInput>
  }

  export type LearningSessionUpdateManyWithoutChapterNestedInput = {
    create?: XOR<LearningSessionCreateWithoutChapterInput, LearningSessionUncheckedCreateWithoutChapterInput> | LearningSessionCreateWithoutChapterInput[] | LearningSessionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutChapterInput | LearningSessionCreateOrConnectWithoutChapterInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutChapterInput | LearningSessionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: LearningSessionCreateManyChapterInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutChapterInput | LearningSessionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutChapterInput | LearningSessionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ConversationCreateWithoutChapterInput, ConversationUncheckedCreateWithoutChapterInput> | ConversationCreateWithoutChapterInput[] | ConversationUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutChapterInput | ConversationCreateOrConnectWithoutChapterInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutChapterInput | ConversationUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ConversationCreateManyChapterInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutChapterInput | ConversationUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutChapterInput | ConversationUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutChapterNestedInput = {
    create?: XOR<QuestionCreateWithoutChapterInput, QuestionUncheckedCreateWithoutChapterInput> | QuestionCreateWithoutChapterInput[] | QuestionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutChapterInput | QuestionCreateOrConnectWithoutChapterInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutChapterInput | QuestionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: QuestionCreateManyChapterInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutChapterInput | QuestionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutChapterInput | QuestionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterChunkCreateWithoutChapterInput, ChapterChunkUncheckedCreateWithoutChapterInput> | ChapterChunkCreateWithoutChapterInput[] | ChapterChunkUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterChunkCreateOrConnectWithoutChapterInput | ChapterChunkCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterChunkUpsertWithWhereUniqueWithoutChapterInput | ChapterChunkUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterChunkCreateManyChapterInputEnvelope
    set?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    disconnect?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    delete?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    connect?: ChapterChunkWhereUniqueInput | ChapterChunkWhereUniqueInput[]
    update?: ChapterChunkUpdateWithWhereUniqueWithoutChapterInput | ChapterChunkUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterChunkUpdateManyWithWhereWithoutChapterInput | ChapterChunkUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterChunkScalarWhereInput | ChapterChunkScalarWhereInput[]
  }

  export type ChapterPageUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterPageCreateWithoutChapterInput, ChapterPageUncheckedCreateWithoutChapterInput> | ChapterPageCreateWithoutChapterInput[] | ChapterPageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterPageCreateOrConnectWithoutChapterInput | ChapterPageCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterPageUpsertWithWhereUniqueWithoutChapterInput | ChapterPageUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterPageCreateManyChapterInputEnvelope
    set?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    disconnect?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    delete?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    connect?: ChapterPageWhereUniqueInput | ChapterPageWhereUniqueInput[]
    update?: ChapterPageUpdateWithWhereUniqueWithoutChapterInput | ChapterPageUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterPageUpdateManyWithWhereWithoutChapterInput | ChapterPageUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterPageScalarWhereInput | ChapterPageScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput> | QuizCreateWithoutChapterInput[] | QuizUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutChapterInput | QuizCreateOrConnectWithoutChapterInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutChapterInput | QuizUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: QuizCreateManyChapterInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutChapterInput | QuizUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutChapterInput | QuizUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput = {
    create?: XOR<StudyMaterialCreateWithoutChapterInput, StudyMaterialUncheckedCreateWithoutChapterInput>
    connectOrCreate?: StudyMaterialCreateOrConnectWithoutChapterInput
    upsert?: StudyMaterialUpsertWithoutChapterInput
    disconnect?: StudyMaterialWhereInput | boolean
    delete?: StudyMaterialWhereInput | boolean
    connect?: StudyMaterialWhereUniqueInput
    update?: XOR<XOR<StudyMaterialUpdateToOneWithWhereWithoutChapterInput, StudyMaterialUpdateWithoutChapterInput>, StudyMaterialUncheckedUpdateWithoutChapterInput>
  }

  export type LearningSessionUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<LearningSessionCreateWithoutChapterInput, LearningSessionUncheckedCreateWithoutChapterInput> | LearningSessionCreateWithoutChapterInput[] | LearningSessionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: LearningSessionCreateOrConnectWithoutChapterInput | LearningSessionCreateOrConnectWithoutChapterInput[]
    upsert?: LearningSessionUpsertWithWhereUniqueWithoutChapterInput | LearningSessionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: LearningSessionCreateManyChapterInputEnvelope
    set?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    disconnect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    delete?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    connect?: LearningSessionWhereUniqueInput | LearningSessionWhereUniqueInput[]
    update?: LearningSessionUpdateWithWhereUniqueWithoutChapterInput | LearningSessionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: LearningSessionUpdateManyWithWhereWithoutChapterInput | LearningSessionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ConversationCreateWithoutChapterInput, ConversationUncheckedCreateWithoutChapterInput> | ConversationCreateWithoutChapterInput[] | ConversationUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutChapterInput | ConversationCreateOrConnectWithoutChapterInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutChapterInput | ConversationUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ConversationCreateManyChapterInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutChapterInput | ConversationUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutChapterInput | ConversationUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<QuestionCreateWithoutChapterInput, QuestionUncheckedCreateWithoutChapterInput> | QuestionCreateWithoutChapterInput[] | QuestionUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutChapterInput | QuestionCreateOrConnectWithoutChapterInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutChapterInput | QuestionUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: QuestionCreateManyChapterInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutChapterInput | QuestionUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutChapterInput | QuestionUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ChapterCreateNestedOneWithoutChunksInput = {
    create?: XOR<ChapterCreateWithoutChunksInput, ChapterUncheckedCreateWithoutChunksInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutChunksInput
    connect?: ChapterWhereUniqueInput
  }

  export type ChapterChunkBoardCreateNestedManyWithoutChunkInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutChunkInput, ChapterChunkBoardUncheckedCreateWithoutChunkInput> | ChapterChunkBoardCreateWithoutChunkInput[] | ChapterChunkBoardUncheckedCreateWithoutChunkInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutChunkInput | ChapterChunkBoardCreateOrConnectWithoutChunkInput[]
    createMany?: ChapterChunkBoardCreateManyChunkInputEnvelope
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
  }

  export type ChapterChunkBoardUncheckedCreateNestedManyWithoutChunkInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutChunkInput, ChapterChunkBoardUncheckedCreateWithoutChunkInput> | ChapterChunkBoardCreateWithoutChunkInput[] | ChapterChunkBoardUncheckedCreateWithoutChunkInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutChunkInput | ChapterChunkBoardCreateOrConnectWithoutChunkInput[]
    createMany?: ChapterChunkBoardCreateManyChunkInputEnvelope
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
  }

  export type ChapterUpdateOneRequiredWithoutChunksNestedInput = {
    create?: XOR<ChapterCreateWithoutChunksInput, ChapterUncheckedCreateWithoutChunksInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutChunksInput
    upsert?: ChapterUpsertWithoutChunksInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutChunksInput, ChapterUpdateWithoutChunksInput>, ChapterUncheckedUpdateWithoutChunksInput>
  }

  export type ChapterChunkBoardUpdateManyWithoutChunkNestedInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutChunkInput, ChapterChunkBoardUncheckedCreateWithoutChunkInput> | ChapterChunkBoardCreateWithoutChunkInput[] | ChapterChunkBoardUncheckedCreateWithoutChunkInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutChunkInput | ChapterChunkBoardCreateOrConnectWithoutChunkInput[]
    upsert?: ChapterChunkBoardUpsertWithWhereUniqueWithoutChunkInput | ChapterChunkBoardUpsertWithWhereUniqueWithoutChunkInput[]
    createMany?: ChapterChunkBoardCreateManyChunkInputEnvelope
    set?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    disconnect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    delete?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    update?: ChapterChunkBoardUpdateWithWhereUniqueWithoutChunkInput | ChapterChunkBoardUpdateWithWhereUniqueWithoutChunkInput[]
    updateMany?: ChapterChunkBoardUpdateManyWithWhereWithoutChunkInput | ChapterChunkBoardUpdateManyWithWhereWithoutChunkInput[]
    deleteMany?: ChapterChunkBoardScalarWhereInput | ChapterChunkBoardScalarWhereInput[]
  }

  export type ChapterChunkBoardUncheckedUpdateManyWithoutChunkNestedInput = {
    create?: XOR<ChapterChunkBoardCreateWithoutChunkInput, ChapterChunkBoardUncheckedCreateWithoutChunkInput> | ChapterChunkBoardCreateWithoutChunkInput[] | ChapterChunkBoardUncheckedCreateWithoutChunkInput[]
    connectOrCreate?: ChapterChunkBoardCreateOrConnectWithoutChunkInput | ChapterChunkBoardCreateOrConnectWithoutChunkInput[]
    upsert?: ChapterChunkBoardUpsertWithWhereUniqueWithoutChunkInput | ChapterChunkBoardUpsertWithWhereUniqueWithoutChunkInput[]
    createMany?: ChapterChunkBoardCreateManyChunkInputEnvelope
    set?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    disconnect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    delete?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    connect?: ChapterChunkBoardWhereUniqueInput | ChapterChunkBoardWhereUniqueInput[]
    update?: ChapterChunkBoardUpdateWithWhereUniqueWithoutChunkInput | ChapterChunkBoardUpdateWithWhereUniqueWithoutChunkInput[]
    updateMany?: ChapterChunkBoardUpdateManyWithWhereWithoutChunkInput | ChapterChunkBoardUpdateManyWithWhereWithoutChunkInput[]
    deleteMany?: ChapterChunkBoardScalarWhereInput | ChapterChunkBoardScalarWhereInput[]
  }

  export type ChapterChunkCreateNestedOneWithoutChunkBoardsInput = {
    create?: XOR<ChapterChunkCreateWithoutChunkBoardsInput, ChapterChunkUncheckedCreateWithoutChunkBoardsInput>
    connectOrCreate?: ChapterChunkCreateOrConnectWithoutChunkBoardsInput
    connect?: ChapterChunkWhereUniqueInput
  }

  export type BoardCreateNestedOneWithoutChunkBoardsInput = {
    create?: XOR<BoardCreateWithoutChunkBoardsInput, BoardUncheckedCreateWithoutChunkBoardsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutChunkBoardsInput
    connect?: BoardWhereUniqueInput
  }

  export type ChapterChunkUpdateOneRequiredWithoutChunkBoardsNestedInput = {
    create?: XOR<ChapterChunkCreateWithoutChunkBoardsInput, ChapterChunkUncheckedCreateWithoutChunkBoardsInput>
    connectOrCreate?: ChapterChunkCreateOrConnectWithoutChunkBoardsInput
    upsert?: ChapterChunkUpsertWithoutChunkBoardsInput
    connect?: ChapterChunkWhereUniqueInput
    update?: XOR<XOR<ChapterChunkUpdateToOneWithWhereWithoutChunkBoardsInput, ChapterChunkUpdateWithoutChunkBoardsInput>, ChapterChunkUncheckedUpdateWithoutChunkBoardsInput>
  }

  export type BoardUpdateOneRequiredWithoutChunkBoardsNestedInput = {
    create?: XOR<BoardCreateWithoutChunkBoardsInput, BoardUncheckedCreateWithoutChunkBoardsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutChunkBoardsInput
    upsert?: BoardUpsertWithoutChunkBoardsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutChunkBoardsInput, BoardUpdateWithoutChunkBoardsInput>, BoardUncheckedUpdateWithoutChunkBoardsInput>
  }

  export type ChapterCreateNestedOneWithoutPagesInput = {
    create?: XOR<ChapterCreateWithoutPagesInput, ChapterUncheckedCreateWithoutPagesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutPagesInput
    connect?: ChapterWhereUniqueInput
  }

  export type ChapterUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<ChapterCreateWithoutPagesInput, ChapterUncheckedCreateWithoutPagesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutPagesInput
    upsert?: ChapterUpsertWithoutPagesInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutPagesInput, ChapterUpdateWithoutPagesInput>, ChapterUncheckedUpdateWithoutPagesInput>
  }

  export type userCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<userCreateWithoutQuizzesInput, userUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: userCreateOrConnectWithoutQuizzesInput
    connect?: userWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<SubjectCreateWithoutQuizzesInput, SubjectUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutQuizzesInput
    connect?: SubjectWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutQuizzesInput
    connect?: ChapterWhereUniqueInput
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type BattleCreateNestedManyWithoutQuizInput = {
    create?: XOR<BattleCreateWithoutQuizInput, BattleUncheckedCreateWithoutQuizInput> | BattleCreateWithoutQuizInput[] | BattleUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutQuizInput | BattleCreateOrConnectWithoutQuizInput[]
    createMany?: BattleCreateManyQuizInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type BattleUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<BattleCreateWithoutQuizInput, BattleUncheckedCreateWithoutQuizInput> | BattleCreateWithoutQuizInput[] | BattleUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutQuizInput | BattleCreateOrConnectWithoutQuizInput[]
    createMany?: BattleCreateManyQuizInputEnvelope
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
  }

  export type EnumQuizStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuizStatus
  }

  export type userUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<userCreateWithoutQuizzesInput, userUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: userCreateOrConnectWithoutQuizzesInput
    upsert?: userUpsertWithoutQuizzesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutQuizzesInput, userUpdateWithoutQuizzesInput>, userUncheckedUpdateWithoutQuizzesInput>
  }

  export type SubjectUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<SubjectCreateWithoutQuizzesInput, SubjectUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutQuizzesInput
    upsert?: SubjectUpsertWithoutQuizzesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutQuizzesInput, SubjectUpdateWithoutQuizzesInput>, SubjectUncheckedUpdateWithoutQuizzesInput>
  }

  export type ChapterUpdateOneWithoutQuizzesNestedInput = {
    create?: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutQuizzesInput
    upsert?: ChapterUpsertWithoutQuizzesInput
    disconnect?: ChapterWhereInput | boolean
    delete?: ChapterWhereInput | boolean
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutQuizzesInput, ChapterUpdateWithoutQuizzesInput>, ChapterUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type BattleUpdateManyWithoutQuizNestedInput = {
    create?: XOR<BattleCreateWithoutQuizInput, BattleUncheckedCreateWithoutQuizInput> | BattleCreateWithoutQuizInput[] | BattleUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutQuizInput | BattleCreateOrConnectWithoutQuizInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutQuizInput | BattleUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: BattleCreateManyQuizInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutQuizInput | BattleUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutQuizInput | BattleUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type BattleUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<BattleCreateWithoutQuizInput, BattleUncheckedCreateWithoutQuizInput> | BattleCreateWithoutQuizInput[] | BattleUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: BattleCreateOrConnectWithoutQuizInput | BattleCreateOrConnectWithoutQuizInput[]
    upsert?: BattleUpsertWithWhereUniqueWithoutQuizInput | BattleUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: BattleCreateManyQuizInputEnvelope
    set?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    disconnect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    delete?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    connect?: BattleWhereUniqueInput | BattleWhereUniqueInput[]
    update?: BattleUpdateWithWhereUniqueWithoutQuizInput | BattleUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: BattleUpdateManyWithWhereWithoutQuizInput | BattleUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: BattleScalarWhereInput | BattleScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type ChapterCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ChapterCreateWithoutQuestionsInput, ChapterUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutQuestionsInput
    connect?: ChapterWhereUniqueInput
  }

  export type ChapterUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ChapterCreateWithoutQuestionsInput, ChapterUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutQuestionsInput
    upsert?: ChapterUpsertWithoutQuestionsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutQuestionsInput, ChapterUpdateWithoutQuestionsInput>, ChapterUncheckedUpdateWithoutQuestionsInput>
  }

  export type userCreateNestedOneWithoutPointsInput = {
    create?: XOR<userCreateWithoutPointsInput, userUncheckedCreateWithoutPointsInput>
    connectOrCreate?: userCreateOrConnectWithoutPointsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutPointsNestedInput = {
    create?: XOR<userCreateWithoutPointsInput, userUncheckedCreateWithoutPointsInput>
    connectOrCreate?: userCreateOrConnectWithoutPointsInput
    upsert?: userUpsertWithoutPointsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPointsInput, userUpdateWithoutPointsInput>, userUncheckedUpdateWithoutPointsInput>
  }

  export type StudyMaterialCreatevideo_queriesInput = {
    set: string[]
  }

  export type ChapterCreateNestedOneWithoutStudy_materialsInput = {
    create?: XOR<ChapterCreateWithoutStudy_materialsInput, ChapterUncheckedCreateWithoutStudy_materialsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutStudy_materialsInput
    connect?: ChapterWhereUniqueInput
  }

  export type StudyMaterialUpdatevideo_queriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChapterUpdateOneRequiredWithoutStudy_materialsNestedInput = {
    create?: XOR<ChapterCreateWithoutStudy_materialsInput, ChapterUncheckedCreateWithoutStudy_materialsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutStudy_materialsInput
    upsert?: ChapterUpsertWithoutStudy_materialsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutStudy_materialsInput, ChapterUpdateWithoutStudy_materialsInput>, ChapterUncheckedUpdateWithoutStudy_materialsInput>
  }

  export type ProgramCreateNestedOneWithoutExamsInput = {
    create?: XOR<ProgramCreateWithoutExamsInput, ProgramUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutExamsInput
    connect?: ProgramWhereUniqueInput
  }

  export type ProgramUpdateOneWithoutExamsNestedInput = {
    create?: XOR<ProgramCreateWithoutExamsInput, ProgramUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutExamsInput
    upsert?: ProgramUpsertWithoutExamsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutExamsInput, ProgramUpdateWithoutExamsInput>, ProgramUncheckedUpdateWithoutExamsInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutBadgesInput = {
    create?: XOR<userCreateWithoutBadgesInput, userUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: userCreateOrConnectWithoutBadgesInput
    connect?: userWhereUniqueInput
  }

  export type StreakBadgeCreateNestedOneWithoutUser_badgesInput = {
    create?: XOR<StreakBadgeCreateWithoutUser_badgesInput, StreakBadgeUncheckedCreateWithoutUser_badgesInput>
    connectOrCreate?: StreakBadgeCreateOrConnectWithoutUser_badgesInput
    connect?: StreakBadgeWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<userCreateWithoutBadgesInput, userUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: userCreateOrConnectWithoutBadgesInput
    upsert?: userUpsertWithoutBadgesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBadgesInput, userUpdateWithoutBadgesInput>, userUncheckedUpdateWithoutBadgesInput>
  }

  export type StreakBadgeUpdateOneRequiredWithoutUser_badgesNestedInput = {
    create?: XOR<StreakBadgeCreateWithoutUser_badgesInput, StreakBadgeUncheckedCreateWithoutUser_badgesInput>
    connectOrCreate?: StreakBadgeCreateOrConnectWithoutUser_badgesInput
    upsert?: StreakBadgeUpsertWithoutUser_badgesInput
    connect?: StreakBadgeWhereUniqueInput
    update?: XOR<XOR<StreakBadgeUpdateToOneWithWhereWithoutUser_badgesInput, StreakBadgeUpdateWithoutUser_badgesInput>, StreakBadgeUncheckedUpdateWithoutUser_badgesInput>
  }

  export type userCreateNestedOneWithoutLearning_sessionsInput = {
    create?: XOR<userCreateWithoutLearning_sessionsInput, userUncheckedCreateWithoutLearning_sessionsInput>
    connectOrCreate?: userCreateOrConnectWithoutLearning_sessionsInput
    connect?: userWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutLearning_sessionsInput = {
    create?: XOR<ChapterCreateWithoutLearning_sessionsInput, ChapterUncheckedCreateWithoutLearning_sessionsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutLearning_sessionsInput
    connect?: ChapterWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutLearning_sessionsNestedInput = {
    create?: XOR<userCreateWithoutLearning_sessionsInput, userUncheckedCreateWithoutLearning_sessionsInput>
    connectOrCreate?: userCreateOrConnectWithoutLearning_sessionsInput
    upsert?: userUpsertWithoutLearning_sessionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutLearning_sessionsInput, userUpdateWithoutLearning_sessionsInput>, userUncheckedUpdateWithoutLearning_sessionsInput>
  }

  export type ChapterUpdateOneRequiredWithoutLearning_sessionsNestedInput = {
    create?: XOR<ChapterCreateWithoutLearning_sessionsInput, ChapterUncheckedCreateWithoutLearning_sessionsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutLearning_sessionsInput
    upsert?: ChapterUpsertWithoutLearning_sessionsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutLearning_sessionsInput, ChapterUpdateWithoutLearning_sessionsInput>, ChapterUncheckedUpdateWithoutLearning_sessionsInput>
  }

  export type QuizCreateNestedOneWithoutBattlesInput = {
    create?: XOR<QuizCreateWithoutBattlesInput, QuizUncheckedCreateWithoutBattlesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutBattlesInput
    connect?: QuizWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCreated_battlesInput = {
    create?: XOR<userCreateWithoutCreated_battlesInput, userUncheckedCreateWithoutCreated_battlesInput>
    connectOrCreate?: userCreateOrConnectWithoutCreated_battlesInput
    connect?: userWhereUniqueInput
  }

  export type BattleParticipantCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleParticipantCreateWithoutBattleInput, BattleParticipantUncheckedCreateWithoutBattleInput> | BattleParticipantCreateWithoutBattleInput[] | BattleParticipantUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutBattleInput | BattleParticipantCreateOrConnectWithoutBattleInput[]
    createMany?: BattleParticipantCreateManyBattleInputEnvelope
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
  }

  export type BattleParticipantUncheckedCreateNestedManyWithoutBattleInput = {
    create?: XOR<BattleParticipantCreateWithoutBattleInput, BattleParticipantUncheckedCreateWithoutBattleInput> | BattleParticipantCreateWithoutBattleInput[] | BattleParticipantUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutBattleInput | BattleParticipantCreateOrConnectWithoutBattleInput[]
    createMany?: BattleParticipantCreateManyBattleInputEnvelope
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
  }

  export type EnumBattleStatusFieldUpdateOperationsInput = {
    set?: $Enums.BattleStatus
  }

  export type QuizUpdateOneRequiredWithoutBattlesNestedInput = {
    create?: XOR<QuizCreateWithoutBattlesInput, QuizUncheckedCreateWithoutBattlesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutBattlesInput
    upsert?: QuizUpsertWithoutBattlesInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutBattlesInput, QuizUpdateWithoutBattlesInput>, QuizUncheckedUpdateWithoutBattlesInput>
  }

  export type userUpdateOneRequiredWithoutCreated_battlesNestedInput = {
    create?: XOR<userCreateWithoutCreated_battlesInput, userUncheckedCreateWithoutCreated_battlesInput>
    connectOrCreate?: userCreateOrConnectWithoutCreated_battlesInput
    upsert?: userUpsertWithoutCreated_battlesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreated_battlesInput, userUpdateWithoutCreated_battlesInput>, userUncheckedUpdateWithoutCreated_battlesInput>
  }

  export type BattleParticipantUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleParticipantCreateWithoutBattleInput, BattleParticipantUncheckedCreateWithoutBattleInput> | BattleParticipantCreateWithoutBattleInput[] | BattleParticipantUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutBattleInput | BattleParticipantCreateOrConnectWithoutBattleInput[]
    upsert?: BattleParticipantUpsertWithWhereUniqueWithoutBattleInput | BattleParticipantUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleParticipantCreateManyBattleInputEnvelope
    set?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    disconnect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    delete?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    update?: BattleParticipantUpdateWithWhereUniqueWithoutBattleInput | BattleParticipantUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleParticipantUpdateManyWithWhereWithoutBattleInput | BattleParticipantUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleParticipantScalarWhereInput | BattleParticipantScalarWhereInput[]
  }

  export type BattleParticipantUncheckedUpdateManyWithoutBattleNestedInput = {
    create?: XOR<BattleParticipantCreateWithoutBattleInput, BattleParticipantUncheckedCreateWithoutBattleInput> | BattleParticipantCreateWithoutBattleInput[] | BattleParticipantUncheckedCreateWithoutBattleInput[]
    connectOrCreate?: BattleParticipantCreateOrConnectWithoutBattleInput | BattleParticipantCreateOrConnectWithoutBattleInput[]
    upsert?: BattleParticipantUpsertWithWhereUniqueWithoutBattleInput | BattleParticipantUpsertWithWhereUniqueWithoutBattleInput[]
    createMany?: BattleParticipantCreateManyBattleInputEnvelope
    set?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    disconnect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    delete?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    connect?: BattleParticipantWhereUniqueInput | BattleParticipantWhereUniqueInput[]
    update?: BattleParticipantUpdateWithWhereUniqueWithoutBattleInput | BattleParticipantUpdateWithWhereUniqueWithoutBattleInput[]
    updateMany?: BattleParticipantUpdateManyWithWhereWithoutBattleInput | BattleParticipantUpdateManyWithWhereWithoutBattleInput[]
    deleteMany?: BattleParticipantScalarWhereInput | BattleParticipantScalarWhereInput[]
  }

  export type BattleCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<BattleCreateWithoutParticipantsInput, BattleUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: BattleCreateOrConnectWithoutParticipantsInput
    connect?: BattleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutBattle_participationsInput = {
    create?: XOR<userCreateWithoutBattle_participationsInput, userUncheckedCreateWithoutBattle_participationsInput>
    connectOrCreate?: userCreateOrConnectWithoutBattle_participationsInput
    connect?: userWhereUniqueInput
  }

  export type BattleUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<BattleCreateWithoutParticipantsInput, BattleUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: BattleCreateOrConnectWithoutParticipantsInput
    upsert?: BattleUpsertWithoutParticipantsInput
    connect?: BattleWhereUniqueInput
    update?: XOR<XOR<BattleUpdateToOneWithWhereWithoutParticipantsInput, BattleUpdateWithoutParticipantsInput>, BattleUncheckedUpdateWithoutParticipantsInput>
  }

  export type userUpdateOneRequiredWithoutBattle_participationsNestedInput = {
    create?: XOR<userCreateWithoutBattle_participationsInput, userUncheckedCreateWithoutBattle_participationsInput>
    connectOrCreate?: userCreateOrConnectWithoutBattle_participationsInput
    upsert?: userUpsertWithoutBattle_participationsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBattle_participationsInput, userUpdateWithoutBattle_participationsInput>, userUncheckedUpdateWithoutBattle_participationsInput>
  }

  export type SyllabusUnitCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<SyllabusUnitCreateWithoutSyllabusInput, SyllabusUnitUncheckedCreateWithoutSyllabusInput> | SyllabusUnitCreateWithoutSyllabusInput[] | SyllabusUnitUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusUnitCreateOrConnectWithoutSyllabusInput | SyllabusUnitCreateOrConnectWithoutSyllabusInput[]
    createMany?: SyllabusUnitCreateManySyllabusInputEnvelope
    connect?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
  }

  export type TextbookCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<TextbookCreateWithoutSyllabusInput, TextbookUncheckedCreateWithoutSyllabusInput> | TextbookCreateWithoutSyllabusInput[] | TextbookUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutSyllabusInput | TextbookCreateOrConnectWithoutSyllabusInput[]
    createMany?: TextbookCreateManySyllabusInputEnvelope
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
  }

  export type SyllabusUnitUncheckedCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<SyllabusUnitCreateWithoutSyllabusInput, SyllabusUnitUncheckedCreateWithoutSyllabusInput> | SyllabusUnitCreateWithoutSyllabusInput[] | SyllabusUnitUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusUnitCreateOrConnectWithoutSyllabusInput | SyllabusUnitCreateOrConnectWithoutSyllabusInput[]
    createMany?: SyllabusUnitCreateManySyllabusInputEnvelope
    connect?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
  }

  export type TextbookUncheckedCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<TextbookCreateWithoutSyllabusInput, TextbookUncheckedCreateWithoutSyllabusInput> | TextbookCreateWithoutSyllabusInput[] | TextbookUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutSyllabusInput | TextbookCreateOrConnectWithoutSyllabusInput[]
    createMany?: TextbookCreateManySyllabusInputEnvelope
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
  }

  export type EnumSyllabusStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyllabusStatus
  }

  export type SyllabusUnitUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<SyllabusUnitCreateWithoutSyllabusInput, SyllabusUnitUncheckedCreateWithoutSyllabusInput> | SyllabusUnitCreateWithoutSyllabusInput[] | SyllabusUnitUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusUnitCreateOrConnectWithoutSyllabusInput | SyllabusUnitCreateOrConnectWithoutSyllabusInput[]
    upsert?: SyllabusUnitUpsertWithWhereUniqueWithoutSyllabusInput | SyllabusUnitUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: SyllabusUnitCreateManySyllabusInputEnvelope
    set?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    disconnect?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    delete?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    connect?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    update?: SyllabusUnitUpdateWithWhereUniqueWithoutSyllabusInput | SyllabusUnitUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: SyllabusUnitUpdateManyWithWhereWithoutSyllabusInput | SyllabusUnitUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: SyllabusUnitScalarWhereInput | SyllabusUnitScalarWhereInput[]
  }

  export type TextbookUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<TextbookCreateWithoutSyllabusInput, TextbookUncheckedCreateWithoutSyllabusInput> | TextbookCreateWithoutSyllabusInput[] | TextbookUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutSyllabusInput | TextbookCreateOrConnectWithoutSyllabusInput[]
    upsert?: TextbookUpsertWithWhereUniqueWithoutSyllabusInput | TextbookUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: TextbookCreateManySyllabusInputEnvelope
    set?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    disconnect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    delete?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    update?: TextbookUpdateWithWhereUniqueWithoutSyllabusInput | TextbookUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: TextbookUpdateManyWithWhereWithoutSyllabusInput | TextbookUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: TextbookScalarWhereInput | TextbookScalarWhereInput[]
  }

  export type SyllabusUnitUncheckedUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<SyllabusUnitCreateWithoutSyllabusInput, SyllabusUnitUncheckedCreateWithoutSyllabusInput> | SyllabusUnitCreateWithoutSyllabusInput[] | SyllabusUnitUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusUnitCreateOrConnectWithoutSyllabusInput | SyllabusUnitCreateOrConnectWithoutSyllabusInput[]
    upsert?: SyllabusUnitUpsertWithWhereUniqueWithoutSyllabusInput | SyllabusUnitUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: SyllabusUnitCreateManySyllabusInputEnvelope
    set?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    disconnect?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    delete?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    connect?: SyllabusUnitWhereUniqueInput | SyllabusUnitWhereUniqueInput[]
    update?: SyllabusUnitUpdateWithWhereUniqueWithoutSyllabusInput | SyllabusUnitUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: SyllabusUnitUpdateManyWithWhereWithoutSyllabusInput | SyllabusUnitUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: SyllabusUnitScalarWhereInput | SyllabusUnitScalarWhereInput[]
  }

  export type TextbookUncheckedUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<TextbookCreateWithoutSyllabusInput, TextbookUncheckedCreateWithoutSyllabusInput> | TextbookCreateWithoutSyllabusInput[] | TextbookUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: TextbookCreateOrConnectWithoutSyllabusInput | TextbookCreateOrConnectWithoutSyllabusInput[]
    upsert?: TextbookUpsertWithWhereUniqueWithoutSyllabusInput | TextbookUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: TextbookCreateManySyllabusInputEnvelope
    set?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    disconnect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    delete?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    connect?: TextbookWhereUniqueInput | TextbookWhereUniqueInput[]
    update?: TextbookUpdateWithWhereUniqueWithoutSyllabusInput | TextbookUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: TextbookUpdateManyWithWhereWithoutSyllabusInput | TextbookUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: TextbookScalarWhereInput | TextbookScalarWhereInput[]
  }

  export type SyllabusCreateNestedOneWithoutUnitsInput = {
    create?: XOR<SyllabusCreateWithoutUnitsInput, SyllabusUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutUnitsInput
    connect?: SyllabusWhereUniqueInput
  }

  export type SyllabusChapterCreateNestedManyWithoutUnitInput = {
    create?: XOR<SyllabusChapterCreateWithoutUnitInput, SyllabusChapterUncheckedCreateWithoutUnitInput> | SyllabusChapterCreateWithoutUnitInput[] | SyllabusChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: SyllabusChapterCreateOrConnectWithoutUnitInput | SyllabusChapterCreateOrConnectWithoutUnitInput[]
    createMany?: SyllabusChapterCreateManyUnitInputEnvelope
    connect?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
  }

  export type SyllabusChapterUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<SyllabusChapterCreateWithoutUnitInput, SyllabusChapterUncheckedCreateWithoutUnitInput> | SyllabusChapterCreateWithoutUnitInput[] | SyllabusChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: SyllabusChapterCreateOrConnectWithoutUnitInput | SyllabusChapterCreateOrConnectWithoutUnitInput[]
    createMany?: SyllabusChapterCreateManyUnitInputEnvelope
    connect?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
  }

  export type SyllabusUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<SyllabusCreateWithoutUnitsInput, SyllabusUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutUnitsInput
    upsert?: SyllabusUpsertWithoutUnitsInput
    connect?: SyllabusWhereUniqueInput
    update?: XOR<XOR<SyllabusUpdateToOneWithWhereWithoutUnitsInput, SyllabusUpdateWithoutUnitsInput>, SyllabusUncheckedUpdateWithoutUnitsInput>
  }

  export type SyllabusChapterUpdateManyWithoutUnitNestedInput = {
    create?: XOR<SyllabusChapterCreateWithoutUnitInput, SyllabusChapterUncheckedCreateWithoutUnitInput> | SyllabusChapterCreateWithoutUnitInput[] | SyllabusChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: SyllabusChapterCreateOrConnectWithoutUnitInput | SyllabusChapterCreateOrConnectWithoutUnitInput[]
    upsert?: SyllabusChapterUpsertWithWhereUniqueWithoutUnitInput | SyllabusChapterUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: SyllabusChapterCreateManyUnitInputEnvelope
    set?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    disconnect?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    delete?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    connect?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    update?: SyllabusChapterUpdateWithWhereUniqueWithoutUnitInput | SyllabusChapterUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: SyllabusChapterUpdateManyWithWhereWithoutUnitInput | SyllabusChapterUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: SyllabusChapterScalarWhereInput | SyllabusChapterScalarWhereInput[]
  }

  export type SyllabusChapterUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<SyllabusChapterCreateWithoutUnitInput, SyllabusChapterUncheckedCreateWithoutUnitInput> | SyllabusChapterCreateWithoutUnitInput[] | SyllabusChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: SyllabusChapterCreateOrConnectWithoutUnitInput | SyllabusChapterCreateOrConnectWithoutUnitInput[]
    upsert?: SyllabusChapterUpsertWithWhereUniqueWithoutUnitInput | SyllabusChapterUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: SyllabusChapterCreateManyUnitInputEnvelope
    set?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    disconnect?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    delete?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    connect?: SyllabusChapterWhereUniqueInput | SyllabusChapterWhereUniqueInput[]
    update?: SyllabusChapterUpdateWithWhereUniqueWithoutUnitInput | SyllabusChapterUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: SyllabusChapterUpdateManyWithWhereWithoutUnitInput | SyllabusChapterUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: SyllabusChapterScalarWhereInput | SyllabusChapterScalarWhereInput[]
  }

  export type SyllabusUnitCreateNestedOneWithoutChaptersInput = {
    create?: XOR<SyllabusUnitCreateWithoutChaptersInput, SyllabusUnitUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SyllabusUnitCreateOrConnectWithoutChaptersInput
    connect?: SyllabusUnitWhereUniqueInput
  }

  export type SyllabusUnitUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<SyllabusUnitCreateWithoutChaptersInput, SyllabusUnitUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SyllabusUnitCreateOrConnectWithoutChaptersInput
    upsert?: SyllabusUnitUpsertWithoutChaptersInput
    connect?: SyllabusUnitWhereUniqueInput
    update?: XOR<XOR<SyllabusUnitUpdateToOneWithWhereWithoutChaptersInput, SyllabusUnitUpdateWithoutChaptersInput>, SyllabusUnitUncheckedUpdateWithoutChaptersInput>
  }

  export type SyllabusCreateNestedOneWithoutTextbooksInput = {
    create?: XOR<SyllabusCreateWithoutTextbooksInput, SyllabusUncheckedCreateWithoutTextbooksInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutTextbooksInput
    connect?: SyllabusWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTextbooks_createdInput = {
    create?: XOR<userCreateWithoutTextbooks_createdInput, userUncheckedCreateWithoutTextbooks_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutTextbooks_createdInput
    connect?: userWhereUniqueInput
  }

  export type TextbookUnitCreateNestedManyWithoutTextbookInput = {
    create?: XOR<TextbookUnitCreateWithoutTextbookInput, TextbookUnitUncheckedCreateWithoutTextbookInput> | TextbookUnitCreateWithoutTextbookInput[] | TextbookUnitUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookUnitCreateOrConnectWithoutTextbookInput | TextbookUnitCreateOrConnectWithoutTextbookInput[]
    createMany?: TextbookUnitCreateManyTextbookInputEnvelope
    connect?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
  }

  export type TextbookGenerationJobCreateNestedManyWithoutTextbookInput = {
    create?: XOR<TextbookGenerationJobCreateWithoutTextbookInput, TextbookGenerationJobUncheckedCreateWithoutTextbookInput> | TextbookGenerationJobCreateWithoutTextbookInput[] | TextbookGenerationJobUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookGenerationJobCreateOrConnectWithoutTextbookInput | TextbookGenerationJobCreateOrConnectWithoutTextbookInput[]
    createMany?: TextbookGenerationJobCreateManyTextbookInputEnvelope
    connect?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
  }

  export type UserEnrollmentCreateNestedManyWithoutTextbookInput = {
    create?: XOR<UserEnrollmentCreateWithoutTextbookInput, UserEnrollmentUncheckedCreateWithoutTextbookInput> | UserEnrollmentCreateWithoutTextbookInput[] | UserEnrollmentUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutTextbookInput | UserEnrollmentCreateOrConnectWithoutTextbookInput[]
    createMany?: UserEnrollmentCreateManyTextbookInputEnvelope
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
  }

  export type TextbookUnitUncheckedCreateNestedManyWithoutTextbookInput = {
    create?: XOR<TextbookUnitCreateWithoutTextbookInput, TextbookUnitUncheckedCreateWithoutTextbookInput> | TextbookUnitCreateWithoutTextbookInput[] | TextbookUnitUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookUnitCreateOrConnectWithoutTextbookInput | TextbookUnitCreateOrConnectWithoutTextbookInput[]
    createMany?: TextbookUnitCreateManyTextbookInputEnvelope
    connect?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
  }

  export type TextbookGenerationJobUncheckedCreateNestedManyWithoutTextbookInput = {
    create?: XOR<TextbookGenerationJobCreateWithoutTextbookInput, TextbookGenerationJobUncheckedCreateWithoutTextbookInput> | TextbookGenerationJobCreateWithoutTextbookInput[] | TextbookGenerationJobUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookGenerationJobCreateOrConnectWithoutTextbookInput | TextbookGenerationJobCreateOrConnectWithoutTextbookInput[]
    createMany?: TextbookGenerationJobCreateManyTextbookInputEnvelope
    connect?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
  }

  export type UserEnrollmentUncheckedCreateNestedManyWithoutTextbookInput = {
    create?: XOR<UserEnrollmentCreateWithoutTextbookInput, UserEnrollmentUncheckedCreateWithoutTextbookInput> | UserEnrollmentCreateWithoutTextbookInput[] | UserEnrollmentUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutTextbookInput | UserEnrollmentCreateOrConnectWithoutTextbookInput[]
    createMany?: UserEnrollmentCreateManyTextbookInputEnvelope
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
  }

  export type EnumTextbookStatusFieldUpdateOperationsInput = {
    set?: $Enums.TextbookStatus
  }

  export type SyllabusUpdateOneWithoutTextbooksNestedInput = {
    create?: XOR<SyllabusCreateWithoutTextbooksInput, SyllabusUncheckedCreateWithoutTextbooksInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutTextbooksInput
    upsert?: SyllabusUpsertWithoutTextbooksInput
    disconnect?: SyllabusWhereInput | boolean
    delete?: SyllabusWhereInput | boolean
    connect?: SyllabusWhereUniqueInput
    update?: XOR<XOR<SyllabusUpdateToOneWithWhereWithoutTextbooksInput, SyllabusUpdateWithoutTextbooksInput>, SyllabusUncheckedUpdateWithoutTextbooksInput>
  }

  export type userUpdateOneRequiredWithoutTextbooks_createdNestedInput = {
    create?: XOR<userCreateWithoutTextbooks_createdInput, userUncheckedCreateWithoutTextbooks_createdInput>
    connectOrCreate?: userCreateOrConnectWithoutTextbooks_createdInput
    upsert?: userUpsertWithoutTextbooks_createdInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTextbooks_createdInput, userUpdateWithoutTextbooks_createdInput>, userUncheckedUpdateWithoutTextbooks_createdInput>
  }

  export type TextbookUnitUpdateManyWithoutTextbookNestedInput = {
    create?: XOR<TextbookUnitCreateWithoutTextbookInput, TextbookUnitUncheckedCreateWithoutTextbookInput> | TextbookUnitCreateWithoutTextbookInput[] | TextbookUnitUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookUnitCreateOrConnectWithoutTextbookInput | TextbookUnitCreateOrConnectWithoutTextbookInput[]
    upsert?: TextbookUnitUpsertWithWhereUniqueWithoutTextbookInput | TextbookUnitUpsertWithWhereUniqueWithoutTextbookInput[]
    createMany?: TextbookUnitCreateManyTextbookInputEnvelope
    set?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    disconnect?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    delete?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    connect?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    update?: TextbookUnitUpdateWithWhereUniqueWithoutTextbookInput | TextbookUnitUpdateWithWhereUniqueWithoutTextbookInput[]
    updateMany?: TextbookUnitUpdateManyWithWhereWithoutTextbookInput | TextbookUnitUpdateManyWithWhereWithoutTextbookInput[]
    deleteMany?: TextbookUnitScalarWhereInput | TextbookUnitScalarWhereInput[]
  }

  export type TextbookGenerationJobUpdateManyWithoutTextbookNestedInput = {
    create?: XOR<TextbookGenerationJobCreateWithoutTextbookInput, TextbookGenerationJobUncheckedCreateWithoutTextbookInput> | TextbookGenerationJobCreateWithoutTextbookInput[] | TextbookGenerationJobUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookGenerationJobCreateOrConnectWithoutTextbookInput | TextbookGenerationJobCreateOrConnectWithoutTextbookInput[]
    upsert?: TextbookGenerationJobUpsertWithWhereUniqueWithoutTextbookInput | TextbookGenerationJobUpsertWithWhereUniqueWithoutTextbookInput[]
    createMany?: TextbookGenerationJobCreateManyTextbookInputEnvelope
    set?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    disconnect?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    delete?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    connect?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    update?: TextbookGenerationJobUpdateWithWhereUniqueWithoutTextbookInput | TextbookGenerationJobUpdateWithWhereUniqueWithoutTextbookInput[]
    updateMany?: TextbookGenerationJobUpdateManyWithWhereWithoutTextbookInput | TextbookGenerationJobUpdateManyWithWhereWithoutTextbookInput[]
    deleteMany?: TextbookGenerationJobScalarWhereInput | TextbookGenerationJobScalarWhereInput[]
  }

  export type UserEnrollmentUpdateManyWithoutTextbookNestedInput = {
    create?: XOR<UserEnrollmentCreateWithoutTextbookInput, UserEnrollmentUncheckedCreateWithoutTextbookInput> | UserEnrollmentCreateWithoutTextbookInput[] | UserEnrollmentUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutTextbookInput | UserEnrollmentCreateOrConnectWithoutTextbookInput[]
    upsert?: UserEnrollmentUpsertWithWhereUniqueWithoutTextbookInput | UserEnrollmentUpsertWithWhereUniqueWithoutTextbookInput[]
    createMany?: UserEnrollmentCreateManyTextbookInputEnvelope
    set?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    disconnect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    delete?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    update?: UserEnrollmentUpdateWithWhereUniqueWithoutTextbookInput | UserEnrollmentUpdateWithWhereUniqueWithoutTextbookInput[]
    updateMany?: UserEnrollmentUpdateManyWithWhereWithoutTextbookInput | UserEnrollmentUpdateManyWithWhereWithoutTextbookInput[]
    deleteMany?: UserEnrollmentScalarWhereInput | UserEnrollmentScalarWhereInput[]
  }

  export type TextbookUnitUncheckedUpdateManyWithoutTextbookNestedInput = {
    create?: XOR<TextbookUnitCreateWithoutTextbookInput, TextbookUnitUncheckedCreateWithoutTextbookInput> | TextbookUnitCreateWithoutTextbookInput[] | TextbookUnitUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookUnitCreateOrConnectWithoutTextbookInput | TextbookUnitCreateOrConnectWithoutTextbookInput[]
    upsert?: TextbookUnitUpsertWithWhereUniqueWithoutTextbookInput | TextbookUnitUpsertWithWhereUniqueWithoutTextbookInput[]
    createMany?: TextbookUnitCreateManyTextbookInputEnvelope
    set?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    disconnect?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    delete?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    connect?: TextbookUnitWhereUniqueInput | TextbookUnitWhereUniqueInput[]
    update?: TextbookUnitUpdateWithWhereUniqueWithoutTextbookInput | TextbookUnitUpdateWithWhereUniqueWithoutTextbookInput[]
    updateMany?: TextbookUnitUpdateManyWithWhereWithoutTextbookInput | TextbookUnitUpdateManyWithWhereWithoutTextbookInput[]
    deleteMany?: TextbookUnitScalarWhereInput | TextbookUnitScalarWhereInput[]
  }

  export type TextbookGenerationJobUncheckedUpdateManyWithoutTextbookNestedInput = {
    create?: XOR<TextbookGenerationJobCreateWithoutTextbookInput, TextbookGenerationJobUncheckedCreateWithoutTextbookInput> | TextbookGenerationJobCreateWithoutTextbookInput[] | TextbookGenerationJobUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: TextbookGenerationJobCreateOrConnectWithoutTextbookInput | TextbookGenerationJobCreateOrConnectWithoutTextbookInput[]
    upsert?: TextbookGenerationJobUpsertWithWhereUniqueWithoutTextbookInput | TextbookGenerationJobUpsertWithWhereUniqueWithoutTextbookInput[]
    createMany?: TextbookGenerationJobCreateManyTextbookInputEnvelope
    set?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    disconnect?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    delete?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    connect?: TextbookGenerationJobWhereUniqueInput | TextbookGenerationJobWhereUniqueInput[]
    update?: TextbookGenerationJobUpdateWithWhereUniqueWithoutTextbookInput | TextbookGenerationJobUpdateWithWhereUniqueWithoutTextbookInput[]
    updateMany?: TextbookGenerationJobUpdateManyWithWhereWithoutTextbookInput | TextbookGenerationJobUpdateManyWithWhereWithoutTextbookInput[]
    deleteMany?: TextbookGenerationJobScalarWhereInput | TextbookGenerationJobScalarWhereInput[]
  }

  export type UserEnrollmentUncheckedUpdateManyWithoutTextbookNestedInput = {
    create?: XOR<UserEnrollmentCreateWithoutTextbookInput, UserEnrollmentUncheckedCreateWithoutTextbookInput> | UserEnrollmentCreateWithoutTextbookInput[] | UserEnrollmentUncheckedCreateWithoutTextbookInput[]
    connectOrCreate?: UserEnrollmentCreateOrConnectWithoutTextbookInput | UserEnrollmentCreateOrConnectWithoutTextbookInput[]
    upsert?: UserEnrollmentUpsertWithWhereUniqueWithoutTextbookInput | UserEnrollmentUpsertWithWhereUniqueWithoutTextbookInput[]
    createMany?: UserEnrollmentCreateManyTextbookInputEnvelope
    set?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    disconnect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    delete?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    connect?: UserEnrollmentWhereUniqueInput | UserEnrollmentWhereUniqueInput[]
    update?: UserEnrollmentUpdateWithWhereUniqueWithoutTextbookInput | UserEnrollmentUpdateWithWhereUniqueWithoutTextbookInput[]
    updateMany?: UserEnrollmentUpdateManyWithWhereWithoutTextbookInput | UserEnrollmentUpdateManyWithWhereWithoutTextbookInput[]
    deleteMany?: UserEnrollmentScalarWhereInput | UserEnrollmentScalarWhereInput[]
  }

  export type TextbookCreateNestedOneWithoutUnitsInput = {
    create?: XOR<TextbookCreateWithoutUnitsInput, TextbookUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: TextbookCreateOrConnectWithoutUnitsInput
    connect?: TextbookWhereUniqueInput
  }

  export type TextbookChapterCreateNestedManyWithoutUnitInput = {
    create?: XOR<TextbookChapterCreateWithoutUnitInput, TextbookChapterUncheckedCreateWithoutUnitInput> | TextbookChapterCreateWithoutUnitInput[] | TextbookChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: TextbookChapterCreateOrConnectWithoutUnitInput | TextbookChapterCreateOrConnectWithoutUnitInput[]
    createMany?: TextbookChapterCreateManyUnitInputEnvelope
    connect?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
  }

  export type TextbookChapterUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<TextbookChapterCreateWithoutUnitInput, TextbookChapterUncheckedCreateWithoutUnitInput> | TextbookChapterCreateWithoutUnitInput[] | TextbookChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: TextbookChapterCreateOrConnectWithoutUnitInput | TextbookChapterCreateOrConnectWithoutUnitInput[]
    createMany?: TextbookChapterCreateManyUnitInputEnvelope
    connect?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
  }

  export type TextbookUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<TextbookCreateWithoutUnitsInput, TextbookUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: TextbookCreateOrConnectWithoutUnitsInput
    upsert?: TextbookUpsertWithoutUnitsInput
    connect?: TextbookWhereUniqueInput
    update?: XOR<XOR<TextbookUpdateToOneWithWhereWithoutUnitsInput, TextbookUpdateWithoutUnitsInput>, TextbookUncheckedUpdateWithoutUnitsInput>
  }

  export type TextbookChapterUpdateManyWithoutUnitNestedInput = {
    create?: XOR<TextbookChapterCreateWithoutUnitInput, TextbookChapterUncheckedCreateWithoutUnitInput> | TextbookChapterCreateWithoutUnitInput[] | TextbookChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: TextbookChapterCreateOrConnectWithoutUnitInput | TextbookChapterCreateOrConnectWithoutUnitInput[]
    upsert?: TextbookChapterUpsertWithWhereUniqueWithoutUnitInput | TextbookChapterUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: TextbookChapterCreateManyUnitInputEnvelope
    set?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    disconnect?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    delete?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    connect?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    update?: TextbookChapterUpdateWithWhereUniqueWithoutUnitInput | TextbookChapterUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: TextbookChapterUpdateManyWithWhereWithoutUnitInput | TextbookChapterUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: TextbookChapterScalarWhereInput | TextbookChapterScalarWhereInput[]
  }

  export type TextbookChapterUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<TextbookChapterCreateWithoutUnitInput, TextbookChapterUncheckedCreateWithoutUnitInput> | TextbookChapterCreateWithoutUnitInput[] | TextbookChapterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: TextbookChapterCreateOrConnectWithoutUnitInput | TextbookChapterCreateOrConnectWithoutUnitInput[]
    upsert?: TextbookChapterUpsertWithWhereUniqueWithoutUnitInput | TextbookChapterUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: TextbookChapterCreateManyUnitInputEnvelope
    set?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    disconnect?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    delete?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    connect?: TextbookChapterWhereUniqueInput | TextbookChapterWhereUniqueInput[]
    update?: TextbookChapterUpdateWithWhereUniqueWithoutUnitInput | TextbookChapterUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: TextbookChapterUpdateManyWithWhereWithoutUnitInput | TextbookChapterUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: TextbookChapterScalarWhereInput | TextbookChapterScalarWhereInput[]
  }

  export type TextbookUnitCreateNestedOneWithoutChaptersInput = {
    create?: XOR<TextbookUnitCreateWithoutChaptersInput, TextbookUnitUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: TextbookUnitCreateOrConnectWithoutChaptersInput
    connect?: TextbookUnitWhereUniqueInput
  }

  export type TextbookImageCreateNestedManyWithoutChapterInput = {
    create?: XOR<TextbookImageCreateWithoutChapterInput, TextbookImageUncheckedCreateWithoutChapterInput> | TextbookImageCreateWithoutChapterInput[] | TextbookImageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: TextbookImageCreateOrConnectWithoutChapterInput | TextbookImageCreateOrConnectWithoutChapterInput[]
    createMany?: TextbookImageCreateManyChapterInputEnvelope
    connect?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
  }

  export type TextbookImageUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<TextbookImageCreateWithoutChapterInput, TextbookImageUncheckedCreateWithoutChapterInput> | TextbookImageCreateWithoutChapterInput[] | TextbookImageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: TextbookImageCreateOrConnectWithoutChapterInput | TextbookImageCreateOrConnectWithoutChapterInput[]
    createMany?: TextbookImageCreateManyChapterInputEnvelope
    connect?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
  }

  export type EnumChapterGenStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChapterGenStatus
  }

  export type TextbookUnitUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<TextbookUnitCreateWithoutChaptersInput, TextbookUnitUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: TextbookUnitCreateOrConnectWithoutChaptersInput
    upsert?: TextbookUnitUpsertWithoutChaptersInput
    connect?: TextbookUnitWhereUniqueInput
    update?: XOR<XOR<TextbookUnitUpdateToOneWithWhereWithoutChaptersInput, TextbookUnitUpdateWithoutChaptersInput>, TextbookUnitUncheckedUpdateWithoutChaptersInput>
  }

  export type TextbookImageUpdateManyWithoutChapterNestedInput = {
    create?: XOR<TextbookImageCreateWithoutChapterInput, TextbookImageUncheckedCreateWithoutChapterInput> | TextbookImageCreateWithoutChapterInput[] | TextbookImageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: TextbookImageCreateOrConnectWithoutChapterInput | TextbookImageCreateOrConnectWithoutChapterInput[]
    upsert?: TextbookImageUpsertWithWhereUniqueWithoutChapterInput | TextbookImageUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: TextbookImageCreateManyChapterInputEnvelope
    set?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    disconnect?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    delete?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    connect?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    update?: TextbookImageUpdateWithWhereUniqueWithoutChapterInput | TextbookImageUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: TextbookImageUpdateManyWithWhereWithoutChapterInput | TextbookImageUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: TextbookImageScalarWhereInput | TextbookImageScalarWhereInput[]
  }

  export type TextbookImageUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<TextbookImageCreateWithoutChapterInput, TextbookImageUncheckedCreateWithoutChapterInput> | TextbookImageCreateWithoutChapterInput[] | TextbookImageUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: TextbookImageCreateOrConnectWithoutChapterInput | TextbookImageCreateOrConnectWithoutChapterInput[]
    upsert?: TextbookImageUpsertWithWhereUniqueWithoutChapterInput | TextbookImageUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: TextbookImageCreateManyChapterInputEnvelope
    set?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    disconnect?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    delete?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    connect?: TextbookImageWhereUniqueInput | TextbookImageWhereUniqueInput[]
    update?: TextbookImageUpdateWithWhereUniqueWithoutChapterInput | TextbookImageUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: TextbookImageUpdateManyWithWhereWithoutChapterInput | TextbookImageUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: TextbookImageScalarWhereInput | TextbookImageScalarWhereInput[]
  }

  export type TextbookChapterCreateNestedOneWithoutImagesInput = {
    create?: XOR<TextbookChapterCreateWithoutImagesInput, TextbookChapterUncheckedCreateWithoutImagesInput>
    connectOrCreate?: TextbookChapterCreateOrConnectWithoutImagesInput
    connect?: TextbookChapterWhereUniqueInput
  }

  export type EnumTextbookImageTypeFieldUpdateOperationsInput = {
    set?: $Enums.TextbookImageType
  }

  export type EnumImageGenStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImageGenStatus
  }

  export type TextbookChapterUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<TextbookChapterCreateWithoutImagesInput, TextbookChapterUncheckedCreateWithoutImagesInput>
    connectOrCreate?: TextbookChapterCreateOrConnectWithoutImagesInput
    upsert?: TextbookChapterUpsertWithoutImagesInput
    connect?: TextbookChapterWhereUniqueInput
    update?: XOR<XOR<TextbookChapterUpdateToOneWithWhereWithoutImagesInput, TextbookChapterUpdateWithoutImagesInput>, TextbookChapterUncheckedUpdateWithoutImagesInput>
  }

  export type TextbookCreateNestedOneWithoutGeneration_jobsInput = {
    create?: XOR<TextbookCreateWithoutGeneration_jobsInput, TextbookUncheckedCreateWithoutGeneration_jobsInput>
    connectOrCreate?: TextbookCreateOrConnectWithoutGeneration_jobsInput
    connect?: TextbookWhereUniqueInput
  }

  export type EnumTextbookGenerationJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.TextbookGenerationJobType
  }

  export type EnumTextbookJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.TextbookJobStatus
  }

  export type TextbookUpdateOneRequiredWithoutGeneration_jobsNestedInput = {
    create?: XOR<TextbookCreateWithoutGeneration_jobsInput, TextbookUncheckedCreateWithoutGeneration_jobsInput>
    connectOrCreate?: TextbookCreateOrConnectWithoutGeneration_jobsInput
    upsert?: TextbookUpsertWithoutGeneration_jobsInput
    connect?: TextbookWhereUniqueInput
    update?: XOR<XOR<TextbookUpdateToOneWithWhereWithoutGeneration_jobsInput, TextbookUpdateWithoutGeneration_jobsInput>, TextbookUncheckedUpdateWithoutGeneration_jobsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type NestedEnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type NestedEnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type NestedEnumUsageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeFilter<$PrismaModel> | $Enums.UsageType
  }

  export type NestedEnumUsageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageType | EnumUsageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageType[] | ListEnumUsageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageTypeWithAggregatesFilter<$PrismaModel> | $Enums.UsageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsageTypeFilter<$PrismaModel>
    _max?: NestedEnumUsageTypeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumChapterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusFilter<$PrismaModel> | $Enums.ChapterStatus
  }

  export type NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterStatus | EnumChapterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterStatus[] | ListEnumChapterStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuizStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizStatus | EnumQuizStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStatusFilter<$PrismaModel> | $Enums.QuizStatus
  }

  export type NestedEnumQuizStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizStatus | EnumQuizStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizStatus[] | ListEnumQuizStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuizStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuizStatusFilter<$PrismaModel>
    _max?: NestedEnumQuizStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumBattleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusFilter<$PrismaModel> | $Enums.BattleStatus
  }

  export type NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattleStatus | EnumBattleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BattleStatus[] | ListEnumBattleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBattleStatusWithAggregatesFilter<$PrismaModel> | $Enums.BattleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBattleStatusFilter<$PrismaModel>
    _max?: NestedEnumBattleStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyllabusStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusStatus | EnumSyllabusStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyllabusStatusFilter<$PrismaModel> | $Enums.SyllabusStatus
  }

  export type NestedEnumSyllabusStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyllabusStatus | EnumSyllabusStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyllabusStatus[] | ListEnumSyllabusStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyllabusStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyllabusStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyllabusStatusFilter<$PrismaModel>
    _max?: NestedEnumSyllabusStatusFilter<$PrismaModel>
  }

  export type NestedEnumTextbookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookStatus | EnumTextbookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookStatusFilter<$PrismaModel> | $Enums.TextbookStatus
  }

  export type NestedEnumTextbookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookStatus | EnumTextbookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookStatus[] | ListEnumTextbookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookStatusWithAggregatesFilter<$PrismaModel> | $Enums.TextbookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookStatusFilter<$PrismaModel>
    _max?: NestedEnumTextbookStatusFilter<$PrismaModel>
  }

  export type NestedEnumChapterGenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterGenStatus | EnumChapterGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterGenStatusFilter<$PrismaModel> | $Enums.ChapterGenStatus
  }

  export type NestedEnumChapterGenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterGenStatus | EnumChapterGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChapterGenStatus[] | ListEnumChapterGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChapterGenStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChapterGenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterGenStatusFilter<$PrismaModel>
    _max?: NestedEnumChapterGenStatusFilter<$PrismaModel>
  }

  export type NestedEnumTextbookImageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookImageType | EnumTextbookImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookImageTypeFilter<$PrismaModel> | $Enums.TextbookImageType
  }

  export type NestedEnumImageGenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageGenStatus | EnumImageGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImageGenStatusFilter<$PrismaModel> | $Enums.ImageGenStatus
  }

  export type NestedEnumTextbookImageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookImageType | EnumTextbookImageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookImageType[] | ListEnumTextbookImageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookImageTypeWithAggregatesFilter<$PrismaModel> | $Enums.TextbookImageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookImageTypeFilter<$PrismaModel>
    _max?: NestedEnumTextbookImageTypeFilter<$PrismaModel>
  }

  export type NestedEnumImageGenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageGenStatus | EnumImageGenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageGenStatus[] | ListEnumImageGenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImageGenStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImageGenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageGenStatusFilter<$PrismaModel>
    _max?: NestedEnumImageGenStatusFilter<$PrismaModel>
  }

  export type NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookGenerationJobType | EnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel> | $Enums.TextbookGenerationJobType
  }

  export type NestedEnumTextbookJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookJobStatus | EnumTextbookJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookJobStatusFilter<$PrismaModel> | $Enums.TextbookJobStatus
  }

  export type NestedEnumTextbookGenerationJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookGenerationJobType | EnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookGenerationJobType[] | ListEnumTextbookGenerationJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookGenerationJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.TextbookGenerationJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel>
    _max?: NestedEnumTextbookGenerationJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumTextbookJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextbookJobStatus | EnumTextbookJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextbookJobStatus[] | ListEnumTextbookJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTextbookJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.TextbookJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextbookJobStatusFilter<$PrismaModel>
    _max?: NestedEnumTextbookJobStatusFilter<$PrismaModel>
  }

  export type userCreateWithoutCategoriesInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCategoriesInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCategoriesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCategoriesInput, userUncheckedCreateWithoutCategoriesInput>
  }

  export type userUpsertWithoutCategoriesInput = {
    update: XOR<userUpdateWithoutCategoriesInput, userUncheckedUpdateWithoutCategoriesInput>
    create: XOR<userCreateWithoutCategoriesInput, userUncheckedCreateWithoutCategoriesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCategoriesInput, userUncheckedUpdateWithoutCategoriesInput>
  }

  export type userUpdateWithoutCategoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutFilesInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFilesInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFilesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
  }

  export type DocumentPageCreateWithoutFileInput = {
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type DocumentPageUncheckedCreateWithoutFileInput = {
    id?: number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type DocumentPageCreateOrConnectWithoutFileInput = {
    where: DocumentPageWhereUniqueInput
    create: XOR<DocumentPageCreateWithoutFileInput, DocumentPageUncheckedCreateWithoutFileInput>
  }

  export type DocumentPageCreateManyFileInputEnvelope = {
    data: DocumentPageCreateManyFileInput | DocumentPageCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type FileChunkCreateWithoutFileInput = {
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: number | null
    created_at?: Date | string
  }

  export type FileChunkUncheckedCreateWithoutFileInput = {
    id?: number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: number | null
    created_at?: Date | string
  }

  export type FileChunkCreateOrConnectWithoutFileInput = {
    where: FileChunkWhereUniqueInput
    create: XOR<FileChunkCreateWithoutFileInput, FileChunkUncheckedCreateWithoutFileInput>
  }

  export type FileChunkCreateManyFileInputEnvelope = {
    data: FileChunkCreateManyFileInput | FileChunkCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutFilesInput = {
    update: XOR<userUpdateWithoutFilesInput, userUncheckedUpdateWithoutFilesInput>
    create: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFilesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFilesInput, userUncheckedUpdateWithoutFilesInput>
  }

  export type userUpdateWithoutFilesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentPageUpsertWithWhereUniqueWithoutFileInput = {
    where: DocumentPageWhereUniqueInput
    update: XOR<DocumentPageUpdateWithoutFileInput, DocumentPageUncheckedUpdateWithoutFileInput>
    create: XOR<DocumentPageCreateWithoutFileInput, DocumentPageUncheckedCreateWithoutFileInput>
  }

  export type DocumentPageUpdateWithWhereUniqueWithoutFileInput = {
    where: DocumentPageWhereUniqueInput
    data: XOR<DocumentPageUpdateWithoutFileInput, DocumentPageUncheckedUpdateWithoutFileInput>
  }

  export type DocumentPageUpdateManyWithWhereWithoutFileInput = {
    where: DocumentPageScalarWhereInput
    data: XOR<DocumentPageUpdateManyMutationInput, DocumentPageUncheckedUpdateManyWithoutFileInput>
  }

  export type DocumentPageScalarWhereInput = {
    AND?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
    OR?: DocumentPageScalarWhereInput[]
    NOT?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
    id?: IntFilter<"DocumentPage"> | number
    file_id?: IntFilter<"DocumentPage"> | number
    page_number?: IntFilter<"DocumentPage"> | number
    image_url?: StringFilter<"DocumentPage"> | string
    width?: IntNullableFilter<"DocumentPage"> | number | null
    height?: IntNullableFilter<"DocumentPage"> | number | null
    created_at?: DateTimeFilter<"DocumentPage"> | Date | string
  }

  export type FileChunkUpsertWithWhereUniqueWithoutFileInput = {
    where: FileChunkWhereUniqueInput
    update: XOR<FileChunkUpdateWithoutFileInput, FileChunkUncheckedUpdateWithoutFileInput>
    create: XOR<FileChunkCreateWithoutFileInput, FileChunkUncheckedCreateWithoutFileInput>
  }

  export type FileChunkUpdateWithWhereUniqueWithoutFileInput = {
    where: FileChunkWhereUniqueInput
    data: XOR<FileChunkUpdateWithoutFileInput, FileChunkUncheckedUpdateWithoutFileInput>
  }

  export type FileChunkUpdateManyWithWhereWithoutFileInput = {
    where: FileChunkScalarWhereInput
    data: XOR<FileChunkUpdateManyMutationInput, FileChunkUncheckedUpdateManyWithoutFileInput>
  }

  export type FileChunkScalarWhereInput = {
    AND?: FileChunkScalarWhereInput | FileChunkScalarWhereInput[]
    OR?: FileChunkScalarWhereInput[]
    NOT?: FileChunkScalarWhereInput | FileChunkScalarWhereInput[]
    id?: IntFilter<"FileChunk"> | number
    file_id?: IntFilter<"FileChunk"> | number
    chunk_index?: IntFilter<"FileChunk"> | number
    content?: StringFilter<"FileChunk"> | string
    page_number?: IntNullableFilter<"FileChunk"> | number | null
    bbox?: JsonNullableFilter<"FileChunk">
    token_count?: IntNullableFilter<"FileChunk"> | number | null
    created_at?: DateTimeFilter<"FileChunk"> | Date | string
  }

  export type FileListCreateWithoutPagesInput = {
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    user?: userCreateNestedOneWithoutFilesInput
    chunks?: FileChunkCreateNestedManyWithoutFileInput
  }

  export type FileListUncheckedCreateWithoutPagesInput = {
    id?: number
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: number | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    chunks?: FileChunkUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileListCreateOrConnectWithoutPagesInput = {
    where: FileListWhereUniqueInput
    create: XOR<FileListCreateWithoutPagesInput, FileListUncheckedCreateWithoutPagesInput>
  }

  export type FileListUpsertWithoutPagesInput = {
    update: XOR<FileListUpdateWithoutPagesInput, FileListUncheckedUpdateWithoutPagesInput>
    create: XOR<FileListCreateWithoutPagesInput, FileListUncheckedCreateWithoutPagesInput>
    where?: FileListWhereInput
  }

  export type FileListUpdateToOneWithWhereWithoutPagesInput = {
    where?: FileListWhereInput
    data: XOR<FileListUpdateWithoutPagesInput, FileListUncheckedUpdateWithoutPagesInput>
  }

  export type FileListUpdateWithoutPagesInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutFilesNestedInput
    chunks?: FileChunkUpdateManyWithoutFileNestedInput
  }

  export type FileListUncheckedUpdateWithoutPagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: FileChunkUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileListCreateWithoutChunksInput = {
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    user?: userCreateNestedOneWithoutFilesInput
    pages?: DocumentPageCreateNestedManyWithoutFileInput
  }

  export type FileListUncheckedCreateWithoutChunksInput = {
    id?: number
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    user_id?: number | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    pages?: DocumentPageUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileListCreateOrConnectWithoutChunksInput = {
    where: FileListWhereUniqueInput
    create: XOR<FileListCreateWithoutChunksInput, FileListUncheckedCreateWithoutChunksInput>
  }

  export type FileListUpsertWithoutChunksInput = {
    update: XOR<FileListUpdateWithoutChunksInput, FileListUncheckedUpdateWithoutChunksInput>
    create: XOR<FileListCreateWithoutChunksInput, FileListUncheckedCreateWithoutChunksInput>
    where?: FileListWhereInput
  }

  export type FileListUpdateToOneWithWhereWithoutChunksInput = {
    where?: FileListWhereInput
    data: XOR<FileListUpdateWithoutChunksInput, FileListUncheckedUpdateWithoutChunksInput>
  }

  export type FileListUpdateWithoutChunksInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneWithoutFilesNestedInput
    pages?: DocumentPageUpdateManyWithoutFileNestedInput
  }

  export type FileListUncheckedUpdateWithoutChunksInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: DocumentPageUncheckedUpdateManyWithoutFileNestedInput
  }

  export type CategoryListCreateWithoutUserInput = {
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type CategoryListUncheckedCreateWithoutUserInput = {
    id?: number
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type CategoryListCreateOrConnectWithoutUserInput = {
    where: CategoryListWhereUniqueInput
    create: XOR<CategoryListCreateWithoutUserInput, CategoryListUncheckedCreateWithoutUserInput>
  }

  export type CategoryListCreateManyUserInputEnvelope = {
    data: CategoryListCreateManyUserInput | CategoryListCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    messages?: ConversationMessageCreateNestedManyWithoutConversationInput
    subject?: SubjectCreateNestedOneWithoutConversationsInput
    chapter?: ChapterCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
    chapter_id?: bigint | number | null
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileListCreateWithoutUserInput = {
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    pages?: DocumentPageCreateNestedManyWithoutFileInput
    chunks?: FileChunkCreateNestedManyWithoutFileInput
  }

  export type FileListUncheckedCreateWithoutUserInput = {
    id?: number
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
    pages?: DocumentPageUncheckedCreateNestedManyWithoutFileInput
    chunks?: FileChunkUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileListCreateOrConnectWithoutUserInput = {
    where: FileListWhereUniqueInput
    create: XOR<FileListCreateWithoutUserInput, FileListUncheckedCreateWithoutUserInput>
  }

  export type FileListCreateManyUserInputEnvelope = {
    data: FileListCreateManyUserInput | FileListCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageTrackingCreateWithoutUserInput = {
    usage_type: $Enums.UsageType
    count?: number
    period_start: Date | string
    period_end: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UsageTrackingUncheckedCreateWithoutUserInput = {
    id?: number
    usage_type: $Enums.UsageType
    count?: number
    period_start: Date | string
    period_end: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UsageTrackingCreateOrConnectWithoutUserInput = {
    where: UsageTrackingWhereUniqueInput
    create: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput>
  }

  export type UsageTrackingCreateManyUserInputEnvelope = {
    data: UsageTrackingCreateManyUserInput | UsageTrackingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    id?: number
    plan_id: number
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type ProfileCreateWithoutUserInput = {
    is_premium?: boolean
    last_sync_at?: bigint | number | null
    institution?: InstitutionCreateNestedOneWithoutProfilesInput
    program?: ProgramCreateNestedOneWithoutProfilesInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    institution_id?: bigint | number | null
    program_id?: number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type QuizCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    battles?: BattleCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutUserInput = {
    id?: string
    subject_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    battles?: BattleUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutUserInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput>
  }

  export type QuizCreateManyUserInputEnvelope = {
    data: QuizCreateManyUserInput | QuizCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPointsCreateWithoutUserInput = {
    id?: string
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPointsUncheckedCreateWithoutUserInput = {
    id?: string
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPointsCreateOrConnectWithoutUserInput = {
    where: UserPointsWhereUniqueInput
    create: XOR<UserPointsCreateWithoutUserInput, UserPointsUncheckedCreateWithoutUserInput>
  }

  export type UserPointsCreateManyUserInputEnvelope = {
    data: UserPointsCreateManyUserInput | UserPointsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    earned_at?: Date | string
    badge: StreakBadgeCreateNestedOneWithoutUser_badgesInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badge_id: string
    earned_at?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LearningSessionCreateWithoutUserInput = {
    id?: string
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
    chapter: ChapterCreateNestedOneWithoutLearning_sessionsInput
  }

  export type LearningSessionUncheckedCreateWithoutUserInput = {
    id?: string
    chapter_id: bigint | number
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LearningSessionCreateOrConnectWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput>
  }

  export type LearningSessionCreateManyUserInputEnvelope = {
    data: LearningSessionCreateManyUserInput | LearningSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutCreatorInput = {
    id?: string
    code: string
    status?: $Enums.BattleStatus
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    quiz: QuizCreateNestedOneWithoutBattlesInput
    participants?: BattleParticipantCreateNestedManyWithoutBattleInput
  }

  export type BattleUncheckedCreateWithoutCreatorInput = {
    id?: string
    quiz_id: string
    code: string
    status?: $Enums.BattleStatus
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    participants?: BattleParticipantUncheckedCreateNestedManyWithoutBattleInput
  }

  export type BattleCreateOrConnectWithoutCreatorInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutCreatorInput, BattleUncheckedCreateWithoutCreatorInput>
  }

  export type BattleCreateManyCreatorInputEnvelope = {
    data: BattleCreateManyCreatorInput | BattleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type BattleParticipantCreateWithoutUserInput = {
    id?: string
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
    battle: BattleCreateNestedOneWithoutParticipantsInput
  }

  export type BattleParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    battle_id: string
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
  }

  export type BattleParticipantCreateOrConnectWithoutUserInput = {
    where: BattleParticipantWhereUniqueInput
    create: XOR<BattleParticipantCreateWithoutUserInput, BattleParticipantUncheckedCreateWithoutUserInput>
  }

  export type BattleParticipantCreateManyUserInputEnvelope = {
    data: BattleParticipantCreateManyUserInput | BattleParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TextbookCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    syllabus?: SyllabusCreateNestedOneWithoutTextbooksInput
    units?: TextbookUnitCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    units?: TextbookUnitUncheckedCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobUncheckedCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutTextbookInput
  }

  export type TextbookCreateOrConnectWithoutCreatorInput = {
    where: TextbookWhereUniqueInput
    create: XOR<TextbookCreateWithoutCreatorInput, TextbookUncheckedCreateWithoutCreatorInput>
  }

  export type TextbookCreateManyCreatorInputEnvelope = {
    data: TextbookCreateManyCreatorInput | TextbookCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserEnrollmentCreateWithoutUserInput = {
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
    textbook: TextbookCreateNestedOneWithoutEnrollmentsInput
  }

  export type UserEnrollmentUncheckedCreateWithoutUserInput = {
    id?: number
    textbook_id: number
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
  }

  export type UserEnrollmentCreateOrConnectWithoutUserInput = {
    where: UserEnrollmentWhereUniqueInput
    create: XOR<UserEnrollmentCreateWithoutUserInput, UserEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type UserEnrollmentCreateManyUserInputEnvelope = {
    data: UserEnrollmentCreateManyUserInput | UserEnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CategoryListUpsertWithWhereUniqueWithoutUserInput = {
    where: CategoryListWhereUniqueInput
    update: XOR<CategoryListUpdateWithoutUserInput, CategoryListUncheckedUpdateWithoutUserInput>
    create: XOR<CategoryListCreateWithoutUserInput, CategoryListUncheckedCreateWithoutUserInput>
  }

  export type CategoryListUpdateWithWhereUniqueWithoutUserInput = {
    where: CategoryListWhereUniqueInput
    data: XOR<CategoryListUpdateWithoutUserInput, CategoryListUncheckedUpdateWithoutUserInput>
  }

  export type CategoryListUpdateManyWithWhereWithoutUserInput = {
    where: CategoryListScalarWhereInput
    data: XOR<CategoryListUpdateManyMutationInput, CategoryListUncheckedUpdateManyWithoutUserInput>
  }

  export type CategoryListScalarWhereInput = {
    AND?: CategoryListScalarWhereInput | CategoryListScalarWhereInput[]
    OR?: CategoryListScalarWhereInput[]
    NOT?: CategoryListScalarWhereInput | CategoryListScalarWhereInput[]
    id?: IntFilter<"CategoryList"> | number
    category?: StringFilter<"CategoryList"> | string
    created_at?: DateTimeNullableFilter<"CategoryList"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"CategoryList"> | Date | string | null
    user_id?: IntNullableFilter<"CategoryList"> | number | null
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: IntFilter<"Conversation"> | number
    user_id?: IntFilter<"Conversation"> | number
    title?: StringFilter<"Conversation"> | string
    created_at?: DateTimeFilter<"Conversation"> | Date | string
    updated_at?: DateTimeFilter<"Conversation"> | Date | string
    last_message_at?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    message_count?: IntFilter<"Conversation"> | number
    is_pinned?: BoolFilter<"Conversation"> | boolean
    is_archived?: BoolFilter<"Conversation"> | boolean
    subject_id?: IntNullableFilter<"Conversation"> | number | null
    chapter_id?: BigIntNullableFilter<"Conversation"> | bigint | number | null
  }

  export type FileListUpsertWithWhereUniqueWithoutUserInput = {
    where: FileListWhereUniqueInput
    update: XOR<FileListUpdateWithoutUserInput, FileListUncheckedUpdateWithoutUserInput>
    create: XOR<FileListCreateWithoutUserInput, FileListUncheckedCreateWithoutUserInput>
  }

  export type FileListUpdateWithWhereUniqueWithoutUserInput = {
    where: FileListWhereUniqueInput
    data: XOR<FileListUpdateWithoutUserInput, FileListUncheckedUpdateWithoutUserInput>
  }

  export type FileListUpdateManyWithWhereWithoutUserInput = {
    where: FileListScalarWhereInput
    data: XOR<FileListUpdateManyMutationInput, FileListUncheckedUpdateManyWithoutUserInput>
  }

  export type FileListScalarWhereInput = {
    AND?: FileListScalarWhereInput | FileListScalarWhereInput[]
    OR?: FileListScalarWhereInput[]
    NOT?: FileListScalarWhereInput | FileListScalarWhereInput[]
    id?: IntFilter<"FileList"> | number
    category?: StringFilter<"FileList"> | string
    title?: StringFilter<"FileList"> | string
    note?: StringNullableFilter<"FileList"> | string | null
    content_format?: StringNullableFilter<"FileList"> | string | null
    doc1?: StringNullableFilter<"FileList"> | string | null
    entry_date?: StringNullableFilter<"FileList"> | string | null
    entry_date_real?: DateTimeNullableFilter<"FileList"> | Date | string | null
    created_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
    user_id?: IntNullableFilter<"FileList"> | number | null
    parsing_status?: StringNullableFilter<"FileList"> | string | null
    parsing_error?: StringNullableFilter<"FileList"> | string | null
    parsed_at?: DateTimeNullableFilter<"FileList"> | Date | string | null
  }

  export type UsageTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageTrackingWhereUniqueInput
    update: XOR<UsageTrackingUpdateWithoutUserInput, UsageTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<UsageTrackingCreateWithoutUserInput, UsageTrackingUncheckedCreateWithoutUserInput>
  }

  export type UsageTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageTrackingWhereUniqueInput
    data: XOR<UsageTrackingUpdateWithoutUserInput, UsageTrackingUncheckedUpdateWithoutUserInput>
  }

  export type UsageTrackingUpdateManyWithWhereWithoutUserInput = {
    where: UsageTrackingScalarWhereInput
    data: XOR<UsageTrackingUpdateManyMutationInput, UsageTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageTrackingScalarWhereInput = {
    AND?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
    OR?: UsageTrackingScalarWhereInput[]
    NOT?: UsageTrackingScalarWhereInput | UsageTrackingScalarWhereInput[]
    id?: IntFilter<"UsageTracking"> | number
    user_id?: IntFilter<"UsageTracking"> | number
    usage_type?: EnumUsageTypeFilter<"UsageTracking"> | $Enums.UsageType
    count?: IntFilter<"UsageTracking"> | number
    period_start?: DateTimeFilter<"UsageTracking"> | Date | string
    period_end?: DateTimeFilter<"UsageTracking"> | Date | string
    metadata?: JsonNullableFilter<"UsageTracking">
    created_at?: DateTimeFilter<"UsageTracking"> | Date | string
  }

  export type UserSubscriptionUpsertWithoutUserInput = {
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
    where?: UserSubscriptionWhereInput
  }

  export type UserSubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSubscriptionWhereInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    institution?: InstitutionUpdateOneWithoutProfilesNestedInput
    program?: ProgramUpdateOneWithoutProfilesNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type QuizUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutUserInput, QuizUncheckedUpdateWithoutUserInput>
    create: XOR<QuizCreateWithoutUserInput, QuizUncheckedCreateWithoutUserInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutUserInput, QuizUncheckedUpdateWithoutUserInput>
  }

  export type QuizUpdateManyWithWhereWithoutUserInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: StringFilter<"Quiz"> | string
    user_id?: IntFilter<"Quiz"> | number
    subject_id?: IntFilter<"Quiz"> | number
    chapter_id?: BigIntNullableFilter<"Quiz"> | bigint | number | null
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    status?: EnumQuizStatusFilter<"Quiz"> | $Enums.QuizStatus
    score?: IntFilter<"Quiz"> | number
    total_points?: IntFilter<"Quiz"> | number
    created_at?: DateTimeFilter<"Quiz"> | Date | string
    updated_at?: DateTimeFilter<"Quiz"> | Date | string
    completed_at?: DateTimeNullableFilter<"Quiz"> | Date | string | null
  }

  export type UserPointsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPointsWhereUniqueInput
    update: XOR<UserPointsUpdateWithoutUserInput, UserPointsUncheckedUpdateWithoutUserInput>
    create: XOR<UserPointsCreateWithoutUserInput, UserPointsUncheckedCreateWithoutUserInput>
  }

  export type UserPointsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPointsWhereUniqueInput
    data: XOR<UserPointsUpdateWithoutUserInput, UserPointsUncheckedUpdateWithoutUserInput>
  }

  export type UserPointsUpdateManyWithWhereWithoutUserInput = {
    where: UserPointsScalarWhereInput
    data: XOR<UserPointsUpdateManyMutationInput, UserPointsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPointsScalarWhereInput = {
    AND?: UserPointsScalarWhereInput | UserPointsScalarWhereInput[]
    OR?: UserPointsScalarWhereInput[]
    NOT?: UserPointsScalarWhereInput | UserPointsScalarWhereInput[]
    id?: StringFilter<"UserPoints"> | string
    user_id?: IntFilter<"UserPoints"> | number
    points?: IntFilter<"UserPoints"> | number
    reason?: StringFilter<"UserPoints"> | string
    metadata?: JsonNullableFilter<"UserPoints">
    created_at?: DateTimeFilter<"UserPoints"> | Date | string
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    user_id?: IntFilter<"UserBadge"> | number
    badge_id?: StringFilter<"UserBadge"> | string
    earned_at?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type LearningSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    update: XOR<LearningSessionUpdateWithoutUserInput, LearningSessionUncheckedUpdateWithoutUserInput>
    create: XOR<LearningSessionCreateWithoutUserInput, LearningSessionUncheckedCreateWithoutUserInput>
  }

  export type LearningSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningSessionWhereUniqueInput
    data: XOR<LearningSessionUpdateWithoutUserInput, LearningSessionUncheckedUpdateWithoutUserInput>
  }

  export type LearningSessionUpdateManyWithWhereWithoutUserInput = {
    where: LearningSessionScalarWhereInput
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningSessionScalarWhereInput = {
    AND?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
    OR?: LearningSessionScalarWhereInput[]
    NOT?: LearningSessionScalarWhereInput | LearningSessionScalarWhereInput[]
    id?: StringFilter<"LearningSession"> | string
    user_id?: IntFilter<"LearningSession"> | number
    chapter_id?: BigIntFilter<"LearningSession"> | bigint | number
    status?: StringFilter<"LearningSession"> | string
    current_topic?: StringNullableFilter<"LearningSession"> | string | null
    progress?: IntFilter<"LearningSession"> | number
    created_at?: DateTimeFilter<"LearningSession"> | Date | string
    updated_at?: DateTimeFilter<"LearningSession"> | Date | string
  }

  export type BattleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutCreatorInput, BattleUncheckedUpdateWithoutCreatorInput>
    create: XOR<BattleCreateWithoutCreatorInput, BattleUncheckedCreateWithoutCreatorInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutCreatorInput, BattleUncheckedUpdateWithoutCreatorInput>
  }

  export type BattleUpdateManyWithWhereWithoutCreatorInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type BattleScalarWhereInput = {
    AND?: BattleScalarWhereInput | BattleScalarWhereInput[]
    OR?: BattleScalarWhereInput[]
    NOT?: BattleScalarWhereInput | BattleScalarWhereInput[]
    id?: StringFilter<"Battle"> | string
    quiz_id?: StringFilter<"Battle"> | string
    code?: StringFilter<"Battle"> | string
    status?: EnumBattleStatusFilter<"Battle"> | $Enums.BattleStatus
    created_by?: IntFilter<"Battle"> | number
    created_at?: DateTimeFilter<"Battle"> | Date | string
    started_at?: DateTimeNullableFilter<"Battle"> | Date | string | null
    ended_at?: DateTimeNullableFilter<"Battle"> | Date | string | null
    settings?: JsonNullableFilter<"Battle">
  }

  export type BattleParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: BattleParticipantWhereUniqueInput
    update: XOR<BattleParticipantUpdateWithoutUserInput, BattleParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<BattleParticipantCreateWithoutUserInput, BattleParticipantUncheckedCreateWithoutUserInput>
  }

  export type BattleParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: BattleParticipantWhereUniqueInput
    data: XOR<BattleParticipantUpdateWithoutUserInput, BattleParticipantUncheckedUpdateWithoutUserInput>
  }

  export type BattleParticipantUpdateManyWithWhereWithoutUserInput = {
    where: BattleParticipantScalarWhereInput
    data: XOR<BattleParticipantUpdateManyMutationInput, BattleParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type BattleParticipantScalarWhereInput = {
    AND?: BattleParticipantScalarWhereInput | BattleParticipantScalarWhereInput[]
    OR?: BattleParticipantScalarWhereInput[]
    NOT?: BattleParticipantScalarWhereInput | BattleParticipantScalarWhereInput[]
    id?: StringFilter<"BattleParticipant"> | string
    battle_id?: StringFilter<"BattleParticipant"> | string
    user_id?: IntFilter<"BattleParticipant"> | number
    score?: IntFilter<"BattleParticipant"> | number
    current_q_index?: IntFilter<"BattleParticipant"> | number
    finished?: BoolFilter<"BattleParticipant"> | boolean
    joined_at?: DateTimeFilter<"BattleParticipant"> | Date | string
    last_active?: DateTimeFilter<"BattleParticipant"> | Date | string
  }

  export type TextbookUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TextbookWhereUniqueInput
    update: XOR<TextbookUpdateWithoutCreatorInput, TextbookUncheckedUpdateWithoutCreatorInput>
    create: XOR<TextbookCreateWithoutCreatorInput, TextbookUncheckedCreateWithoutCreatorInput>
  }

  export type TextbookUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TextbookWhereUniqueInput
    data: XOR<TextbookUpdateWithoutCreatorInput, TextbookUncheckedUpdateWithoutCreatorInput>
  }

  export type TextbookUpdateManyWithWhereWithoutCreatorInput = {
    where: TextbookScalarWhereInput
    data: XOR<TextbookUpdateManyMutationInput, TextbookUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TextbookScalarWhereInput = {
    AND?: TextbookScalarWhereInput | TextbookScalarWhereInput[]
    OR?: TextbookScalarWhereInput[]
    NOT?: TextbookScalarWhereInput | TextbookScalarWhereInput[]
    id?: IntFilter<"Textbook"> | number
    title?: StringFilter<"Textbook"> | string
    description?: StringNullableFilter<"Textbook"> | string | null
    class_level?: StringFilter<"Textbook"> | string
    stream?: StringNullableFilter<"Textbook"> | string | null
    subject_name?: StringNullableFilter<"Textbook"> | string | null
    board_id?: StringNullableFilter<"Textbook"> | string | null
    academic_year?: StringNullableFilter<"Textbook"> | string | null
    author?: StringNullableFilter<"Textbook"> | string | null
    syllabus_id?: IntNullableFilter<"Textbook"> | number | null
    raw_syllabus?: StringNullableFilter<"Textbook"> | string | null
    status?: EnumTextbookStatusFilter<"Textbook"> | $Enums.TextbookStatus
    progress?: IntFilter<"Textbook"> | number
    cover_image_url?: StringNullableFilter<"Textbook"> | string | null
    pdf_url?: StringNullableFilter<"Textbook"> | string | null
    compiled_pdf_url?: StringNullableFilter<"Textbook"> | string | null
    created_at?: DateTimeFilter<"Textbook"> | Date | string
    updated_at?: DateTimeFilter<"Textbook"> | Date | string
    created_by?: IntFilter<"Textbook"> | number
  }

  export type UserEnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEnrollmentWhereUniqueInput
    update: XOR<UserEnrollmentUpdateWithoutUserInput, UserEnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<UserEnrollmentCreateWithoutUserInput, UserEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type UserEnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEnrollmentWhereUniqueInput
    data: XOR<UserEnrollmentUpdateWithoutUserInput, UserEnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type UserEnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: UserEnrollmentScalarWhereInput
    data: XOR<UserEnrollmentUpdateManyMutationInput, UserEnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserEnrollmentScalarWhereInput = {
    AND?: UserEnrollmentScalarWhereInput | UserEnrollmentScalarWhereInput[]
    OR?: UserEnrollmentScalarWhereInput[]
    NOT?: UserEnrollmentScalarWhereInput | UserEnrollmentScalarWhereInput[]
    id?: IntFilter<"UserEnrollment"> | number
    user_id?: IntFilter<"UserEnrollment"> | number
    textbook_id?: IntFilter<"UserEnrollment"> | number
    status?: StringFilter<"UserEnrollment"> | string
    progress?: IntFilter<"UserEnrollment"> | number
    last_accessed_at?: DateTimeNullableFilter<"UserEnrollment"> | Date | string | null
    enrolled_at?: DateTimeFilter<"UserEnrollment"> | Date | string
    completed_at?: DateTimeNullableFilter<"UserEnrollment"> | Date | string | null
  }

  export type userCreateWithoutEnrollmentsInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
  }

  export type userUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type userCreateOrConnectWithoutEnrollmentsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEnrollmentsInput, userUncheckedCreateWithoutEnrollmentsInput>
  }

  export type TextbookCreateWithoutEnrollmentsInput = {
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    syllabus?: SyllabusCreateNestedOneWithoutTextbooksInput
    creator: userCreateNestedOneWithoutTextbooks_createdInput
    units?: TextbookUnitCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
    units?: TextbookUnitUncheckedCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobUncheckedCreateNestedManyWithoutTextbookInput
  }

  export type TextbookCreateOrConnectWithoutEnrollmentsInput = {
    where: TextbookWhereUniqueInput
    create: XOR<TextbookCreateWithoutEnrollmentsInput, TextbookUncheckedCreateWithoutEnrollmentsInput>
  }

  export type userUpsertWithoutEnrollmentsInput = {
    update: XOR<userUpdateWithoutEnrollmentsInput, userUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<userCreateWithoutEnrollmentsInput, userUncheckedCreateWithoutEnrollmentsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEnrollmentsInput, userUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type userUpdateWithoutEnrollmentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
  }

  export type userUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TextbookUpsertWithoutEnrollmentsInput = {
    update: XOR<TextbookUpdateWithoutEnrollmentsInput, TextbookUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<TextbookCreateWithoutEnrollmentsInput, TextbookUncheckedCreateWithoutEnrollmentsInput>
    where?: TextbookWhereInput
  }

  export type TextbookUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: TextbookWhereInput
    data: XOR<TextbookUpdateWithoutEnrollmentsInput, TextbookUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type TextbookUpdateWithoutEnrollmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    syllabus?: SyllabusUpdateOneWithoutTextbooksNestedInput
    creator?: userUpdateOneRequiredWithoutTextbooks_createdNestedInput
    units?: TextbookUnitUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
    units?: TextbookUnitUncheckedUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUncheckedUpdateManyWithoutTextbookNestedInput
  }

  export type ConversationMessageCreateWithoutConversationInput = {
    role: $Enums.MessageRole
    content: string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ConversationMessageUncheckedCreateWithoutConversationInput = {
    id?: number
    role: $Enums.MessageRole
    content: string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ConversationMessageCreateOrConnectWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMessageCreateManyConversationInputEnvelope = {
    data: ConversationMessageCreateManyConversationInput | ConversationMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutConversationsInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutConversationsInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutConversationsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutConversationsInput, userUncheckedCreateWithoutConversationsInput>
  }

  export type SubjectCreateWithoutConversationsInput = {
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    program: ProgramCreateNestedOneWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    quizzes?: QuizCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutConversationsInput = {
    id?: number
    program_id: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutConversationsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutConversationsInput, SubjectUncheckedCreateWithoutConversationsInput>
  }

  export type ChapterCreateWithoutConversationsInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutConversationsInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutConversationsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutConversationsInput, ChapterUncheckedCreateWithoutConversationsInput>
  }

  export type ConversationMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    update: XOR<ConversationMessageUpdateWithoutConversationInput, ConversationMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    data: XOR<ConversationMessageUpdateWithoutConversationInput, ConversationMessageUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationMessageUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationMessageScalarWhereInput
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationMessageScalarWhereInput = {
    AND?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
    OR?: ConversationMessageScalarWhereInput[]
    NOT?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
    id?: IntFilter<"ConversationMessage"> | number
    conversation_id?: IntFilter<"ConversationMessage"> | number
    role?: EnumMessageRoleFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringFilter<"ConversationMessage"> | string
    sources?: JsonNullableFilter<"ConversationMessage">
    token_count?: JsonNullableFilter<"ConversationMessage">
    metadata?: JsonNullableFilter<"ConversationMessage">
    created_at?: DateTimeFilter<"ConversationMessage"> | Date | string
  }

  export type userUpsertWithoutConversationsInput = {
    update: XOR<userUpdateWithoutConversationsInput, userUncheckedUpdateWithoutConversationsInput>
    create: XOR<userCreateWithoutConversationsInput, userUncheckedCreateWithoutConversationsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutConversationsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutConversationsInput, userUncheckedUpdateWithoutConversationsInput>
  }

  export type userUpdateWithoutConversationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutConversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubjectUpsertWithoutConversationsInput = {
    update: XOR<SubjectUpdateWithoutConversationsInput, SubjectUncheckedUpdateWithoutConversationsInput>
    create: XOR<SubjectCreateWithoutConversationsInput, SubjectUncheckedCreateWithoutConversationsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutConversationsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutConversationsInput, SubjectUncheckedUpdateWithoutConversationsInput>
  }

  export type SubjectUpdateWithoutConversationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    quizzes?: QuizUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutConversationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ChapterUpsertWithoutConversationsInput = {
    update: XOR<ChapterUpdateWithoutConversationsInput, ChapterUncheckedUpdateWithoutConversationsInput>
    create: XOR<ChapterCreateWithoutConversationsInput, ChapterUncheckedCreateWithoutConversationsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutConversationsInput, ChapterUncheckedUpdateWithoutConversationsInput>
  }

  export type ChapterUpdateWithoutConversationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutConversationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    user: userCreateNestedOneWithoutConversationsInput
    subject?: SubjectCreateNestedOneWithoutConversationsInput
    chapter?: ChapterCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
    chapter_id?: bigint | number | null
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutConversationsNestedInput
    subject?: SubjectUpdateOneWithoutConversationsNestedInput
    chapter?: ChapterUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type UserSubscriptionCreateWithoutPlanInput = {
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: number
    user_id: number
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionCreateManyPlanInputEnvelope = {
    data: UserSubscriptionCreateManyPlanInput | UserSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserSubscriptionScalarWhereInput = {
    AND?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    OR?: UserSubscriptionScalarWhereInput[]
    NOT?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    id?: IntFilter<"UserSubscription"> | number
    user_id?: IntFilter<"UserSubscription"> | number
    plan_id?: IntFilter<"UserSubscription"> | number
    razorpay_subscription_id?: StringNullableFilter<"UserSubscription"> | string | null
    razorpay_customer_id?: StringNullableFilter<"UserSubscription"> | string | null
    razorpay_order_id?: StringNullableFilter<"UserSubscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFilter<"UserSubscription"> | $Enums.BillingCycle
    current_period_start?: DateTimeFilter<"UserSubscription"> | Date | string
    current_period_end?: DateTimeFilter<"UserSubscription"> | Date | string
    cancel_at_period_end?: BoolFilter<"UserSubscription"> | boolean
    canceled_at?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    created_at?: DateTimeFilter<"UserSubscription"> | Date | string
    updated_at?: DateTimeFilter<"UserSubscription"> | Date | string
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    name: string
    display_name: string
    description?: string | null
    price_monthly: Decimal | DecimalJsLike | number | string
    price_yearly?: Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: string | null
    razorpay_plan_id_yearly?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    name: string
    display_name: string
    description?: string | null
    price_monthly: Decimal | DecimalJsLike | number | string
    price_yearly?: Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: string | null
    razorpay_plan_id_yearly?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_default?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type userCreateWithoutSubscriptionInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSubscriptionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_monthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_yearly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_plan_id_yearly?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_monthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_yearly?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    razorpay_plan_id_monthly?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_plan_id_yearly?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutSubscriptionInput = {
    update: XOR<userUpdateWithoutSubscriptionInput, userUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSubscriptionInput, userUncheckedUpdateWithoutSubscriptionInput>
  }

  export type userUpdateWithoutSubscriptionInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUsage_trackingInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUsage_trackingInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUsage_trackingInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUsage_trackingInput, userUncheckedCreateWithoutUsage_trackingInput>
  }

  export type userUpsertWithoutUsage_trackingInput = {
    update: XOR<userUpdateWithoutUsage_trackingInput, userUncheckedUpdateWithoutUsage_trackingInput>
    create: XOR<userCreateWithoutUsage_trackingInput, userUncheckedCreateWithoutUsage_trackingInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUsage_trackingInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUsage_trackingInput, userUncheckedUpdateWithoutUsage_trackingInput>
  }

  export type userUpdateWithoutUsage_trackingInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUsage_trackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BoardCreateWithoutCountryInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    institutions?: InstitutionCreateNestedManyWithoutBoardInput
    programs?: ProgramCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutCountryInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    institutions?: InstitutionUncheckedCreateNestedManyWithoutBoardInput
    programs?: ProgramUncheckedCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutCountryInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutCountryInput, BoardUncheckedCreateWithoutCountryInput>
  }

  export type BoardCreateManyCountryInputEnvelope = {
    data: BoardCreateManyCountryInput | BoardCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithWhereUniqueWithoutCountryInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutCountryInput, BoardUncheckedUpdateWithoutCountryInput>
    create: XOR<BoardCreateWithoutCountryInput, BoardUncheckedCreateWithoutCountryInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutCountryInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutCountryInput, BoardUncheckedUpdateWithoutCountryInput>
  }

  export type BoardUpdateManyWithWhereWithoutCountryInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutCountryInput>
  }

  export type BoardScalarWhereInput = {
    AND?: BoardScalarWhereInput | BoardScalarWhereInput[]
    OR?: BoardScalarWhereInput[]
    NOT?: BoardScalarWhereInput | BoardScalarWhereInput[]
    id?: StringFilter<"Board"> | string
    name?: StringFilter<"Board"> | string
    country_id?: StringFilter<"Board"> | string
    state?: StringNullableFilter<"Board"> | string | null
    type?: StringFilter<"Board"> | string
    is_active?: BoolFilter<"Board"> | boolean
    created_at?: DateTimeFilter<"Board"> | Date | string
    updated_at?: DateTimeFilter<"Board"> | Date | string
  }

  export type CountryCreateWithoutBoardsInput = {
    id: string
    name: string
    currency: string
    locale?: string
    is_active?: boolean
  }

  export type CountryUncheckedCreateWithoutBoardsInput = {
    id: string
    name: string
    currency: string
    locale?: string
    is_active?: boolean
  }

  export type CountryCreateOrConnectWithoutBoardsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutBoardsInput, CountryUncheckedCreateWithoutBoardsInput>
  }

  export type InstitutionCreateWithoutBoardInput = {
    id?: bigint | number
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    programs?: ProgramCreateNestedManyWithoutInstitutionInput
    profiles?: ProfileCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutBoardInput = {
    id?: bigint | number
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutInstitutionInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutBoardInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutBoardInput, InstitutionUncheckedCreateWithoutBoardInput>
  }

  export type InstitutionCreateManyBoardInputEnvelope = {
    data: InstitutionCreateManyBoardInput | InstitutionCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutBoardInput = {
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    institution?: InstitutionCreateNestedOneWithoutProgramsInput
    subjects?: SubjectCreateNestedManyWithoutProgramInput
    profiles?: ProfileCreateNestedManyWithoutProgramInput
    exams?: ExamCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutBoardInput = {
    id?: number
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutProgramInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutProgramInput
    exams?: ExamUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutBoardInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutBoardInput, ProgramUncheckedCreateWithoutBoardInput>
  }

  export type ProgramCreateManyBoardInputEnvelope = {
    data: ProgramCreateManyBoardInput | ProgramCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type ChapterChunkBoardCreateWithoutBoardInput = {
    chunk: ChapterChunkCreateNestedOneWithoutChunkBoardsInput
  }

  export type ChapterChunkBoardUncheckedCreateWithoutBoardInput = {
    chunk_id: bigint | number
  }

  export type ChapterChunkBoardCreateOrConnectWithoutBoardInput = {
    where: ChapterChunkBoardWhereUniqueInput
    create: XOR<ChapterChunkBoardCreateWithoutBoardInput, ChapterChunkBoardUncheckedCreateWithoutBoardInput>
  }

  export type ChapterChunkBoardCreateManyBoardInputEnvelope = {
    data: ChapterChunkBoardCreateManyBoardInput | ChapterChunkBoardCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutBoardsInput = {
    update: XOR<CountryUpdateWithoutBoardsInput, CountryUncheckedUpdateWithoutBoardsInput>
    create: XOR<CountryCreateWithoutBoardsInput, CountryUncheckedCreateWithoutBoardsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutBoardsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutBoardsInput, CountryUncheckedUpdateWithoutBoardsInput>
  }

  export type CountryUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CountryUncheckedUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstitutionUpsertWithWhereUniqueWithoutBoardInput = {
    where: InstitutionWhereUniqueInput
    update: XOR<InstitutionUpdateWithoutBoardInput, InstitutionUncheckedUpdateWithoutBoardInput>
    create: XOR<InstitutionCreateWithoutBoardInput, InstitutionUncheckedCreateWithoutBoardInput>
  }

  export type InstitutionUpdateWithWhereUniqueWithoutBoardInput = {
    where: InstitutionWhereUniqueInput
    data: XOR<InstitutionUpdateWithoutBoardInput, InstitutionUncheckedUpdateWithoutBoardInput>
  }

  export type InstitutionUpdateManyWithWhereWithoutBoardInput = {
    where: InstitutionScalarWhereInput
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyWithoutBoardInput>
  }

  export type InstitutionScalarWhereInput = {
    AND?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
    OR?: InstitutionScalarWhereInput[]
    NOT?: InstitutionScalarWhereInput | InstitutionScalarWhereInput[]
    id?: BigIntFilter<"Institution"> | bigint | number
    board_id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    type?: StringFilter<"Institution"> | string
    district?: StringNullableFilter<"Institution"> | string | null
    state?: StringNullableFilter<"Institution"> | string | null
    license_expiry?: DateTimeNullableFilter<"Institution"> | Date | string | null
    is_active?: BoolFilter<"Institution"> | boolean
    created_at?: DateTimeFilter<"Institution"> | Date | string
  }

  export type ProgramUpsertWithWhereUniqueWithoutBoardInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutBoardInput, ProgramUncheckedUpdateWithoutBoardInput>
    create: XOR<ProgramCreateWithoutBoardInput, ProgramUncheckedCreateWithoutBoardInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutBoardInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutBoardInput, ProgramUncheckedUpdateWithoutBoardInput>
  }

  export type ProgramUpdateManyWithWhereWithoutBoardInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutBoardInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: IntFilter<"Program"> | number
    board_id?: StringFilter<"Program"> | string
    institution_id?: BigIntNullableFilter<"Program"> | bigint | number | null
    name?: StringFilter<"Program"> | string
    code?: StringNullableFilter<"Program"> | string | null
    level?: StringNullableFilter<"Program"> | string | null
    duration_years?: IntNullableFilter<"Program"> | number | null
    is_active?: BoolFilter<"Program"> | boolean
    created_at?: DateTimeFilter<"Program"> | Date | string
  }

  export type ChapterChunkBoardUpsertWithWhereUniqueWithoutBoardInput = {
    where: ChapterChunkBoardWhereUniqueInput
    update: XOR<ChapterChunkBoardUpdateWithoutBoardInput, ChapterChunkBoardUncheckedUpdateWithoutBoardInput>
    create: XOR<ChapterChunkBoardCreateWithoutBoardInput, ChapterChunkBoardUncheckedCreateWithoutBoardInput>
  }

  export type ChapterChunkBoardUpdateWithWhereUniqueWithoutBoardInput = {
    where: ChapterChunkBoardWhereUniqueInput
    data: XOR<ChapterChunkBoardUpdateWithoutBoardInput, ChapterChunkBoardUncheckedUpdateWithoutBoardInput>
  }

  export type ChapterChunkBoardUpdateManyWithWhereWithoutBoardInput = {
    where: ChapterChunkBoardScalarWhereInput
    data: XOR<ChapterChunkBoardUpdateManyMutationInput, ChapterChunkBoardUncheckedUpdateManyWithoutBoardInput>
  }

  export type ChapterChunkBoardScalarWhereInput = {
    AND?: ChapterChunkBoardScalarWhereInput | ChapterChunkBoardScalarWhereInput[]
    OR?: ChapterChunkBoardScalarWhereInput[]
    NOT?: ChapterChunkBoardScalarWhereInput | ChapterChunkBoardScalarWhereInput[]
    chunk_id?: BigIntFilter<"ChapterChunkBoard"> | bigint | number
    board_id?: StringFilter<"ChapterChunkBoard"> | string
  }

  export type BoardCreateWithoutInstitutionsInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    country?: CountryCreateNestedOneWithoutBoardsInput
    programs?: ProgramCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutInstitutionsInput = {
    id: string
    name: string
    country_id?: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutInstitutionsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutInstitutionsInput, BoardUncheckedCreateWithoutInstitutionsInput>
  }

  export type ProgramCreateWithoutInstitutionInput = {
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutProgramsInput
    subjects?: SubjectCreateNestedManyWithoutProgramInput
    profiles?: ProfileCreateNestedManyWithoutProgramInput
    exams?: ExamCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutInstitutionInput = {
    id?: number
    board_id: string
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutProgramInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutProgramInput
    exams?: ExamUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutInstitutionInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutInstitutionInput, ProgramUncheckedCreateWithoutInstitutionInput>
  }

  export type ProgramCreateManyInstitutionInputEnvelope = {
    data: ProgramCreateManyInstitutionInput | ProgramCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutInstitutionInput = {
    is_premium?: boolean
    last_sync_at?: bigint | number | null
    user: userCreateNestedOneWithoutProfileInput
    program?: ProgramCreateNestedOneWithoutProfilesInput
  }

  export type ProfileUncheckedCreateWithoutInstitutionInput = {
    id?: number
    user_id: number
    program_id?: number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ProfileCreateOrConnectWithoutInstitutionInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutInstitutionInput, ProfileUncheckedCreateWithoutInstitutionInput>
  }

  export type ProfileCreateManyInstitutionInputEnvelope = {
    data: ProfileCreateManyInstitutionInput | ProfileCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutInstitutionsInput = {
    update: XOR<BoardUpdateWithoutInstitutionsInput, BoardUncheckedUpdateWithoutInstitutionsInput>
    create: XOR<BoardCreateWithoutInstitutionsInput, BoardUncheckedCreateWithoutInstitutionsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutInstitutionsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutInstitutionsInput, BoardUncheckedUpdateWithoutInstitutionsInput>
  }

  export type BoardUpdateWithoutInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutBoardsNestedInput
    programs?: ProgramUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutInstitutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type ProgramUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutInstitutionInput, ProgramUncheckedUpdateWithoutInstitutionInput>
    create: XOR<ProgramCreateWithoutInstitutionInput, ProgramUncheckedCreateWithoutInstitutionInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutInstitutionInput, ProgramUncheckedUpdateWithoutInstitutionInput>
  }

  export type ProgramUpdateManyWithWhereWithoutInstitutionInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type ProfileUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutInstitutionInput, ProfileUncheckedUpdateWithoutInstitutionInput>
    create: XOR<ProfileCreateWithoutInstitutionInput, ProfileUncheckedCreateWithoutInstitutionInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutInstitutionInput, ProfileUncheckedUpdateWithoutInstitutionInput>
  }

  export type ProfileUpdateManyWithWhereWithoutInstitutionInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: IntFilter<"Profile"> | number
    user_id?: IntFilter<"Profile"> | number
    institution_id?: BigIntNullableFilter<"Profile"> | bigint | number | null
    program_id?: IntNullableFilter<"Profile"> | number | null
    is_premium?: BoolFilter<"Profile"> | boolean
    last_sync_at?: BigIntNullableFilter<"Profile"> | bigint | number | null
  }

  export type BoardCreateWithoutProgramsInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    country?: CountryCreateNestedOneWithoutBoardsInput
    institutions?: InstitutionCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutProgramsInput = {
    id: string
    name: string
    country_id?: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    institutions?: InstitutionUncheckedCreateNestedManyWithoutBoardInput
    chunkBoards?: ChapterChunkBoardUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutProgramsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutProgramsInput, BoardUncheckedCreateWithoutProgramsInput>
  }

  export type InstitutionCreateWithoutProgramsInput = {
    id?: bigint | number
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutInstitutionsInput
    profiles?: ProfileCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutProgramsInput = {
    id?: bigint | number
    board_id: string
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutProgramsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutProgramsInput, InstitutionUncheckedCreateWithoutProgramsInput>
  }

  export type SubjectCreateWithoutProgramInput = {
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    quizzes?: QuizCreateNestedManyWithoutSubjectInput
    conversations?: ConversationCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutProgramInput = {
    id?: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutSubjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutProgramInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutProgramInput, SubjectUncheckedCreateWithoutProgramInput>
  }

  export type SubjectCreateManyProgramInputEnvelope = {
    data: SubjectCreateManyProgramInput | SubjectCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutProgramInput = {
    is_premium?: boolean
    last_sync_at?: bigint | number | null
    user: userCreateNestedOneWithoutProfileInput
    institution?: InstitutionCreateNestedOneWithoutProfilesInput
  }

  export type ProfileUncheckedCreateWithoutProgramInput = {
    id?: number
    user_id: number
    institution_id?: bigint | number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ProfileCreateOrConnectWithoutProgramInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutProgramInput, ProfileUncheckedCreateWithoutProgramInput>
  }

  export type ProfileCreateManyProgramInputEnvelope = {
    data: ProfileCreateManyProgramInput | ProfileCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutProgramInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExamUncheckedCreateWithoutProgramInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ExamCreateOrConnectWithoutProgramInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutProgramInput, ExamUncheckedCreateWithoutProgramInput>
  }

  export type ExamCreateManyProgramInputEnvelope = {
    data: ExamCreateManyProgramInput | ExamCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutProgramsInput = {
    update: XOR<BoardUpdateWithoutProgramsInput, BoardUncheckedUpdateWithoutProgramsInput>
    create: XOR<BoardCreateWithoutProgramsInput, BoardUncheckedCreateWithoutProgramsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutProgramsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutProgramsInput, BoardUncheckedUpdateWithoutProgramsInput>
  }

  export type BoardUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutBoardsNestedInput
    institutions?: InstitutionUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUncheckedUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type InstitutionUpsertWithoutProgramsInput = {
    update: XOR<InstitutionUpdateWithoutProgramsInput, InstitutionUncheckedUpdateWithoutProgramsInput>
    create: XOR<InstitutionCreateWithoutProgramsInput, InstitutionUncheckedCreateWithoutProgramsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutProgramsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutProgramsInput, InstitutionUncheckedUpdateWithoutProgramsInput>
  }

  export type InstitutionUpdateWithoutProgramsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutInstitutionsNestedInput
    profiles?: ProfileUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutProgramsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutProgramInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutProgramInput, SubjectUncheckedUpdateWithoutProgramInput>
    create: XOR<SubjectCreateWithoutProgramInput, SubjectUncheckedCreateWithoutProgramInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutProgramInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutProgramInput, SubjectUncheckedUpdateWithoutProgramInput>
  }

  export type SubjectUpdateManyWithWhereWithoutProgramInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutProgramInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: IntFilter<"Subject"> | number
    program_id?: IntFilter<"Subject"> | number
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    is_active?: BoolFilter<"Subject"> | boolean
    created_at?: DateTimeFilter<"Subject"> | Date | string
    term?: StringNullableFilter<"Subject"> | string | null
  }

  export type ProfileUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutProgramInput, ProfileUncheckedUpdateWithoutProgramInput>
    create: XOR<ProfileCreateWithoutProgramInput, ProfileUncheckedCreateWithoutProgramInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutProgramInput, ProfileUncheckedUpdateWithoutProgramInput>
  }

  export type ProfileUpdateManyWithWhereWithoutProgramInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutProgramInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutProgramInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutProgramInput, ExamUncheckedUpdateWithoutProgramInput>
    create: XOR<ExamCreateWithoutProgramInput, ExamUncheckedCreateWithoutProgramInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutProgramInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutProgramInput, ExamUncheckedUpdateWithoutProgramInput>
  }

  export type ExamUpdateManyWithWhereWithoutProgramInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutProgramInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    date?: DateTimeFilter<"Exam"> | Date | string
    program_id?: IntNullableFilter<"Exam"> | number | null
    is_active?: BoolFilter<"Exam"> | boolean
    created_at?: DateTimeFilter<"Exam"> | Date | string
    updated_at?: DateTimeFilter<"Exam"> | Date | string
  }

  export type userCreateWithoutProfileInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfileInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfileInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type InstitutionCreateWithoutProfilesInput = {
    id?: bigint | number
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutInstitutionsInput
    programs?: ProgramCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutProfilesInput = {
    id?: bigint | number
    board_id: string
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutProfilesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutProfilesInput, InstitutionUncheckedCreateWithoutProfilesInput>
  }

  export type ProgramCreateWithoutProfilesInput = {
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutProgramsInput
    institution?: InstitutionCreateNestedOneWithoutProgramsInput
    subjects?: SubjectCreateNestedManyWithoutProgramInput
    exams?: ExamCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutProfilesInput = {
    id?: number
    board_id: string
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutProgramInput
    exams?: ExamUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutProfilesInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutProfilesInput, ProgramUncheckedCreateWithoutProfilesInput>
  }

  export type userUpsertWithoutProfileInput = {
    update: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProfileInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateWithoutProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstitutionUpsertWithoutProfilesInput = {
    update: XOR<InstitutionUpdateWithoutProfilesInput, InstitutionUncheckedUpdateWithoutProfilesInput>
    create: XOR<InstitutionCreateWithoutProfilesInput, InstitutionUncheckedCreateWithoutProfilesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutProfilesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutProfilesInput, InstitutionUncheckedUpdateWithoutProfilesInput>
  }

  export type InstitutionUpdateWithoutProfilesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutInstitutionsNestedInput
    programs?: ProgramUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutProfilesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    board_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type ProgramUpsertWithoutProfilesInput = {
    update: XOR<ProgramUpdateWithoutProfilesInput, ProgramUncheckedUpdateWithoutProfilesInput>
    create: XOR<ProgramCreateWithoutProfilesInput, ProgramUncheckedCreateWithoutProfilesInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutProfilesInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutProfilesInput, ProgramUncheckedUpdateWithoutProfilesInput>
  }

  export type ProgramUpdateWithoutProfilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutProgramsNestedInput
    institution?: InstitutionUpdateOneWithoutProgramsNestedInput
    subjects?: SubjectUpdateManyWithoutProgramNestedInput
    exams?: ExamUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutProfilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutProgramNestedInput
    exams?: ExamUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateWithoutSubjectsInput = {
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutProgramsInput
    institution?: InstitutionCreateNestedOneWithoutProgramsInput
    profiles?: ProfileCreateNestedManyWithoutProgramInput
    exams?: ExamCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutSubjectsInput = {
    id?: number
    board_id: string
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    profiles?: ProfileUncheckedCreateNestedManyWithoutProgramInput
    exams?: ExamUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutSubjectsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutSubjectsInput, ProgramUncheckedCreateWithoutSubjectsInput>
  }

  export type ChapterCreateWithoutSubjectInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutSubjectInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterCreateManySubjectInputEnvelope = {
    data: ChapterCreateManySubjectInput | ChapterCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutSubjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    battles?: BattleCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutSubjectInput = {
    id?: string
    user_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    battles?: BattleUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutSubjectInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutSubjectInput, QuizUncheckedCreateWithoutSubjectInput>
  }

  export type QuizCreateManySubjectInputEnvelope = {
    data: QuizCreateManySubjectInput | QuizCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutSubjectInput = {
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    messages?: ConversationMessageCreateNestedManyWithoutConversationInput
    user: userCreateNestedOneWithoutConversationsInput
    chapter?: ChapterCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutSubjectInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    chapter_id?: bigint | number | null
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutSubjectInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutSubjectInput, ConversationUncheckedCreateWithoutSubjectInput>
  }

  export type ConversationCreateManySubjectInputEnvelope = {
    data: ConversationCreateManySubjectInput | ConversationCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutSubjectsInput = {
    update: XOR<ProgramUpdateWithoutSubjectsInput, ProgramUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ProgramCreateWithoutSubjectsInput, ProgramUncheckedCreateWithoutSubjectsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutSubjectsInput, ProgramUncheckedUpdateWithoutSubjectsInput>
  }

  export type ProgramUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutProgramsNestedInput
    institution?: InstitutionUpdateOneWithoutProgramsNestedInput
    profiles?: ProfileUpdateManyWithoutProgramNestedInput
    exams?: ExamUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: ProfileUncheckedUpdateManyWithoutProgramNestedInput
    exams?: ExamUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ChapterUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
  }

  export type ChapterUpdateManyWithWhereWithoutSubjectInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: BigIntFilter<"Chapter"> | bigint | number
    subject_id?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    chapter_number?: IntNullableFilter<"Chapter"> | number | null
    content_json?: JsonFilter<"Chapter">
    version_id?: StringFilter<"Chapter"> | string
    accessible_boards?: StringNullableListFilter<"Chapter">
    is_global?: BoolFilter<"Chapter"> | boolean
    is_active?: BoolFilter<"Chapter"> | boolean
    processing_status?: EnumChapterStatusFilter<"Chapter"> | $Enums.ChapterStatus
    error_message?: StringNullableFilter<"Chapter"> | string | null
    processed_at?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    created_at?: DateTimeFilter<"Chapter"> | Date | string
    updated_at?: DateTimeFilter<"Chapter"> | Date | string
    parsed_at?: DateTimeNullableFilter<"Chapter"> | Date | string | null
  }

  export type QuizUpsertWithWhereUniqueWithoutSubjectInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutSubjectInput, QuizUncheckedUpdateWithoutSubjectInput>
    create: XOR<QuizCreateWithoutSubjectInput, QuizUncheckedCreateWithoutSubjectInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutSubjectInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutSubjectInput, QuizUncheckedUpdateWithoutSubjectInput>
  }

  export type QuizUpdateManyWithWhereWithoutSubjectInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutSubjectInput, ConversationUncheckedUpdateWithoutSubjectInput>
    create: XOR<ConversationCreateWithoutSubjectInput, ConversationUncheckedCreateWithoutSubjectInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutSubjectInput, ConversationUncheckedUpdateWithoutSubjectInput>
  }

  export type ConversationUpdateManyWithWhereWithoutSubjectInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SubjectCreateWithoutChaptersInput = {
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    program: ProgramCreateNestedOneWithoutSubjectsInput
    quizzes?: QuizCreateNestedManyWithoutSubjectInput
    conversations?: ConversationCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutChaptersInput = {
    id?: number
    program_id: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutSubjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutChaptersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
  }

  export type ChapterChunkCreateWithoutChapterInput = {
    id?: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
    chunkBoards?: ChapterChunkBoardCreateNestedManyWithoutChunkInput
  }

  export type ChapterChunkUncheckedCreateWithoutChapterInput = {
    id?: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
    chunkBoards?: ChapterChunkBoardUncheckedCreateNestedManyWithoutChunkInput
  }

  export type ChapterChunkCreateOrConnectWithoutChapterInput = {
    where: ChapterChunkWhereUniqueInput
    create: XOR<ChapterChunkCreateWithoutChapterInput, ChapterChunkUncheckedCreateWithoutChapterInput>
  }

  export type ChapterChunkCreateManyChapterInputEnvelope = {
    data: ChapterChunkCreateManyChapterInput | ChapterChunkCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ChapterPageCreateWithoutChapterInput = {
    id?: bigint | number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type ChapterPageUncheckedCreateWithoutChapterInput = {
    id?: bigint | number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type ChapterPageCreateOrConnectWithoutChapterInput = {
    where: ChapterPageWhereUniqueInput
    create: XOR<ChapterPageCreateWithoutChapterInput, ChapterPageUncheckedCreateWithoutChapterInput>
  }

  export type ChapterPageCreateManyChapterInputEnvelope = {
    data: ChapterPageCreateManyChapterInput | ChapterPageCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutChapterInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutQuizzesInput
    subject: SubjectCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    battles?: BattleCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutChapterInput = {
    id?: string
    user_id: number
    subject_id: number
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    battles?: BattleUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutChapterInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput>
  }

  export type QuizCreateManyChapterInputEnvelope = {
    data: QuizCreateManyChapterInput | QuizCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type StudyMaterialCreateWithoutChapterInput = {
    id?: bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: string | null
    video_queries?: StudyMaterialCreatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StudyMaterialUncheckedCreateWithoutChapterInput = {
    id?: bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: string | null
    video_queries?: StudyMaterialCreatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StudyMaterialCreateOrConnectWithoutChapterInput = {
    where: StudyMaterialWhereUniqueInput
    create: XOR<StudyMaterialCreateWithoutChapterInput, StudyMaterialUncheckedCreateWithoutChapterInput>
  }

  export type LearningSessionCreateWithoutChapterInput = {
    id?: string
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutLearning_sessionsInput
  }

  export type LearningSessionUncheckedCreateWithoutChapterInput = {
    id?: string
    user_id: number
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type LearningSessionCreateOrConnectWithoutChapterInput = {
    where: LearningSessionWhereUniqueInput
    create: XOR<LearningSessionCreateWithoutChapterInput, LearningSessionUncheckedCreateWithoutChapterInput>
  }

  export type LearningSessionCreateManyChapterInputEnvelope = {
    data: LearningSessionCreateManyChapterInput | LearningSessionCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutChapterInput = {
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    messages?: ConversationMessageCreateNestedManyWithoutConversationInput
    user: userCreateNestedOneWithoutConversationsInput
    subject?: SubjectCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutChapterInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutChapterInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutChapterInput, ConversationUncheckedCreateWithoutChapterInput>
  }

  export type ConversationCreateManyChapterInputEnvelope = {
    data: ConversationCreateManyChapterInput | ConversationCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutChapterInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    points?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type QuestionUncheckedCreateWithoutChapterInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    points?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type QuestionCreateOrConnectWithoutChapterInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutChapterInput, QuestionUncheckedCreateWithoutChapterInput>
  }

  export type QuestionCreateManyChapterInputEnvelope = {
    data: QuestionCreateManyChapterInput | QuestionCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type SubjectUpsertWithoutChaptersInput = {
    update: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutChaptersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type SubjectUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutSubjectsNestedInput
    quizzes?: QuizUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ChapterChunkUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterChunkWhereUniqueInput
    update: XOR<ChapterChunkUpdateWithoutChapterInput, ChapterChunkUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterChunkCreateWithoutChapterInput, ChapterChunkUncheckedCreateWithoutChapterInput>
  }

  export type ChapterChunkUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterChunkWhereUniqueInput
    data: XOR<ChapterChunkUpdateWithoutChapterInput, ChapterChunkUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterChunkUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterChunkScalarWhereInput
    data: XOR<ChapterChunkUpdateManyMutationInput, ChapterChunkUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterChunkScalarWhereInput = {
    AND?: ChapterChunkScalarWhereInput | ChapterChunkScalarWhereInput[]
    OR?: ChapterChunkScalarWhereInput[]
    NOT?: ChapterChunkScalarWhereInput | ChapterChunkScalarWhereInput[]
    id?: BigIntFilter<"ChapterChunk"> | bigint | number
    chapter_id?: BigIntFilter<"ChapterChunk"> | bigint | number
    chunk_index?: IntFilter<"ChapterChunk"> | number
    content?: StringFilter<"ChapterChunk"> | string
    page_number?: IntNullableFilter<"ChapterChunk"> | number | null
    bbox?: JsonNullableFilter<"ChapterChunk">
    subject_id?: IntNullableFilter<"ChapterChunk"> | number | null
    created_at?: DateTimeFilter<"ChapterChunk"> | Date | string
  }

  export type ChapterPageUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterPageWhereUniqueInput
    update: XOR<ChapterPageUpdateWithoutChapterInput, ChapterPageUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterPageCreateWithoutChapterInput, ChapterPageUncheckedCreateWithoutChapterInput>
  }

  export type ChapterPageUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterPageWhereUniqueInput
    data: XOR<ChapterPageUpdateWithoutChapterInput, ChapterPageUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterPageUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterPageScalarWhereInput
    data: XOR<ChapterPageUpdateManyMutationInput, ChapterPageUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterPageScalarWhereInput = {
    AND?: ChapterPageScalarWhereInput | ChapterPageScalarWhereInput[]
    OR?: ChapterPageScalarWhereInput[]
    NOT?: ChapterPageScalarWhereInput | ChapterPageScalarWhereInput[]
    id?: BigIntFilter<"ChapterPage"> | bigint | number
    chapter_id?: BigIntFilter<"ChapterPage"> | bigint | number
    page_number?: IntFilter<"ChapterPage"> | number
    image_url?: StringFilter<"ChapterPage"> | string
    width?: IntNullableFilter<"ChapterPage"> | number | null
    height?: IntNullableFilter<"ChapterPage"> | number | null
    created_at?: DateTimeFilter<"ChapterPage"> | Date | string
  }

  export type QuizUpsertWithWhereUniqueWithoutChapterInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutChapterInput, QuizUncheckedUpdateWithoutChapterInput>
    create: XOR<QuizCreateWithoutChapterInput, QuizUncheckedCreateWithoutChapterInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutChapterInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutChapterInput, QuizUncheckedUpdateWithoutChapterInput>
  }

  export type QuizUpdateManyWithWhereWithoutChapterInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutChapterInput>
  }

  export type StudyMaterialUpsertWithoutChapterInput = {
    update: XOR<StudyMaterialUpdateWithoutChapterInput, StudyMaterialUncheckedUpdateWithoutChapterInput>
    create: XOR<StudyMaterialCreateWithoutChapterInput, StudyMaterialUncheckedCreateWithoutChapterInput>
    where?: StudyMaterialWhereInput
  }

  export type StudyMaterialUpdateToOneWithWhereWithoutChapterInput = {
    where?: StudyMaterialWhereInput
    data: XOR<StudyMaterialUpdateWithoutChapterInput, StudyMaterialUncheckedUpdateWithoutChapterInput>
  }

  export type StudyMaterialUpdateWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: NullableStringFieldUpdateOperationsInput | string | null
    video_queries?: StudyMaterialUpdatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyMaterialUncheckedUpdateWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    summary?: NullableJsonNullValueInput | InputJsonValue
    definitions?: NullableJsonNullValueInput | InputJsonValue
    flashcards?: NullableJsonNullValueInput | InputJsonValue
    mind_map?: NullableStringFieldUpdateOperationsInput | string | null
    video_queries?: StudyMaterialUpdatevideo_queriesInput | string[]
    curated_videos?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUpsertWithWhereUniqueWithoutChapterInput = {
    where: LearningSessionWhereUniqueInput
    update: XOR<LearningSessionUpdateWithoutChapterInput, LearningSessionUncheckedUpdateWithoutChapterInput>
    create: XOR<LearningSessionCreateWithoutChapterInput, LearningSessionUncheckedCreateWithoutChapterInput>
  }

  export type LearningSessionUpdateWithWhereUniqueWithoutChapterInput = {
    where: LearningSessionWhereUniqueInput
    data: XOR<LearningSessionUpdateWithoutChapterInput, LearningSessionUncheckedUpdateWithoutChapterInput>
  }

  export type LearningSessionUpdateManyWithWhereWithoutChapterInput = {
    where: LearningSessionScalarWhereInput
    data: XOR<LearningSessionUpdateManyMutationInput, LearningSessionUncheckedUpdateManyWithoutChapterInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutChapterInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutChapterInput, ConversationUncheckedUpdateWithoutChapterInput>
    create: XOR<ConversationCreateWithoutChapterInput, ConversationUncheckedCreateWithoutChapterInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutChapterInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutChapterInput, ConversationUncheckedUpdateWithoutChapterInput>
  }

  export type ConversationUpdateManyWithWhereWithoutChapterInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutChapterInput>
  }

  export type QuestionUpsertWithWhereUniqueWithoutChapterInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutChapterInput, QuestionUncheckedUpdateWithoutChapterInput>
    create: XOR<QuestionCreateWithoutChapterInput, QuestionUncheckedCreateWithoutChapterInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutChapterInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutChapterInput, QuestionUncheckedUpdateWithoutChapterInput>
  }

  export type QuestionUpdateManyWithWhereWithoutChapterInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutChapterInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    chapter_id?: BigIntFilter<"Question"> | bigint | number
    question_text?: StringFilter<"Question"> | string
    question_type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    difficulty?: StringFilter<"Question"> | string
    options?: JsonNullableFilter<"Question">
    correct_answer?: JsonFilter<"Question">
    explanation?: StringNullableFilter<"Question"> | string | null
    points?: IntFilter<"Question"> | number
    is_active?: BoolFilter<"Question"> | boolean
    created_at?: DateTimeFilter<"Question"> | Date | string
    updated_at?: DateTimeFilter<"Question"> | Date | string
  }

  export type ChapterCreateWithoutChunksInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutChunksInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutChunksInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutChunksInput, ChapterUncheckedCreateWithoutChunksInput>
  }

  export type ChapterChunkBoardCreateWithoutChunkInput = {
    board: BoardCreateNestedOneWithoutChunkBoardsInput
  }

  export type ChapterChunkBoardUncheckedCreateWithoutChunkInput = {
    board_id: string
  }

  export type ChapterChunkBoardCreateOrConnectWithoutChunkInput = {
    where: ChapterChunkBoardWhereUniqueInput
    create: XOR<ChapterChunkBoardCreateWithoutChunkInput, ChapterChunkBoardUncheckedCreateWithoutChunkInput>
  }

  export type ChapterChunkBoardCreateManyChunkInputEnvelope = {
    data: ChapterChunkBoardCreateManyChunkInput | ChapterChunkBoardCreateManyChunkInput[]
    skipDuplicates?: boolean
  }

  export type ChapterUpsertWithoutChunksInput = {
    update: XOR<ChapterUpdateWithoutChunksInput, ChapterUncheckedUpdateWithoutChunksInput>
    create: XOR<ChapterCreateWithoutChunksInput, ChapterUncheckedCreateWithoutChunksInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutChunksInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutChunksInput, ChapterUncheckedUpdateWithoutChunksInput>
  }

  export type ChapterUpdateWithoutChunksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutChunksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterChunkBoardUpsertWithWhereUniqueWithoutChunkInput = {
    where: ChapterChunkBoardWhereUniqueInput
    update: XOR<ChapterChunkBoardUpdateWithoutChunkInput, ChapterChunkBoardUncheckedUpdateWithoutChunkInput>
    create: XOR<ChapterChunkBoardCreateWithoutChunkInput, ChapterChunkBoardUncheckedCreateWithoutChunkInput>
  }

  export type ChapterChunkBoardUpdateWithWhereUniqueWithoutChunkInput = {
    where: ChapterChunkBoardWhereUniqueInput
    data: XOR<ChapterChunkBoardUpdateWithoutChunkInput, ChapterChunkBoardUncheckedUpdateWithoutChunkInput>
  }

  export type ChapterChunkBoardUpdateManyWithWhereWithoutChunkInput = {
    where: ChapterChunkBoardScalarWhereInput
    data: XOR<ChapterChunkBoardUpdateManyMutationInput, ChapterChunkBoardUncheckedUpdateManyWithoutChunkInput>
  }

  export type ChapterChunkCreateWithoutChunkBoardsInput = {
    id?: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
    chapter: ChapterCreateNestedOneWithoutChunksInput
  }

  export type ChapterChunkUncheckedCreateWithoutChunkBoardsInput = {
    id?: bigint | number
    chapter_id: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
  }

  export type ChapterChunkCreateOrConnectWithoutChunkBoardsInput = {
    where: ChapterChunkWhereUniqueInput
    create: XOR<ChapterChunkCreateWithoutChunkBoardsInput, ChapterChunkUncheckedCreateWithoutChunkBoardsInput>
  }

  export type BoardCreateWithoutChunkBoardsInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    country?: CountryCreateNestedOneWithoutBoardsInput
    institutions?: InstitutionCreateNestedManyWithoutBoardInput
    programs?: ProgramCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutChunkBoardsInput = {
    id: string
    name: string
    country_id?: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    institutions?: InstitutionUncheckedCreateNestedManyWithoutBoardInput
    programs?: ProgramUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutChunkBoardsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutChunkBoardsInput, BoardUncheckedCreateWithoutChunkBoardsInput>
  }

  export type ChapterChunkUpsertWithoutChunkBoardsInput = {
    update: XOR<ChapterChunkUpdateWithoutChunkBoardsInput, ChapterChunkUncheckedUpdateWithoutChunkBoardsInput>
    create: XOR<ChapterChunkCreateWithoutChunkBoardsInput, ChapterChunkUncheckedCreateWithoutChunkBoardsInput>
    where?: ChapterChunkWhereInput
  }

  export type ChapterChunkUpdateToOneWithWhereWithoutChunkBoardsInput = {
    where?: ChapterChunkWhereInput
    data: XOR<ChapterChunkUpdateWithoutChunkBoardsInput, ChapterChunkUncheckedUpdateWithoutChunkBoardsInput>
  }

  export type ChapterChunkUpdateWithoutChunkBoardsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutChunksNestedInput
  }

  export type ChapterChunkUncheckedUpdateWithoutChunkBoardsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUpsertWithoutChunkBoardsInput = {
    update: XOR<BoardUpdateWithoutChunkBoardsInput, BoardUncheckedUpdateWithoutChunkBoardsInput>
    create: XOR<BoardCreateWithoutChunkBoardsInput, BoardUncheckedCreateWithoutChunkBoardsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutChunkBoardsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutChunkBoardsInput, BoardUncheckedUpdateWithoutChunkBoardsInput>
  }

  export type BoardUpdateWithoutChunkBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutBoardsNestedInput
    institutions?: InstitutionUpdateManyWithoutBoardNestedInput
    programs?: ProgramUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutChunkBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country_id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUncheckedUpdateManyWithoutBoardNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type ChapterCreateWithoutPagesInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutPagesInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutPagesInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutPagesInput, ChapterUncheckedCreateWithoutPagesInput>
  }

  export type ChapterUpsertWithoutPagesInput = {
    update: XOR<ChapterUpdateWithoutPagesInput, ChapterUncheckedUpdateWithoutPagesInput>
    create: XOR<ChapterCreateWithoutPagesInput, ChapterUncheckedCreateWithoutPagesInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutPagesInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutPagesInput, ChapterUncheckedUpdateWithoutPagesInput>
  }

  export type ChapterUpdateWithoutPagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutPagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type userCreateWithoutQuizzesInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutQuizzesInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutQuizzesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutQuizzesInput, userUncheckedCreateWithoutQuizzesInput>
  }

  export type SubjectCreateWithoutQuizzesInput = {
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    program: ProgramCreateNestedOneWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    conversations?: ConversationCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutQuizzesInput = {
    id?: number
    program_id: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutQuizzesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutQuizzesInput, SubjectUncheckedCreateWithoutQuizzesInput>
  }

  export type ChapterCreateWithoutQuizzesInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutQuizzesInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutQuizzesInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: boolean | null
    points?: number
    explanation?: string | null
    feedback?: string | null
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: boolean | null
    points?: number
    explanation?: string | null
    feedback?: string | null
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type BattleCreateWithoutQuizInput = {
    id?: string
    code: string
    status?: $Enums.BattleStatus
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    creator: userCreateNestedOneWithoutCreated_battlesInput
    participants?: BattleParticipantCreateNestedManyWithoutBattleInput
  }

  export type BattleUncheckedCreateWithoutQuizInput = {
    id?: string
    code: string
    status?: $Enums.BattleStatus
    created_by: number
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    participants?: BattleParticipantUncheckedCreateNestedManyWithoutBattleInput
  }

  export type BattleCreateOrConnectWithoutQuizInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutQuizInput, BattleUncheckedCreateWithoutQuizInput>
  }

  export type BattleCreateManyQuizInputEnvelope = {
    data: BattleCreateManyQuizInput | BattleCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutQuizzesInput = {
    update: XOR<userUpdateWithoutQuizzesInput, userUncheckedUpdateWithoutQuizzesInput>
    create: XOR<userCreateWithoutQuizzesInput, userUncheckedCreateWithoutQuizzesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutQuizzesInput, userUncheckedUpdateWithoutQuizzesInput>
  }

  export type userUpdateWithoutQuizzesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubjectUpsertWithoutQuizzesInput = {
    update: XOR<SubjectUpdateWithoutQuizzesInput, SubjectUncheckedUpdateWithoutQuizzesInput>
    create: XOR<SubjectCreateWithoutQuizzesInput, SubjectUncheckedCreateWithoutQuizzesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutQuizzesInput, SubjectUncheckedUpdateWithoutQuizzesInput>
  }

  export type SubjectUpdateWithoutQuizzesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    program?: ProgramUpdateOneRequiredWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ChapterUpsertWithoutQuizzesInput = {
    update: XOR<ChapterUpdateWithoutQuizzesInput, ChapterUncheckedUpdateWithoutQuizzesInput>
    create: XOR<ChapterCreateWithoutQuizzesInput, ChapterUncheckedCreateWithoutQuizzesInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutQuizzesInput, ChapterUncheckedUpdateWithoutQuizzesInput>
  }

  export type ChapterUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    quiz_id?: StringFilter<"QuizQuestion"> | string
    question_text?: StringFilter<"QuizQuestion"> | string
    question_type?: EnumQuestionTypeFilter<"QuizQuestion"> | $Enums.QuestionType
    options?: JsonNullableFilter<"QuizQuestion">
    correct_answer?: JsonFilter<"QuizQuestion">
    user_answer?: JsonNullableFilter<"QuizQuestion">
    is_correct?: BoolNullableFilter<"QuizQuestion"> | boolean | null
    points?: IntFilter<"QuizQuestion"> | number
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    feedback?: StringNullableFilter<"QuizQuestion"> | string | null
  }

  export type BattleUpsertWithWhereUniqueWithoutQuizInput = {
    where: BattleWhereUniqueInput
    update: XOR<BattleUpdateWithoutQuizInput, BattleUncheckedUpdateWithoutQuizInput>
    create: XOR<BattleCreateWithoutQuizInput, BattleUncheckedCreateWithoutQuizInput>
  }

  export type BattleUpdateWithWhereUniqueWithoutQuizInput = {
    where: BattleWhereUniqueInput
    data: XOR<BattleUpdateWithoutQuizInput, BattleUncheckedUpdateWithoutQuizInput>
  }

  export type BattleUpdateManyWithWhereWithoutQuizInput = {
    where: BattleScalarWhereInput
    data: XOR<BattleUpdateManyMutationInput, BattleUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutQuizzesInput
    subject: SubjectCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    battles?: BattleCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    user_id: number
    subject_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    battles?: BattleUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQuizzesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    battles?: BattleUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    battles?: BattleUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type ChapterCreateWithoutQuestionsInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutQuestionsInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutQuestionsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutQuestionsInput, ChapterUncheckedCreateWithoutQuestionsInput>
  }

  export type ChapterUpsertWithoutQuestionsInput = {
    update: XOR<ChapterUpdateWithoutQuestionsInput, ChapterUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ChapterCreateWithoutQuestionsInput, ChapterUncheckedCreateWithoutQuestionsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutQuestionsInput, ChapterUncheckedUpdateWithoutQuestionsInput>
  }

  export type ChapterUpdateWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type userCreateWithoutPointsInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPointsInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPointsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPointsInput, userUncheckedCreateWithoutPointsInput>
  }

  export type userUpsertWithoutPointsInput = {
    update: XOR<userUpdateWithoutPointsInput, userUncheckedUpdateWithoutPointsInput>
    create: XOR<userCreateWithoutPointsInput, userUncheckedCreateWithoutPointsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPointsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPointsInput, userUncheckedUpdateWithoutPointsInput>
  }

  export type userUpdateWithoutPointsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPointsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChapterCreateWithoutStudy_materialsInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutStudy_materialsInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutStudy_materialsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutStudy_materialsInput, ChapterUncheckedCreateWithoutStudy_materialsInput>
  }

  export type ChapterUpsertWithoutStudy_materialsInput = {
    update: XOR<ChapterUpdateWithoutStudy_materialsInput, ChapterUncheckedUpdateWithoutStudy_materialsInput>
    create: XOR<ChapterCreateWithoutStudy_materialsInput, ChapterUncheckedCreateWithoutStudy_materialsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutStudy_materialsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutStudy_materialsInput, ChapterUncheckedUpdateWithoutStudy_materialsInput>
  }

  export type ChapterUpdateWithoutStudy_materialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutStudy_materialsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ProgramCreateWithoutExamsInput = {
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    board: BoardCreateNestedOneWithoutProgramsInput
    institution?: InstitutionCreateNestedOneWithoutProgramsInput
    subjects?: SubjectCreateNestedManyWithoutProgramInput
    profiles?: ProfileCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutExamsInput = {
    id?: number
    board_id: string
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutProgramInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutExamsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutExamsInput, ProgramUncheckedCreateWithoutExamsInput>
  }

  export type ProgramUpsertWithoutExamsInput = {
    update: XOR<ProgramUpdateWithoutExamsInput, ProgramUncheckedUpdateWithoutExamsInput>
    create: XOR<ProgramCreateWithoutExamsInput, ProgramUncheckedCreateWithoutExamsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutExamsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutExamsInput, ProgramUncheckedUpdateWithoutExamsInput>
  }

  export type ProgramUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutProgramsNestedInput
    institution?: InstitutionUpdateOneWithoutProgramsNestedInput
    subjects?: SubjectUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    id?: string
    earned_at?: Date | string
    user: userCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    user_id: number
    earned_at?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type userCreateWithoutBadgesInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBadgesInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBadgesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBadgesInput, userUncheckedCreateWithoutBadgesInput>
  }

  export type StreakBadgeCreateWithoutUser_badgesInput = {
    id?: string
    name: string
    icon: string
    min_streak: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StreakBadgeUncheckedCreateWithoutUser_badgesInput = {
    id?: string
    name: string
    icon: string
    min_streak: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StreakBadgeCreateOrConnectWithoutUser_badgesInput = {
    where: StreakBadgeWhereUniqueInput
    create: XOR<StreakBadgeCreateWithoutUser_badgesInput, StreakBadgeUncheckedCreateWithoutUser_badgesInput>
  }

  export type userUpsertWithoutBadgesInput = {
    update: XOR<userUpdateWithoutBadgesInput, userUncheckedUpdateWithoutBadgesInput>
    create: XOR<userCreateWithoutBadgesInput, userUncheckedCreateWithoutBadgesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBadgesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBadgesInput, userUncheckedUpdateWithoutBadgesInput>
  }

  export type userUpdateWithoutBadgesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBadgesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StreakBadgeUpsertWithoutUser_badgesInput = {
    update: XOR<StreakBadgeUpdateWithoutUser_badgesInput, StreakBadgeUncheckedUpdateWithoutUser_badgesInput>
    create: XOR<StreakBadgeCreateWithoutUser_badgesInput, StreakBadgeUncheckedCreateWithoutUser_badgesInput>
    where?: StreakBadgeWhereInput
  }

  export type StreakBadgeUpdateToOneWithWhereWithoutUser_badgesInput = {
    where?: StreakBadgeWhereInput
    data: XOR<StreakBadgeUpdateWithoutUser_badgesInput, StreakBadgeUncheckedUpdateWithoutUser_badgesInput>
  }

  export type StreakBadgeUpdateWithoutUser_badgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    min_streak?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakBadgeUncheckedUpdateWithoutUser_badgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    min_streak?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateWithoutLearning_sessionsInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutLearning_sessionsInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutLearning_sessionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutLearning_sessionsInput, userUncheckedCreateWithoutLearning_sessionsInput>
  }

  export type ChapterCreateWithoutLearning_sessionsInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    subject: SubjectCreateNestedOneWithoutChaptersInput
    chunks?: ChapterChunkCreateNestedManyWithoutChapterInput
    pages?: ChapterPageCreateNestedManyWithoutChapterInput
    quizzes?: QuizCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialCreateNestedOneWithoutChapterInput
    conversations?: ConversationCreateNestedManyWithoutChapterInput
    questions?: QuestionCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutLearning_sessionsInput = {
    id?: bigint | number
    subject_id: number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
    chunks?: ChapterChunkUncheckedCreateNestedManyWithoutChapterInput
    pages?: ChapterPageUncheckedCreateNestedManyWithoutChapterInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutChapterInput
    study_materials?: StudyMaterialUncheckedCreateNestedOneWithoutChapterInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutChapterInput
    questions?: QuestionUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutLearning_sessionsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutLearning_sessionsInput, ChapterUncheckedCreateWithoutLearning_sessionsInput>
  }

  export type userUpsertWithoutLearning_sessionsInput = {
    update: XOR<userUpdateWithoutLearning_sessionsInput, userUncheckedUpdateWithoutLearning_sessionsInput>
    create: XOR<userCreateWithoutLearning_sessionsInput, userUncheckedCreateWithoutLearning_sessionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutLearning_sessionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutLearning_sessionsInput, userUncheckedUpdateWithoutLearning_sessionsInput>
  }

  export type userUpdateWithoutLearning_sessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutLearning_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChapterUpsertWithoutLearning_sessionsInput = {
    update: XOR<ChapterUpdateWithoutLearning_sessionsInput, ChapterUncheckedUpdateWithoutLearning_sessionsInput>
    create: XOR<ChapterCreateWithoutLearning_sessionsInput, ChapterUncheckedCreateWithoutLearning_sessionsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutLearning_sessionsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutLearning_sessionsInput, ChapterUncheckedUpdateWithoutLearning_sessionsInput>
  }

  export type ChapterUpdateWithoutLearning_sessionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutLearning_sessionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type QuizCreateWithoutBattlesInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutQuizzesInput
    subject: SubjectCreateNestedOneWithoutQuizzesInput
    chapter?: ChapterCreateNestedOneWithoutQuizzesInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutBattlesInput = {
    id?: string
    user_id: number
    subject_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutBattlesInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutBattlesInput, QuizUncheckedCreateWithoutBattlesInput>
  }

  export type userCreateWithoutCreated_battlesInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreated_battlesInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreated_battlesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreated_battlesInput, userUncheckedCreateWithoutCreated_battlesInput>
  }

  export type BattleParticipantCreateWithoutBattleInput = {
    id?: string
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
    user: userCreateNestedOneWithoutBattle_participationsInput
  }

  export type BattleParticipantUncheckedCreateWithoutBattleInput = {
    id?: string
    user_id: number
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
  }

  export type BattleParticipantCreateOrConnectWithoutBattleInput = {
    where: BattleParticipantWhereUniqueInput
    create: XOR<BattleParticipantCreateWithoutBattleInput, BattleParticipantUncheckedCreateWithoutBattleInput>
  }

  export type BattleParticipantCreateManyBattleInputEnvelope = {
    data: BattleParticipantCreateManyBattleInput | BattleParticipantCreateManyBattleInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutBattlesInput = {
    update: XOR<QuizUpdateWithoutBattlesInput, QuizUncheckedUpdateWithoutBattlesInput>
    create: XOR<QuizCreateWithoutBattlesInput, QuizUncheckedCreateWithoutBattlesInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutBattlesInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutBattlesInput, QuizUncheckedUpdateWithoutBattlesInput>
  }

  export type QuizUpdateWithoutBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQuizzesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutBattlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type userUpsertWithoutCreated_battlesInput = {
    update: XOR<userUpdateWithoutCreated_battlesInput, userUncheckedUpdateWithoutCreated_battlesInput>
    create: XOR<userCreateWithoutCreated_battlesInput, userUncheckedCreateWithoutCreated_battlesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreated_battlesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreated_battlesInput, userUncheckedUpdateWithoutCreated_battlesInput>
  }

  export type userUpdateWithoutCreated_battlesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreated_battlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BattleParticipantUpsertWithWhereUniqueWithoutBattleInput = {
    where: BattleParticipantWhereUniqueInput
    update: XOR<BattleParticipantUpdateWithoutBattleInput, BattleParticipantUncheckedUpdateWithoutBattleInput>
    create: XOR<BattleParticipantCreateWithoutBattleInput, BattleParticipantUncheckedCreateWithoutBattleInput>
  }

  export type BattleParticipantUpdateWithWhereUniqueWithoutBattleInput = {
    where: BattleParticipantWhereUniqueInput
    data: XOR<BattleParticipantUpdateWithoutBattleInput, BattleParticipantUncheckedUpdateWithoutBattleInput>
  }

  export type BattleParticipantUpdateManyWithWhereWithoutBattleInput = {
    where: BattleParticipantScalarWhereInput
    data: XOR<BattleParticipantUpdateManyMutationInput, BattleParticipantUncheckedUpdateManyWithoutBattleInput>
  }

  export type BattleCreateWithoutParticipantsInput = {
    id?: string
    code: string
    status?: $Enums.BattleStatus
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    quiz: QuizCreateNestedOneWithoutBattlesInput
    creator: userCreateNestedOneWithoutCreated_battlesInput
  }

  export type BattleUncheckedCreateWithoutParticipantsInput = {
    id?: string
    quiz_id: string
    code: string
    status?: $Enums.BattleStatus
    created_by: number
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BattleCreateOrConnectWithoutParticipantsInput = {
    where: BattleWhereUniqueInput
    create: XOR<BattleCreateWithoutParticipantsInput, BattleUncheckedCreateWithoutParticipantsInput>
  }

  export type userCreateWithoutBattle_participationsInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    textbooks_created?: TextbookCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBattle_participationsInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    textbooks_created?: TextbookUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBattle_participationsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBattle_participationsInput, userUncheckedCreateWithoutBattle_participationsInput>
  }

  export type BattleUpsertWithoutParticipantsInput = {
    update: XOR<BattleUpdateWithoutParticipantsInput, BattleUncheckedUpdateWithoutParticipantsInput>
    create: XOR<BattleCreateWithoutParticipantsInput, BattleUncheckedCreateWithoutParticipantsInput>
    where?: BattleWhereInput
  }

  export type BattleUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: BattleWhereInput
    data: XOR<BattleUpdateWithoutParticipantsInput, BattleUncheckedUpdateWithoutParticipantsInput>
  }

  export type BattleUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    quiz?: QuizUpdateOneRequiredWithoutBattlesNestedInput
    creator?: userUpdateOneRequiredWithoutCreated_battlesNestedInput
  }

  export type BattleUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type userUpsertWithoutBattle_participationsInput = {
    update: XOR<userUpdateWithoutBattle_participationsInput, userUncheckedUpdateWithoutBattle_participationsInput>
    create: XOR<userCreateWithoutBattle_participationsInput, userUncheckedCreateWithoutBattle_participationsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBattle_participationsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBattle_participationsInput, userUncheckedUpdateWithoutBattle_participationsInput>
  }

  export type userUpdateWithoutBattle_participationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    textbooks_created?: TextbookUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBattle_participationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    textbooks_created?: TextbookUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SyllabusUnitCreateWithoutSyllabusInput = {
    title: string
    order: number
    description?: string | null
    chapters?: SyllabusChapterCreateNestedManyWithoutUnitInput
  }

  export type SyllabusUnitUncheckedCreateWithoutSyllabusInput = {
    id?: number
    title: string
    order: number
    description?: string | null
    chapters?: SyllabusChapterUncheckedCreateNestedManyWithoutUnitInput
  }

  export type SyllabusUnitCreateOrConnectWithoutSyllabusInput = {
    where: SyllabusUnitWhereUniqueInput
    create: XOR<SyllabusUnitCreateWithoutSyllabusInput, SyllabusUnitUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusUnitCreateManySyllabusInputEnvelope = {
    data: SyllabusUnitCreateManySyllabusInput | SyllabusUnitCreateManySyllabusInput[]
    skipDuplicates?: boolean
  }

  export type TextbookCreateWithoutSyllabusInput = {
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: userCreateNestedOneWithoutTextbooks_createdInput
    units?: TextbookUnitCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUncheckedCreateWithoutSyllabusInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
    units?: TextbookUnitUncheckedCreateNestedManyWithoutTextbookInput
    generation_jobs?: TextbookGenerationJobUncheckedCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutTextbookInput
  }

  export type TextbookCreateOrConnectWithoutSyllabusInput = {
    where: TextbookWhereUniqueInput
    create: XOR<TextbookCreateWithoutSyllabusInput, TextbookUncheckedCreateWithoutSyllabusInput>
  }

  export type TextbookCreateManySyllabusInputEnvelope = {
    data: TextbookCreateManySyllabusInput | TextbookCreateManySyllabusInput[]
    skipDuplicates?: boolean
  }

  export type SyllabusUnitUpsertWithWhereUniqueWithoutSyllabusInput = {
    where: SyllabusUnitWhereUniqueInput
    update: XOR<SyllabusUnitUpdateWithoutSyllabusInput, SyllabusUnitUncheckedUpdateWithoutSyllabusInput>
    create: XOR<SyllabusUnitCreateWithoutSyllabusInput, SyllabusUnitUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusUnitUpdateWithWhereUniqueWithoutSyllabusInput = {
    where: SyllabusUnitWhereUniqueInput
    data: XOR<SyllabusUnitUpdateWithoutSyllabusInput, SyllabusUnitUncheckedUpdateWithoutSyllabusInput>
  }

  export type SyllabusUnitUpdateManyWithWhereWithoutSyllabusInput = {
    where: SyllabusUnitScalarWhereInput
    data: XOR<SyllabusUnitUpdateManyMutationInput, SyllabusUnitUncheckedUpdateManyWithoutSyllabusInput>
  }

  export type SyllabusUnitScalarWhereInput = {
    AND?: SyllabusUnitScalarWhereInput | SyllabusUnitScalarWhereInput[]
    OR?: SyllabusUnitScalarWhereInput[]
    NOT?: SyllabusUnitScalarWhereInput | SyllabusUnitScalarWhereInput[]
    id?: IntFilter<"SyllabusUnit"> | number
    syllabus_id?: IntFilter<"SyllabusUnit"> | number
    title?: StringFilter<"SyllabusUnit"> | string
    order?: IntFilter<"SyllabusUnit"> | number
    description?: StringNullableFilter<"SyllabusUnit"> | string | null
  }

  export type TextbookUpsertWithWhereUniqueWithoutSyllabusInput = {
    where: TextbookWhereUniqueInput
    update: XOR<TextbookUpdateWithoutSyllabusInput, TextbookUncheckedUpdateWithoutSyllabusInput>
    create: XOR<TextbookCreateWithoutSyllabusInput, TextbookUncheckedCreateWithoutSyllabusInput>
  }

  export type TextbookUpdateWithWhereUniqueWithoutSyllabusInput = {
    where: TextbookWhereUniqueInput
    data: XOR<TextbookUpdateWithoutSyllabusInput, TextbookUncheckedUpdateWithoutSyllabusInput>
  }

  export type TextbookUpdateManyWithWhereWithoutSyllabusInput = {
    where: TextbookScalarWhereInput
    data: XOR<TextbookUpdateManyMutationInput, TextbookUncheckedUpdateManyWithoutSyllabusInput>
  }

  export type SyllabusCreateWithoutUnitsInput = {
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
    textbooks?: TextbookCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateWithoutUnitsInput = {
    id?: number
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
    textbooks?: TextbookUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusCreateOrConnectWithoutUnitsInput = {
    where: SyllabusWhereUniqueInput
    create: XOR<SyllabusCreateWithoutUnitsInput, SyllabusUncheckedCreateWithoutUnitsInput>
  }

  export type SyllabusChapterCreateWithoutUnitInput = {
    chapter_number: string
    title: string
    order: number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUncheckedCreateWithoutUnitInput = {
    id?: number
    chapter_number: string
    title: string
    order: number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterCreateOrConnectWithoutUnitInput = {
    where: SyllabusChapterWhereUniqueInput
    create: XOR<SyllabusChapterCreateWithoutUnitInput, SyllabusChapterUncheckedCreateWithoutUnitInput>
  }

  export type SyllabusChapterCreateManyUnitInputEnvelope = {
    data: SyllabusChapterCreateManyUnitInput | SyllabusChapterCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type SyllabusUpsertWithoutUnitsInput = {
    update: XOR<SyllabusUpdateWithoutUnitsInput, SyllabusUncheckedUpdateWithoutUnitsInput>
    create: XOR<SyllabusCreateWithoutUnitsInput, SyllabusUncheckedCreateWithoutUnitsInput>
    where?: SyllabusWhereInput
  }

  export type SyllabusUpdateToOneWithWhereWithoutUnitsInput = {
    where?: SyllabusWhereInput
    data: XOR<SyllabusUpdateWithoutUnitsInput, SyllabusUncheckedUpdateWithoutUnitsInput>
  }

  export type SyllabusUpdateWithoutUnitsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    textbooks?: TextbookUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    textbooks?: TextbookUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusChapterUpsertWithWhereUniqueWithoutUnitInput = {
    where: SyllabusChapterWhereUniqueInput
    update: XOR<SyllabusChapterUpdateWithoutUnitInput, SyllabusChapterUncheckedUpdateWithoutUnitInput>
    create: XOR<SyllabusChapterCreateWithoutUnitInput, SyllabusChapterUncheckedCreateWithoutUnitInput>
  }

  export type SyllabusChapterUpdateWithWhereUniqueWithoutUnitInput = {
    where: SyllabusChapterWhereUniqueInput
    data: XOR<SyllabusChapterUpdateWithoutUnitInput, SyllabusChapterUncheckedUpdateWithoutUnitInput>
  }

  export type SyllabusChapterUpdateManyWithWhereWithoutUnitInput = {
    where: SyllabusChapterScalarWhereInput
    data: XOR<SyllabusChapterUpdateManyMutationInput, SyllabusChapterUncheckedUpdateManyWithoutUnitInput>
  }

  export type SyllabusChapterScalarWhereInput = {
    AND?: SyllabusChapterScalarWhereInput | SyllabusChapterScalarWhereInput[]
    OR?: SyllabusChapterScalarWhereInput[]
    NOT?: SyllabusChapterScalarWhereInput | SyllabusChapterScalarWhereInput[]
    id?: IntFilter<"SyllabusChapter"> | number
    unit_id?: IntFilter<"SyllabusChapter"> | number
    chapter_number?: StringFilter<"SyllabusChapter"> | string
    title?: StringFilter<"SyllabusChapter"> | string
    order?: IntFilter<"SyllabusChapter"> | number
    subtopics?: JsonNullableFilter<"SyllabusChapter">
  }

  export type SyllabusUnitCreateWithoutChaptersInput = {
    title: string
    order: number
    description?: string | null
    syllabus: SyllabusCreateNestedOneWithoutUnitsInput
  }

  export type SyllabusUnitUncheckedCreateWithoutChaptersInput = {
    id?: number
    syllabus_id: number
    title: string
    order: number
    description?: string | null
  }

  export type SyllabusUnitCreateOrConnectWithoutChaptersInput = {
    where: SyllabusUnitWhereUniqueInput
    create: XOR<SyllabusUnitCreateWithoutChaptersInput, SyllabusUnitUncheckedCreateWithoutChaptersInput>
  }

  export type SyllabusUnitUpsertWithoutChaptersInput = {
    update: XOR<SyllabusUnitUpdateWithoutChaptersInput, SyllabusUnitUncheckedUpdateWithoutChaptersInput>
    create: XOR<SyllabusUnitCreateWithoutChaptersInput, SyllabusUnitUncheckedCreateWithoutChaptersInput>
    where?: SyllabusUnitWhereInput
  }

  export type SyllabusUnitUpdateToOneWithWhereWithoutChaptersInput = {
    where?: SyllabusUnitWhereInput
    data: XOR<SyllabusUnitUpdateWithoutChaptersInput, SyllabusUnitUncheckedUpdateWithoutChaptersInput>
  }

  export type SyllabusUnitUpdateWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus?: SyllabusUpdateOneRequiredWithoutUnitsNestedInput
  }

  export type SyllabusUnitUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    syllabus_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyllabusCreateWithoutTextbooksInput = {
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
    units?: SyllabusUnitCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateWithoutTextbooksInput = {
    id?: number
    title: string
    description?: string | null
    board?: string
    class_level: string
    stream?: string | null
    subject: string
    academic_year?: string | null
    raw_text?: string | null
    status?: $Enums.SyllabusStatus
    created_at?: Date | string
    updated_at?: Date | string
    units?: SyllabusUnitUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusCreateOrConnectWithoutTextbooksInput = {
    where: SyllabusWhereUniqueInput
    create: XOR<SyllabusCreateWithoutTextbooksInput, SyllabusUncheckedCreateWithoutTextbooksInput>
  }

  export type userCreateWithoutTextbooks_createdInput = {
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    files?: FileListCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionCreateNestedOneWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    quizzes?: QuizCreateNestedManyWithoutUserInput
    points?: UserPointsCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionCreateNestedManyWithoutUserInput
    created_battles?: BattleCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantCreateNestedManyWithoutUserInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTextbooks_createdInput = {
    id?: number
    username: string
    password_hash?: string | null
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    categories?: CategoryListUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    files?: FileListUncheckedCreateNestedManyWithoutUserInput
    usage_tracking?: UsageTrackingUncheckedCreateNestedManyWithoutUserInput
    subscription?: UserSubscriptionUncheckedCreateNestedOneWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutUserInput
    points?: UserPointsUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    learning_sessions?: LearningSessionUncheckedCreateNestedManyWithoutUserInput
    created_battles?: BattleUncheckedCreateNestedManyWithoutCreatorInput
    battle_participations?: BattleParticipantUncheckedCreateNestedManyWithoutUserInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTextbooks_createdInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTextbooks_createdInput, userUncheckedCreateWithoutTextbooks_createdInput>
  }

  export type TextbookUnitCreateWithoutTextbookInput = {
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    chapters?: TextbookChapterCreateNestedManyWithoutUnitInput
  }

  export type TextbookUnitUncheckedCreateWithoutTextbookInput = {
    id?: number
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    chapters?: TextbookChapterUncheckedCreateNestedManyWithoutUnitInput
  }

  export type TextbookUnitCreateOrConnectWithoutTextbookInput = {
    where: TextbookUnitWhereUniqueInput
    create: XOR<TextbookUnitCreateWithoutTextbookInput, TextbookUnitUncheckedCreateWithoutTextbookInput>
  }

  export type TextbookUnitCreateManyTextbookInputEnvelope = {
    data: TextbookUnitCreateManyTextbookInput | TextbookUnitCreateManyTextbookInput[]
    skipDuplicates?: boolean
  }

  export type TextbookGenerationJobCreateWithoutTextbookInput = {
    job_type: $Enums.TextbookGenerationJobType
    status?: $Enums.TextbookJobStatus
    target_id?: number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    progress?: number
    started_at?: Date | string | null
    completed_at?: Date | string | null
    attempts?: number
    max_attempts?: number
    created_at?: Date | string
  }

  export type TextbookGenerationJobUncheckedCreateWithoutTextbookInput = {
    id?: number
    job_type: $Enums.TextbookGenerationJobType
    status?: $Enums.TextbookJobStatus
    target_id?: number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    progress?: number
    started_at?: Date | string | null
    completed_at?: Date | string | null
    attempts?: number
    max_attempts?: number
    created_at?: Date | string
  }

  export type TextbookGenerationJobCreateOrConnectWithoutTextbookInput = {
    where: TextbookGenerationJobWhereUniqueInput
    create: XOR<TextbookGenerationJobCreateWithoutTextbookInput, TextbookGenerationJobUncheckedCreateWithoutTextbookInput>
  }

  export type TextbookGenerationJobCreateManyTextbookInputEnvelope = {
    data: TextbookGenerationJobCreateManyTextbookInput | TextbookGenerationJobCreateManyTextbookInput[]
    skipDuplicates?: boolean
  }

  export type UserEnrollmentCreateWithoutTextbookInput = {
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutEnrollmentsInput
  }

  export type UserEnrollmentUncheckedCreateWithoutTextbookInput = {
    id?: number
    user_id: number
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
  }

  export type UserEnrollmentCreateOrConnectWithoutTextbookInput = {
    where: UserEnrollmentWhereUniqueInput
    create: XOR<UserEnrollmentCreateWithoutTextbookInput, UserEnrollmentUncheckedCreateWithoutTextbookInput>
  }

  export type UserEnrollmentCreateManyTextbookInputEnvelope = {
    data: UserEnrollmentCreateManyTextbookInput | UserEnrollmentCreateManyTextbookInput[]
    skipDuplicates?: boolean
  }

  export type SyllabusUpsertWithoutTextbooksInput = {
    update: XOR<SyllabusUpdateWithoutTextbooksInput, SyllabusUncheckedUpdateWithoutTextbooksInput>
    create: XOR<SyllabusCreateWithoutTextbooksInput, SyllabusUncheckedCreateWithoutTextbooksInput>
    where?: SyllabusWhereInput
  }

  export type SyllabusUpdateToOneWithWhereWithoutTextbooksInput = {
    where?: SyllabusWhereInput
    data: XOR<SyllabusUpdateWithoutTextbooksInput, SyllabusUncheckedUpdateWithoutTextbooksInput>
  }

  export type SyllabusUpdateWithoutTextbooksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: SyllabusUnitUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateWithoutTextbooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    board?: StringFieldUpdateOperationsInput | string
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    raw_text?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSyllabusStatusFieldUpdateOperationsInput | $Enums.SyllabusStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: SyllabusUnitUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type userUpsertWithoutTextbooks_createdInput = {
    update: XOR<userUpdateWithoutTextbooks_createdInput, userUncheckedUpdateWithoutTextbooks_createdInput>
    create: XOR<userCreateWithoutTextbooks_createdInput, userUncheckedCreateWithoutTextbooks_createdInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTextbooks_createdInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTextbooks_createdInput, userUncheckedUpdateWithoutTextbooks_createdInput>
  }

  export type userUpdateWithoutTextbooks_createdInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    files?: FileListUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUpdateOneWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    quizzes?: QuizUpdateManyWithoutUserNestedInput
    points?: UserPointsUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutUserNestedInput
    created_battles?: BattleUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUpdateManyWithoutUserNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTextbooks_createdInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryListUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    files?: FileListUncheckedUpdateManyWithoutUserNestedInput
    usage_tracking?: UsageTrackingUncheckedUpdateManyWithoutUserNestedInput
    subscription?: UserSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutUserNestedInput
    points?: UserPointsUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutUserNestedInput
    created_battles?: BattleUncheckedUpdateManyWithoutCreatorNestedInput
    battle_participations?: BattleParticipantUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TextbookUnitUpsertWithWhereUniqueWithoutTextbookInput = {
    where: TextbookUnitWhereUniqueInput
    update: XOR<TextbookUnitUpdateWithoutTextbookInput, TextbookUnitUncheckedUpdateWithoutTextbookInput>
    create: XOR<TextbookUnitCreateWithoutTextbookInput, TextbookUnitUncheckedCreateWithoutTextbookInput>
  }

  export type TextbookUnitUpdateWithWhereUniqueWithoutTextbookInput = {
    where: TextbookUnitWhereUniqueInput
    data: XOR<TextbookUnitUpdateWithoutTextbookInput, TextbookUnitUncheckedUpdateWithoutTextbookInput>
  }

  export type TextbookUnitUpdateManyWithWhereWithoutTextbookInput = {
    where: TextbookUnitScalarWhereInput
    data: XOR<TextbookUnitUpdateManyMutationInput, TextbookUnitUncheckedUpdateManyWithoutTextbookInput>
  }

  export type TextbookUnitScalarWhereInput = {
    AND?: TextbookUnitScalarWhereInput | TextbookUnitScalarWhereInput[]
    OR?: TextbookUnitScalarWhereInput[]
    NOT?: TextbookUnitScalarWhereInput | TextbookUnitScalarWhereInput[]
    id?: IntFilter<"TextbookUnit"> | number
    textbook_id?: IntFilter<"TextbookUnit"> | number
    order?: IntFilter<"TextbookUnit"> | number
    title?: StringFilter<"TextbookUnit"> | string
    description?: StringNullableFilter<"TextbookUnit"> | string | null
    created_at?: DateTimeFilter<"TextbookUnit"> | Date | string
    updated_at?: DateTimeFilter<"TextbookUnit"> | Date | string
  }

  export type TextbookGenerationJobUpsertWithWhereUniqueWithoutTextbookInput = {
    where: TextbookGenerationJobWhereUniqueInput
    update: XOR<TextbookGenerationJobUpdateWithoutTextbookInput, TextbookGenerationJobUncheckedUpdateWithoutTextbookInput>
    create: XOR<TextbookGenerationJobCreateWithoutTextbookInput, TextbookGenerationJobUncheckedCreateWithoutTextbookInput>
  }

  export type TextbookGenerationJobUpdateWithWhereUniqueWithoutTextbookInput = {
    where: TextbookGenerationJobWhereUniqueInput
    data: XOR<TextbookGenerationJobUpdateWithoutTextbookInput, TextbookGenerationJobUncheckedUpdateWithoutTextbookInput>
  }

  export type TextbookGenerationJobUpdateManyWithWhereWithoutTextbookInput = {
    where: TextbookGenerationJobScalarWhereInput
    data: XOR<TextbookGenerationJobUpdateManyMutationInput, TextbookGenerationJobUncheckedUpdateManyWithoutTextbookInput>
  }

  export type TextbookGenerationJobScalarWhereInput = {
    AND?: TextbookGenerationJobScalarWhereInput | TextbookGenerationJobScalarWhereInput[]
    OR?: TextbookGenerationJobScalarWhereInput[]
    NOT?: TextbookGenerationJobScalarWhereInput | TextbookGenerationJobScalarWhereInput[]
    id?: IntFilter<"TextbookGenerationJob"> | number
    textbook_id?: IntFilter<"TextbookGenerationJob"> | number
    job_type?: EnumTextbookGenerationJobTypeFilter<"TextbookGenerationJob"> | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFilter<"TextbookGenerationJob"> | $Enums.TextbookJobStatus
    target_id?: IntNullableFilter<"TextbookGenerationJob"> | number | null
    input_data?: JsonNullableFilter<"TextbookGenerationJob">
    output_data?: JsonNullableFilter<"TextbookGenerationJob">
    error_message?: StringNullableFilter<"TextbookGenerationJob"> | string | null
    progress?: IntFilter<"TextbookGenerationJob"> | number
    started_at?: DateTimeNullableFilter<"TextbookGenerationJob"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"TextbookGenerationJob"> | Date | string | null
    attempts?: IntFilter<"TextbookGenerationJob"> | number
    max_attempts?: IntFilter<"TextbookGenerationJob"> | number
    created_at?: DateTimeFilter<"TextbookGenerationJob"> | Date | string
  }

  export type UserEnrollmentUpsertWithWhereUniqueWithoutTextbookInput = {
    where: UserEnrollmentWhereUniqueInput
    update: XOR<UserEnrollmentUpdateWithoutTextbookInput, UserEnrollmentUncheckedUpdateWithoutTextbookInput>
    create: XOR<UserEnrollmentCreateWithoutTextbookInput, UserEnrollmentUncheckedCreateWithoutTextbookInput>
  }

  export type UserEnrollmentUpdateWithWhereUniqueWithoutTextbookInput = {
    where: UserEnrollmentWhereUniqueInput
    data: XOR<UserEnrollmentUpdateWithoutTextbookInput, UserEnrollmentUncheckedUpdateWithoutTextbookInput>
  }

  export type UserEnrollmentUpdateManyWithWhereWithoutTextbookInput = {
    where: UserEnrollmentScalarWhereInput
    data: XOR<UserEnrollmentUpdateManyMutationInput, UserEnrollmentUncheckedUpdateManyWithoutTextbookInput>
  }

  export type TextbookCreateWithoutUnitsInput = {
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    syllabus?: SyllabusCreateNestedOneWithoutTextbooksInput
    creator: userCreateNestedOneWithoutTextbooks_createdInput
    generation_jobs?: TextbookGenerationJobCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUncheckedCreateWithoutUnitsInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
    generation_jobs?: TextbookGenerationJobUncheckedCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutTextbookInput
  }

  export type TextbookCreateOrConnectWithoutUnitsInput = {
    where: TextbookWhereUniqueInput
    create: XOR<TextbookCreateWithoutUnitsInput, TextbookUncheckedCreateWithoutUnitsInput>
  }

  export type TextbookChapterCreateWithoutUnitInput = {
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: TextbookImageCreateNestedManyWithoutChapterInput
  }

  export type TextbookChapterUncheckedCreateWithoutUnitInput = {
    id?: number
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: TextbookImageUncheckedCreateNestedManyWithoutChapterInput
  }

  export type TextbookChapterCreateOrConnectWithoutUnitInput = {
    where: TextbookChapterWhereUniqueInput
    create: XOR<TextbookChapterCreateWithoutUnitInput, TextbookChapterUncheckedCreateWithoutUnitInput>
  }

  export type TextbookChapterCreateManyUnitInputEnvelope = {
    data: TextbookChapterCreateManyUnitInput | TextbookChapterCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type TextbookUpsertWithoutUnitsInput = {
    update: XOR<TextbookUpdateWithoutUnitsInput, TextbookUncheckedUpdateWithoutUnitsInput>
    create: XOR<TextbookCreateWithoutUnitsInput, TextbookUncheckedCreateWithoutUnitsInput>
    where?: TextbookWhereInput
  }

  export type TextbookUpdateToOneWithWhereWithoutUnitsInput = {
    where?: TextbookWhereInput
    data: XOR<TextbookUpdateWithoutUnitsInput, TextbookUncheckedUpdateWithoutUnitsInput>
  }

  export type TextbookUpdateWithoutUnitsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    syllabus?: SyllabusUpdateOneWithoutTextbooksNestedInput
    creator?: userUpdateOneRequiredWithoutTextbooks_createdNestedInput
    generation_jobs?: TextbookGenerationJobUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
    generation_jobs?: TextbookGenerationJobUncheckedUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookChapterUpsertWithWhereUniqueWithoutUnitInput = {
    where: TextbookChapterWhereUniqueInput
    update: XOR<TextbookChapterUpdateWithoutUnitInput, TextbookChapterUncheckedUpdateWithoutUnitInput>
    create: XOR<TextbookChapterCreateWithoutUnitInput, TextbookChapterUncheckedCreateWithoutUnitInput>
  }

  export type TextbookChapterUpdateWithWhereUniqueWithoutUnitInput = {
    where: TextbookChapterWhereUniqueInput
    data: XOR<TextbookChapterUpdateWithoutUnitInput, TextbookChapterUncheckedUpdateWithoutUnitInput>
  }

  export type TextbookChapterUpdateManyWithWhereWithoutUnitInput = {
    where: TextbookChapterScalarWhereInput
    data: XOR<TextbookChapterUpdateManyMutationInput, TextbookChapterUncheckedUpdateManyWithoutUnitInput>
  }

  export type TextbookChapterScalarWhereInput = {
    AND?: TextbookChapterScalarWhereInput | TextbookChapterScalarWhereInput[]
    OR?: TextbookChapterScalarWhereInput[]
    NOT?: TextbookChapterScalarWhereInput | TextbookChapterScalarWhereInput[]
    id?: IntFilter<"TextbookChapter"> | number
    unit_id?: IntFilter<"TextbookChapter"> | number
    chapter_number?: StringFilter<"TextbookChapter"> | string
    title?: StringFilter<"TextbookChapter"> | string
    order?: IntFilter<"TextbookChapter"> | number
    raw_syllabus_text?: StringNullableFilter<"TextbookChapter"> | string | null
    subtopics?: JsonNullableFilter<"TextbookChapter">
    content?: StringNullableFilter<"TextbookChapter"> | string | null
    content_markdown?: StringNullableFilter<"TextbookChapter"> | string | null
    content_html?: StringNullableFilter<"TextbookChapter"> | string | null
    summary?: StringNullableFilter<"TextbookChapter"> | string | null
    learning_outcomes?: JsonNullableFilter<"TextbookChapter">
    key_takeaways?: JsonNullableFilter<"TextbookChapter">
    pdf_url?: StringNullableFilter<"TextbookChapter"> | string | null
    generated_at?: DateTimeNullableFilter<"TextbookChapter"> | Date | string | null
    neet_relevant?: BoolFilter<"TextbookChapter"> | boolean
    jee_relevant?: BoolFilter<"TextbookChapter"> | boolean
    cuet_relevant?: BoolFilter<"TextbookChapter"> | boolean
    exam_highlights?: JsonNullableFilter<"TextbookChapter">
    mcq_questions?: JsonNullableFilter<"TextbookChapter">
    short_questions?: JsonNullableFilter<"TextbookChapter">
    long_questions?: JsonNullableFilter<"TextbookChapter">
    model_used?: StringNullableFilter<"TextbookChapter"> | string | null
    tokens_used?: JsonNullableFilter<"TextbookChapter">
    generation_time_ms?: IntNullableFilter<"TextbookChapter"> | number | null
    status?: EnumChapterGenStatusFilter<"TextbookChapter"> | $Enums.ChapterGenStatus
    generation_error?: StringNullableFilter<"TextbookChapter"> | string | null
    created_at?: DateTimeFilter<"TextbookChapter"> | Date | string
    updated_at?: DateTimeFilter<"TextbookChapter"> | Date | string
  }

  export type TextbookUnitCreateWithoutChaptersInput = {
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    textbook: TextbookCreateNestedOneWithoutUnitsInput
  }

  export type TextbookUnitUncheckedCreateWithoutChaptersInput = {
    id?: number
    textbook_id: number
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TextbookUnitCreateOrConnectWithoutChaptersInput = {
    where: TextbookUnitWhereUniqueInput
    create: XOR<TextbookUnitCreateWithoutChaptersInput, TextbookUnitUncheckedCreateWithoutChaptersInput>
  }

  export type TextbookImageCreateWithoutChapterInput = {
    type: $Enums.TextbookImageType
    prompt?: string | null
    alt_text?: string | null
    url?: string | null
    image_url?: string | null
    order?: number
    placement?: string | null
    caption?: string | null
    status?: $Enums.ImageGenStatus
    model_used?: string | null
    generation_time_ms?: number | null
    generated_at?: Date | string | null
    created_at?: Date | string
  }

  export type TextbookImageUncheckedCreateWithoutChapterInput = {
    id?: number
    type: $Enums.TextbookImageType
    prompt?: string | null
    alt_text?: string | null
    url?: string | null
    image_url?: string | null
    order?: number
    placement?: string | null
    caption?: string | null
    status?: $Enums.ImageGenStatus
    model_used?: string | null
    generation_time_ms?: number | null
    generated_at?: Date | string | null
    created_at?: Date | string
  }

  export type TextbookImageCreateOrConnectWithoutChapterInput = {
    where: TextbookImageWhereUniqueInput
    create: XOR<TextbookImageCreateWithoutChapterInput, TextbookImageUncheckedCreateWithoutChapterInput>
  }

  export type TextbookImageCreateManyChapterInputEnvelope = {
    data: TextbookImageCreateManyChapterInput | TextbookImageCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type TextbookUnitUpsertWithoutChaptersInput = {
    update: XOR<TextbookUnitUpdateWithoutChaptersInput, TextbookUnitUncheckedUpdateWithoutChaptersInput>
    create: XOR<TextbookUnitCreateWithoutChaptersInput, TextbookUnitUncheckedCreateWithoutChaptersInput>
    where?: TextbookUnitWhereInput
  }

  export type TextbookUnitUpdateToOneWithWhereWithoutChaptersInput = {
    where?: TextbookUnitWhereInput
    data: XOR<TextbookUnitUpdateWithoutChaptersInput, TextbookUnitUncheckedUpdateWithoutChaptersInput>
  }

  export type TextbookUnitUpdateWithoutChaptersInput = {
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    textbook?: TextbookUpdateOneRequiredWithoutUnitsNestedInput
  }

  export type TextbookUnitUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageUpsertWithWhereUniqueWithoutChapterInput = {
    where: TextbookImageWhereUniqueInput
    update: XOR<TextbookImageUpdateWithoutChapterInput, TextbookImageUncheckedUpdateWithoutChapterInput>
    create: XOR<TextbookImageCreateWithoutChapterInput, TextbookImageUncheckedCreateWithoutChapterInput>
  }

  export type TextbookImageUpdateWithWhereUniqueWithoutChapterInput = {
    where: TextbookImageWhereUniqueInput
    data: XOR<TextbookImageUpdateWithoutChapterInput, TextbookImageUncheckedUpdateWithoutChapterInput>
  }

  export type TextbookImageUpdateManyWithWhereWithoutChapterInput = {
    where: TextbookImageScalarWhereInput
    data: XOR<TextbookImageUpdateManyMutationInput, TextbookImageUncheckedUpdateManyWithoutChapterInput>
  }

  export type TextbookImageScalarWhereInput = {
    AND?: TextbookImageScalarWhereInput | TextbookImageScalarWhereInput[]
    OR?: TextbookImageScalarWhereInput[]
    NOT?: TextbookImageScalarWhereInput | TextbookImageScalarWhereInput[]
    id?: IntFilter<"TextbookImage"> | number
    chapter_id?: IntFilter<"TextbookImage"> | number
    type?: EnumTextbookImageTypeFilter<"TextbookImage"> | $Enums.TextbookImageType
    prompt?: StringNullableFilter<"TextbookImage"> | string | null
    alt_text?: StringNullableFilter<"TextbookImage"> | string | null
    url?: StringNullableFilter<"TextbookImage"> | string | null
    image_url?: StringNullableFilter<"TextbookImage"> | string | null
    order?: IntFilter<"TextbookImage"> | number
    placement?: StringNullableFilter<"TextbookImage"> | string | null
    caption?: StringNullableFilter<"TextbookImage"> | string | null
    status?: EnumImageGenStatusFilter<"TextbookImage"> | $Enums.ImageGenStatus
    model_used?: StringNullableFilter<"TextbookImage"> | string | null
    generation_time_ms?: IntNullableFilter<"TextbookImage"> | number | null
    generated_at?: DateTimeNullableFilter<"TextbookImage"> | Date | string | null
    created_at?: DateTimeFilter<"TextbookImage"> | Date | string
  }

  export type TextbookChapterCreateWithoutImagesInput = {
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    unit: TextbookUnitCreateNestedOneWithoutChaptersInput
  }

  export type TextbookChapterUncheckedCreateWithoutImagesInput = {
    id?: number
    unit_id: number
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TextbookChapterCreateOrConnectWithoutImagesInput = {
    where: TextbookChapterWhereUniqueInput
    create: XOR<TextbookChapterCreateWithoutImagesInput, TextbookChapterUncheckedCreateWithoutImagesInput>
  }

  export type TextbookChapterUpsertWithoutImagesInput = {
    update: XOR<TextbookChapterUpdateWithoutImagesInput, TextbookChapterUncheckedUpdateWithoutImagesInput>
    create: XOR<TextbookChapterCreateWithoutImagesInput, TextbookChapterUncheckedCreateWithoutImagesInput>
    where?: TextbookChapterWhereInput
  }

  export type TextbookChapterUpdateToOneWithWhereWithoutImagesInput = {
    where?: TextbookChapterWhereInput
    data: XOR<TextbookChapterUpdateWithoutImagesInput, TextbookChapterUncheckedUpdateWithoutImagesInput>
  }

  export type TextbookChapterUpdateWithoutImagesInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: TextbookUnitUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type TextbookChapterUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookCreateWithoutGeneration_jobsInput = {
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    syllabus?: SyllabusCreateNestedOneWithoutTextbooksInput
    creator: userCreateNestedOneWithoutTextbooks_createdInput
    units?: TextbookUnitCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentCreateNestedManyWithoutTextbookInput
  }

  export type TextbookUncheckedCreateWithoutGeneration_jobsInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
    units?: TextbookUnitUncheckedCreateNestedManyWithoutTextbookInput
    enrollments?: UserEnrollmentUncheckedCreateNestedManyWithoutTextbookInput
  }

  export type TextbookCreateOrConnectWithoutGeneration_jobsInput = {
    where: TextbookWhereUniqueInput
    create: XOR<TextbookCreateWithoutGeneration_jobsInput, TextbookUncheckedCreateWithoutGeneration_jobsInput>
  }

  export type TextbookUpsertWithoutGeneration_jobsInput = {
    update: XOR<TextbookUpdateWithoutGeneration_jobsInput, TextbookUncheckedUpdateWithoutGeneration_jobsInput>
    create: XOR<TextbookCreateWithoutGeneration_jobsInput, TextbookUncheckedCreateWithoutGeneration_jobsInput>
    where?: TextbookWhereInput
  }

  export type TextbookUpdateToOneWithWhereWithoutGeneration_jobsInput = {
    where?: TextbookWhereInput
    data: XOR<TextbookUpdateWithoutGeneration_jobsInput, TextbookUncheckedUpdateWithoutGeneration_jobsInput>
  }

  export type TextbookUpdateWithoutGeneration_jobsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    syllabus?: SyllabusUpdateOneWithoutTextbooksNestedInput
    creator?: userUpdateOneRequiredWithoutTextbooks_createdNestedInput
    units?: TextbookUnitUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateWithoutGeneration_jobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
    units?: TextbookUnitUncheckedUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutTextbookNestedInput
  }

  export type DocumentPageCreateManyFileInput = {
    id?: number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type FileChunkCreateManyFileInput = {
    id?: number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: number | null
    created_at?: Date | string
  }

  export type DocumentPageUpdateWithoutFileInput = {
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageUncheckedUpdateWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageUncheckedUpdateManyWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileChunkUpdateWithoutFileInput = {
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileChunkUncheckedUpdateWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileChunkUncheckedUpdateManyWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryListCreateManyUserInput = {
    id?: number
    category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ConversationCreateManyUserInput = {
    id?: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
    chapter_id?: bigint | number | null
  }

  export type FileListCreateManyUserInput = {
    id?: number
    category: string
    title: string
    note?: string | null
    content_format?: string | null
    doc1?: string | null
    entry_date?: string | null
    entry_date_real?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    parsing_status?: string | null
    parsing_error?: string | null
    parsed_at?: Date | string | null
  }

  export type UsageTrackingCreateManyUserInput = {
    id?: number
    usage_type: $Enums.UsageType
    count?: number
    period_start: Date | string
    period_end: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type QuizCreateManyUserInput = {
    id?: string
    subject_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
  }

  export type UserPointsCreateManyUserInput = {
    id?: string
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badge_id: string
    earned_at?: Date | string
  }

  export type LearningSessionCreateManyUserInput = {
    id?: string
    chapter_id: bigint | number
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BattleCreateManyCreatorInput = {
    id?: string
    quiz_id: string
    code: string
    status?: $Enums.BattleStatus
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BattleParticipantCreateManyUserInput = {
    id?: string
    battle_id: string
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
  }

  export type TextbookCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    syllabus_id?: number | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserEnrollmentCreateManyUserInput = {
    id?: number
    textbook_id: number
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
  }

  export type CategoryListUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryListUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryListUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
    subject?: SubjectUpdateOneWithoutConversationsNestedInput
    chapter?: ChapterUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type FileListUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: DocumentPageUpdateManyWithoutFileNestedInput
    chunks?: FileChunkUpdateManyWithoutFileNestedInput
  }

  export type FileListUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: DocumentPageUncheckedUpdateManyWithoutFileNestedInput
    chunks?: FileChunkUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileListUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    content_format?: NullableStringFieldUpdateOperationsInput | string | null
    doc1?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date?: NullableStringFieldUpdateOperationsInput | string | null
    entry_date_real?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsing_status?: NullableStringFieldUpdateOperationsInput | string | null
    parsing_error?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsageTrackingUpdateWithoutUserInput = {
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    usage_type?: EnumUsageTypeFieldUpdateOperationsInput | $Enums.UsageType
    count?: IntFieldUpdateOperationsInput | number
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject?: SubjectUpdateOneRequiredWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    battles?: BattleUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    battles?: BattleUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPointsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPointsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPointsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: StreakBadgeUpdateOneRequiredWithoutUser_badgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutLearning_sessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapter_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    quiz?: QuizUpdateOneRequiredWithoutBattlesNestedInput
    participants?: BattleParticipantUpdateManyWithoutBattleNestedInput
  }

  export type BattleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    participants?: BattleParticipantUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type BattleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BattleParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
    battle?: BattleUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type BattleParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    battle_id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    battle_id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    syllabus?: SyllabusUpdateOneWithoutTextbooksNestedInput
    units?: TextbookUnitUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: TextbookUnitUncheckedUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUncheckedUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus_id?: NullableIntFieldUpdateOperationsInput | number | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEnrollmentUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    textbook?: TextbookUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type UserEnrollmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserEnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    textbook_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationMessageCreateManyConversationInput = {
    id?: number
    role: $Enums.MessageRole
    content: string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ConversationMessageUpdateWithoutConversationInput = {
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    sources?: NullableJsonNullValueInput | InputJsonValue
    token_count?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyPlanInput = {
    id?: number
    user_id: number
    razorpay_subscription_id?: string | null
    razorpay_customer_id?: string | null
    razorpay_order_id?: string | null
    status?: $Enums.SubscriptionStatus
    billing_cycle?: $Enums.BillingCycle
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserSubscriptionUpdateWithoutPlanInput = {
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    razorpay_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    razorpay_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billing_cycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCreateManyCountryInput = {
    id: string
    name: string
    state?: string | null
    type?: string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BoardUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUpdateManyWithoutBoardNestedInput
    programs?: ProgramUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institutions?: InstitutionUncheckedUpdateManyWithoutBoardNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutBoardNestedInput
    chunkBoards?: ChapterChunkBoardUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutCountryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateManyBoardInput = {
    id?: bigint | number
    name: string
    type: string
    district?: string | null
    state?: string | null
    license_expiry?: Date | string | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type ProgramCreateManyBoardInput = {
    id?: number
    institution_id?: bigint | number | null
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type ChapterChunkBoardCreateManyBoardInput = {
    chunk_id: bigint | number
  }

  export type InstitutionUpdateWithoutBoardInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUpdateManyWithoutInstitutionNestedInput
    profiles?: ProfileUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutBoardInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutInstitutionNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateManyWithoutBoardInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    license_expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpdateWithoutBoardInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutProgramsNestedInput
    subjects?: SubjectUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUpdateManyWithoutProgramNestedInput
    exams?: ExamUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutProgramNestedInput
    exams?: ExamUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChunkBoardUpdateWithoutBoardInput = {
    chunk?: ChapterChunkUpdateOneRequiredWithoutChunkBoardsNestedInput
  }

  export type ChapterChunkBoardUncheckedUpdateWithoutBoardInput = {
    chunk_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ChapterChunkBoardUncheckedUpdateManyWithoutBoardInput = {
    chunk_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramCreateManyInstitutionInput = {
    id?: number
    board_id: string
    name: string
    code?: string | null
    level?: string | null
    duration_years?: number | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type ProfileCreateManyInstitutionInput = {
    id?: number
    user_id: number
    program_id?: number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ProgramUpdateWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutProgramsNestedInput
    subjects?: SubjectUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUpdateManyWithoutProgramNestedInput
    exams?: ExamUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutProgramNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutProgramNestedInput
    exams?: ExamUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration_years?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpdateWithoutInstitutionInput = {
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    program?: ProgramUpdateOneWithoutProfilesNestedInput
  }

  export type ProfileUncheckedUpdateWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ProfileUncheckedUpdateManyWithoutInstitutionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SubjectCreateManyProgramInput = {
    id?: number
    name: string
    code?: string | null
    is_active?: boolean
    created_at?: Date | string
    term?: string | null
  }

  export type ProfileCreateManyProgramInput = {
    id?: number
    user_id: number
    institution_id?: bigint | number | null
    is_premium?: boolean
    last_sync_at?: bigint | number | null
  }

  export type ExamCreateManyProgramInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubjectUpdateWithoutProgramInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    quizzes?: QuizUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutSubjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    term?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUpdateWithoutProgramInput = {
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
    institution?: InstitutionUpdateOneWithoutProfilesNestedInput
  }

  export type ProfileUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ProfileUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    institution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    last_sync_at?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ExamUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateManySubjectInput = {
    id?: bigint | number
    title: string
    chapter_number?: number | null
    content_json: JsonNullValueInput | InputJsonValue
    version_id?: string
    accessible_boards?: ChapterCreateaccessible_boardsInput | string[]
    is_global?: boolean
    is_active?: boolean
    processing_status?: $Enums.ChapterStatus
    error_message?: string | null
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    parsed_at?: Date | string | null
  }

  export type QuizCreateManySubjectInput = {
    id?: string
    user_id: number
    chapter_id?: bigint | number | null
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
  }

  export type ConversationCreateManySubjectInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    chapter_id?: bigint | number | null
  }

  export type ChapterUpdateWithoutSubjectInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUpdateManyWithoutChapterNestedInput
    questions?: QuestionUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutSubjectInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chunks?: ChapterChunkUncheckedUpdateManyWithoutChapterNestedInput
    pages?: ChapterPageUncheckedUpdateManyWithoutChapterNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutChapterNestedInput
    study_materials?: StudyMaterialUncheckedUpdateOneWithoutChapterNestedInput
    learning_sessions?: LearningSessionUncheckedUpdateManyWithoutChapterNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutChapterNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    chapter_number?: NullableIntFieldUpdateOperationsInput | number | null
    content_json?: JsonNullValueInput | InputJsonValue
    version_id?: StringFieldUpdateOperationsInput | string
    accessible_boards?: ChapterUpdateaccessible_boardsInput | string[]
    is_global?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    processing_status?: EnumChapterStatusFieldUpdateOperationsInput | $Enums.ChapterStatus
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parsed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQuizzesNestedInput
    chapter?: ChapterUpdateOneWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    battles?: BattleUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    battles?: BattleUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationUpdateWithoutSubjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
    user?: userUpdateOneRequiredWithoutConversationsNestedInput
    chapter?: ChapterUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    chapter_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ChapterChunkCreateManyChapterInput = {
    id?: bigint | number
    chunk_index: number
    content: string
    page_number?: number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: number | null
    created_at?: Date | string
  }

  export type ChapterPageCreateManyChapterInput = {
    id?: bigint | number
    page_number: number
    image_url: string
    width?: number | null
    height?: number | null
    created_at?: Date | string
  }

  export type QuizCreateManyChapterInput = {
    id?: string
    user_id: number
    subject_id: number
    title: string
    description?: string | null
    status?: $Enums.QuizStatus
    score?: number
    total_points?: number
    created_at?: Date | string
    updated_at?: Date | string
    completed_at?: Date | string | null
  }

  export type LearningSessionCreateManyChapterInput = {
    id?: string
    user_id: number
    status?: string
    current_topic?: string | null
    progress?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConversationCreateManyChapterInput = {
    id?: number
    user_id: number
    title?: string
    created_at?: Date | string
    updated_at?: Date | string
    last_message_at?: Date | string | null
    message_count?: number
    is_pinned?: boolean
    is_archived?: boolean
    subject_id?: number | null
  }

  export type QuestionCreateManyChapterInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    difficulty: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    explanation?: string | null
    points?: number
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChapterChunkUpdateWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chunkBoards?: ChapterChunkBoardUpdateManyWithoutChunkNestedInput
  }

  export type ChapterChunkUncheckedUpdateWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chunkBoards?: ChapterChunkBoardUncheckedUpdateManyWithoutChunkNestedInput
  }

  export type ChapterChunkUncheckedUpdateManyWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chunk_index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    page_number?: NullableIntFieldUpdateOperationsInput | number | null
    bbox?: NullableJsonNullValueInput | InputJsonValue
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterPageUpdateWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterPageUncheckedUpdateWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterPageUncheckedUpdateManyWithoutChapterInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    page_number?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutQuizzesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    battles?: BattleUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    battles?: BattleUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    subject_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuizStatusFieldUpdateOperationsInput | $Enums.QuizStatus
    score?: IntFieldUpdateOperationsInput | number
    total_points?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningSessionUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutLearning_sessionsNestedInput
  }

  export type LearningSessionUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningSessionUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    current_topic?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutChapterInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
    user?: userUpdateOneRequiredWithoutConversationsNestedInput
    subject?: SubjectUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_message_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message_count?: IntFieldUpdateOperationsInput | number
    is_pinned?: BoolFieldUpdateOperationsInput | boolean
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterChunkBoardCreateManyChunkInput = {
    board_id: string
  }

  export type ChapterChunkBoardUpdateWithoutChunkInput = {
    board?: BoardUpdateOneRequiredWithoutChunkBoardsNestedInput
  }

  export type ChapterChunkBoardUncheckedUpdateWithoutChunkInput = {
    board_id?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterChunkBoardUncheckedUpdateManyWithoutChunkInput = {
    board_id?: StringFieldUpdateOperationsInput | string
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: string
    question_text: string
    question_type: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: boolean | null
    points?: number
    explanation?: string | null
    feedback?: string | null
  }

  export type BattleCreateManyQuizInput = {
    id?: string
    code: string
    status?: $Enums.BattleStatus
    created_by: number
    created_at?: Date | string
    started_at?: Date | string | null
    ended_at?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    user_answer?: NullableJsonNullValueInput | InputJsonValue
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    points?: IntFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BattleUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    creator?: userUpdateOneRequiredWithoutCreated_battlesNestedInput
    participants?: BattleParticipantUpdateManyWithoutBattleNestedInput
  }

  export type BattleUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    participants?: BattleParticipantUncheckedUpdateManyWithoutBattleNestedInput
  }

  export type BattleUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumBattleStatusFieldUpdateOperationsInput | $Enums.BattleStatus
    created_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ended_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserBadgeCreateManyBadgeInput = {
    id?: string
    user_id: number
    earned_at?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleParticipantCreateManyBattleInput = {
    id?: string
    user_id: number
    score?: number
    current_q_index?: number
    finished?: boolean
    joined_at?: Date | string
    last_active?: Date | string
  }

  export type BattleParticipantUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutBattle_participationsNestedInput
  }

  export type BattleParticipantUncheckedUpdateWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BattleParticipantUncheckedUpdateManyWithoutBattleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    current_q_index?: IntFieldUpdateOperationsInput | number
    finished?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_active?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyllabusUnitCreateManySyllabusInput = {
    id?: number
    title: string
    order: number
    description?: string | null
  }

  export type TextbookCreateManySyllabusInput = {
    id?: number
    title: string
    description?: string | null
    class_level: string
    stream?: string | null
    subject_name?: string | null
    board_id?: string | null
    academic_year?: string | null
    author?: string | null
    raw_syllabus?: string | null
    status?: $Enums.TextbookStatus
    progress?: number
    cover_image_url?: string | null
    pdf_url?: string | null
    compiled_pdf_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by: number
  }

  export type SyllabusUnitUpdateWithoutSyllabusInput = {
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: SyllabusChapterUpdateManyWithoutUnitNestedInput
  }

  export type SyllabusUnitUncheckedUpdateWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chapters?: SyllabusChapterUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SyllabusUnitUncheckedUpdateManyWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TextbookUpdateWithoutSyllabusInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: userUpdateOneRequiredWithoutTextbooks_createdNestedInput
    units?: TextbookUnitUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
    units?: TextbookUnitUncheckedUpdateManyWithoutTextbookNestedInput
    generation_jobs?: TextbookGenerationJobUncheckedUpdateManyWithoutTextbookNestedInput
    enrollments?: UserEnrollmentUncheckedUpdateManyWithoutTextbookNestedInput
  }

  export type TextbookUncheckedUpdateManyWithoutSyllabusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class_level?: StringFieldUpdateOperationsInput | string
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    subject_name?: NullableStringFieldUpdateOperationsInput | string | null
    board_id?: NullableStringFieldUpdateOperationsInput | string | null
    academic_year?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    raw_syllabus?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTextbookStatusFieldUpdateOperationsInput | $Enums.TextbookStatus
    progress?: IntFieldUpdateOperationsInput | number
    cover_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    compiled_pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: IntFieldUpdateOperationsInput | number
  }

  export type SyllabusChapterCreateManyUnitInput = {
    id?: number
    chapter_number: string
    title: string
    order: number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUpdateWithoutUnitInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyllabusChapterUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subtopics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TextbookUnitCreateManyTextbookInput = {
    id?: number
    order: number
    title: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TextbookGenerationJobCreateManyTextbookInput = {
    id?: number
    job_type: $Enums.TextbookGenerationJobType
    status?: $Enums.TextbookJobStatus
    target_id?: number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: string | null
    progress?: number
    started_at?: Date | string | null
    completed_at?: Date | string | null
    attempts?: number
    max_attempts?: number
    created_at?: Date | string
  }

  export type UserEnrollmentCreateManyTextbookInput = {
    id?: number
    user_id: number
    status?: string
    progress?: number
    last_accessed_at?: Date | string | null
    enrolled_at?: Date | string
    completed_at?: Date | string | null
  }

  export type TextbookUnitUpdateWithoutTextbookInput = {
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: TextbookChapterUpdateManyWithoutUnitNestedInput
  }

  export type TextbookUnitUncheckedUpdateWithoutTextbookInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: TextbookChapterUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type TextbookUnitUncheckedUpdateManyWithoutTextbookInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookGenerationJobUpdateWithoutTextbookInput = {
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookGenerationJobUncheckedUpdateWithoutTextbookInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookGenerationJobUncheckedUpdateManyWithoutTextbookInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: EnumTextbookGenerationJobTypeFieldUpdateOperationsInput | $Enums.TextbookGenerationJobType
    status?: EnumTextbookJobStatusFieldUpdateOperationsInput | $Enums.TextbookJobStatus
    target_id?: NullableIntFieldUpdateOperationsInput | number | null
    input_data?: NullableJsonNullValueInput | InputJsonValue
    output_data?: NullableJsonNullValueInput | InputJsonValue
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    max_attempts?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEnrollmentUpdateWithoutTextbookInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type UserEnrollmentUncheckedUpdateWithoutTextbookInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserEnrollmentUncheckedUpdateManyWithoutTextbookInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrolled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TextbookChapterCreateManyUnitInput = {
    id?: number
    chapter_number: string
    title: string
    order: number
    raw_syllabus_text?: string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    content_markdown?: string | null
    content_html?: string | null
    summary?: string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: string | null
    generated_at?: Date | string | null
    neet_relevant?: boolean
    jee_relevant?: boolean
    cuet_relevant?: boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: number | null
    status?: $Enums.ChapterGenStatus
    generation_error?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TextbookChapterUpdateWithoutUnitInput = {
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: TextbookImageUpdateManyWithoutChapterNestedInput
  }

  export type TextbookChapterUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: TextbookImageUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type TextbookChapterUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapter_number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    raw_syllabus_text?: NullableStringFieldUpdateOperationsInput | string | null
    subtopics?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    content_markdown?: NullableStringFieldUpdateOperationsInput | string | null
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: NullableJsonNullValueInput | InputJsonValue
    key_takeaways?: NullableJsonNullValueInput | InputJsonValue
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neet_relevant?: BoolFieldUpdateOperationsInput | boolean
    jee_relevant?: BoolFieldUpdateOperationsInput | boolean
    cuet_relevant?: BoolFieldUpdateOperationsInput | boolean
    exam_highlights?: NullableJsonNullValueInput | InputJsonValue
    mcq_questions?: NullableJsonNullValueInput | InputJsonValue
    short_questions?: NullableJsonNullValueInput | InputJsonValue
    long_questions?: NullableJsonNullValueInput | InputJsonValue
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    tokens_used?: NullableJsonNullValueInput | InputJsonValue
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumChapterGenStatusFieldUpdateOperationsInput | $Enums.ChapterGenStatus
    generation_error?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageCreateManyChapterInput = {
    id?: number
    type: $Enums.TextbookImageType
    prompt?: string | null
    alt_text?: string | null
    url?: string | null
    image_url?: string | null
    order?: number
    placement?: string | null
    caption?: string | null
    status?: $Enums.ImageGenStatus
    model_used?: string | null
    generation_time_ms?: number | null
    generated_at?: Date | string | null
    created_at?: Date | string
  }

  export type TextbookImageUpdateWithoutChapterInput = {
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TextbookImageUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTextbookImageTypeFieldUpdateOperationsInput | $Enums.TextbookImageType
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    alt_text?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    placement?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumImageGenStatusFieldUpdateOperationsInput | $Enums.ImageGenStatus
    model_used?: NullableStringFieldUpdateOperationsInput | string | null
    generation_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    generated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}