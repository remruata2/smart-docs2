{"version":3,"sources":["../../../../src/lib/semantic-vector.ts","../../../../node_modules/%40vercel/oidc/dist/token-error.js","../../../../src/lib/quiz-cache.ts","../../../../src/app/app/practice/actions.ts"],"sourcesContent":["// semantic-vector.ts\nimport { pipeline } from \"@xenova/transformers\";\nimport { db as prisma } from \"./db\";\n\n// Define the model we want to use.\n// 'Xenova/all-MiniLM-L6-v2' is standard for RAG: fast, small (23MB), and accurate.\nconst EMBEDDING_MODEL = \"Xenova/all-MiniLM-L6-v2\";\n\nexport class SemanticVectorService {\n\t// Singleton instance of the embedder pipeline to avoid reloading model on every call\n\tprivate static embedder: any = null;\n\n\t/**\n\t * Initialize the local embedding pipeline.\n\t * This downloads the model files (once) and caches them.\n\t */\n\tstatic async initialize() {\n\t\tif (!this.embedder) {\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Initializing local embedder model: ${EMBEDDING_MODEL}...`\n\t\t\t);\n\t\t\tthis.embedder = await pipeline(\"feature-extraction\", EMBEDDING_MODEL);\n\t\t\tconsole.log(\"[SEMANTIC] Embedder initialized successfully\");\n\t\t}\n\t}\n\n\t/**\n\t * Generates a vector embedding locally using Transformers.js\n\t * No API limits, no costs.\n\t */\n\tstatic async generateEmbedding(text: string): Promise<number[]> {\n\t\tawait this.initialize();\n\n\t\tif (!text || !text.trim()) {\n\t\t\tthrow new Error(\"Text is required for embedding generation\");\n\t\t}\n\n\t\t// 1. Pre-process text:\n\t\t// Replace newlines to keep semantic meaning consistent and trim\n\t\tconst cleanedText = text.replace(/\\n+/g, \" \").trim();\n\n\t\t// 2. Truncate text to avoid model limits (512 tokens approx ~2000 chars)\n\t\t// We truncate to 2000 characters to be safe.\n\t\t// For full document search, you should ideally chunk the document and average the vectors,\n\t\t// but for a simple file-level vector, truncating the first 2000 chars (header + summary) works well.\n\t\tconst truncatedText = cleanedText.substring(0, 2000);\n\n\t\ttry {\n\t\t\t// 3. Run inference\n\t\t\tconst result = await this.embedder(truncatedText, {\n\t\t\t\tpooling: \"mean\", // Average the token vectors to get one sentence vector\n\t\t\t\tnormalize: true, // Important for cosine similarity\n\t\t\t});\n\n\t\t\t// 4. Convert Float32Array to regular number array\n\t\t\treturn Array.from(result.data);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"[SEMANTIC] Error generating embedding:\", error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the semantic vector for a specific file.\n\t * @deprecated This function references the old file_list table. Use chapter-processor.ts for chapter chunks instead.\n\t */\n\tstatic async updateSemanticVector(fileId: number) {\n\t\ttry {\n\t\t\tconst file = await prisma.fileList.findUnique({\n\t\t\t\twhere: { id: fileId },\n\t\t\t\tselect: { title: true, category: true, note: true },\n\t\t\t});\n\n\t\t\tif (!file) {\n\t\t\t\tthrow new Error(`File with ID ${fileId} not found`);\n\t\t\t}\n\n\t\t\t// Combine fields.\n\t\t\t// Tip: Put the most important keywords (Title/Category) FIRST\n\t\t\t// because truncation happens at the end.\n\t\t\tconst textToEmbed = `Title: ${file.title}. Category: ${file.category\n\t\t\t\t}. Content: ${file.note || \"\"}`;\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Generating vector for file ${fileId} (${textToEmbed.length} chars)...`\n\t\t\t);\n\n\t\t\tconst embedding = await this.generateEmbedding(textToEmbed);\n\n\t\t\t// Update DB using raw query for pgvector compatibility\n\t\t\tawait prisma.$executeRaw`\n\t\t\t\tUPDATE file_list\n\t\t\t\tSET semantic_vector = ${JSON.stringify(embedding)}::vector\n\t\t\t\tWHERE id = ${fileId}\n\t\t\t`;\n\n\t\t\tconsole.log(`[SEMANTIC] Successfully updated vector for file ${fileId}`);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[SEMANTIC] Failed to update vector for file ${fileId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\t// Don't throw here if this is part of a background batch job, just log it.\n\t\t\t// throw error;\n\t\t}\n\t}\n\n\t/**\n\t * Generate semantic vectors for file chunks\n\t * @deprecated This function references the old file_chunks table. Use chapter-processor.ts for chapter chunks instead.\n\t */\n\tstatic async generateChunkVectors(fileId: number) {\n\t\ttry {\n\t\t\t// Get all chunks for this file\n\t\t\tconst chunks = await prisma.fileChunk.findMany({\n\t\t\t\twhere: { file_id: fileId },\n\t\t\t\tselect: { id: true, content: true },\n\t\t\t});\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Generating vectors for ${chunks.length} chunks of file ${fileId}...`\n\t\t\t);\n\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst embedding = await this.generateEmbedding(chunk.content);\n\n\t\t\t\t\t// Update chunk's semantic vector\n\t\t\t\t\tawait prisma.$executeRaw`\n\t\t\t\t\t\tUPDATE file_chunks\n\t\t\t\t\t\tSET semantic_vector = ${JSON.stringify(embedding)}::vector\n\t\t\t\t\t\tWHERE id = ${chunk.id}\n\t\t\t\t\t`;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`[SEMANTIC] Failed to generate vector for chunk ${chunk.id}:`,\n\t\t\t\t\t\terr\n\t\t\t\t\t);\n\t\t\t\t\t// Continue with other chunks\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Successfully updated vectors for file ${fileId} chunks`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[SEMANTIC] Failed to generate chunk vectors for file ${fileId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Batch/Repair function: Find all files missing vectors and generate them.\n\t * @deprecated This function references the old file_list table. Use updateSearchVectors() in ai-service-enhanced.ts for chapter chunks instead.\n\t */\n\tstatic async batchUpdateSemanticVectors() {\n\t\tconsole.log(\"[SEMANTIC] Starting batch update for missing vectors...\");\n\n\t\t// Find IDs where vector is NULL\n\t\tconst records = await prisma.$queryRaw<{ id: number }[]>`\n\t\t\tSELECT id FROM file_list WHERE semantic_vector IS NULL\n\t\t`;\n\n\t\tconsole.log(`[SEMANTIC] Found ${records.length} records to update.`);\n\n\t\tfor (const record of records) {\n\t\t\tawait this.updateSemanticVector(record.id);\n\t\t}\n\n\t\tconsole.log(\"[SEMANTIC] Batch update completed.\");\n\t}\n}\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar token_error_exports = {};\n__export(token_error_exports, {\n  VercelOidcTokenError: () => VercelOidcTokenError\n});\nmodule.exports = __toCommonJS(token_error_exports);\nclass VercelOidcTokenError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.name = \"VercelOidcTokenError\";\n    this.cause = cause;\n  }\n  toString() {\n    if (this.cause) {\n      return `${this.name}: ${this.message}: ${this.cause}`;\n    }\n    return `${this.name}: ${this.message}`;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  VercelOidcTokenError\n});\n","/**\n * Simple in-memory cache for quiz generation\n * Uses TTL-based expiration to prevent stale data\n */\n\ninterface CacheEntry<T> {\n\tvalue: T;\n\texpiresAt: number;\n}\n\nclass QuizCache {\n\tprivate cache: Map<string, CacheEntry<any>> = new Map();\n\tprivate defaultTTL: number = 60 * 60 * 1000; // 1 hour in milliseconds\n\n\t/**\n\t * Get value from cache\n\t */\n\tget<T>(key: string): T | null {\n\t\tconst entry = this.cache.get(key);\n\n\t\tif (!entry) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if expired\n\t\tif (Date.now() > entry.expiresAt) {\n\t\t\tthis.cache.delete(key);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry.value as T;\n\t}\n\n\t/**\n\t * Set value in cache with optional TTL\n\t */\n\tset<T>(key: string, value: T, ttlMs?: number): void {\n\t\tconst ttl = ttlMs ?? this.defaultTTL;\n\t\tconst expiresAt = Date.now() + ttl;\n\n\t\tthis.cache.set(key, {\n\t\t\tvalue,\n\t\t\texpiresAt,\n\t\t});\n\t}\n\n\t/**\n\t * Delete value from cache\n\t */\n\tdelete(key: string): void {\n\t\tthis.cache.delete(key);\n\t}\n\n\t/**\n\t * Clear all cache entries\n\t */\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n\n\t/**\n\t * Remove expired entries\n\t */\n\tcleanup(): void {\n\t\tconst now = Date.now();\n\t\tfor (const [key, entry] of this.cache.entries()) {\n\t\t\tif (now > entry.expiresAt) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get cache stats\n\t */\n\tstats() {\n\t\treturn {\n\t\t\tsize: this.cache.size,\n\t\t\tkeys: Array.from(this.cache.keys()),\n\t\t};\n\t}\n}\n\n// Singleton instance\nexport const quizCache = new QuizCache();\n\n// Clear cache on server start for fresh data (only at runtime, not during build)\n// Check if we're NOT in a build phase\nconst isBuildPhase =\n\tprocess.env.NEXT_PHASE === \"phase-production-build\" ||\n\tprocess.env.NEXT_PHASE === \"phase-development-build\";\n\nif (typeof window === \"undefined\" && !isBuildPhase) {\n\tconsole.log(\"[QUIZ-CACHE] Clearing cache on server start\");\n\tquizCache.clear();\n}\n\n// Periodic cleanup (every 10 minutes) - only at runtime, not during build\nif (typeof window === \"undefined\" && !isBuildPhase) {\n\tsetInterval(() => {\n\t\tquizCache.cleanup();\n\t}, 10 * 60 * 1000);\n}\n\n/**\n * Helper to generate cache keys\n */\nexport const CacheKeys = {\n\tchapterContext: (chapterId: number | bigint) =>\n\t\t`chapter:${chapterId}:context`,\n\tsubjectContext: (subjectId: number) => `subject:${subjectId}:context`,\n} as const;\n","\"use server\";\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth-options\";\nimport { prisma } from \"@/lib/prisma\";\nimport { generateQuiz, gradeQuiz, QuizGenerationConfig } from \"@/lib/ai-service-enhanced\";\nimport { QuestionType, QuizStatus } from \"@/generated/prisma\";\nimport { quizCache, CacheKeys } from \"@/lib/quiz-cache\";\n\n/**\n * Get chapter context with caching\n */\n/**\n * Get chapter context with caching\n */\nasync function getChapterContext(chapterId: number): Promise<{ title: string; context: string; board?: string; level?: string }> {\n    const cacheKey = CacheKeys.chapterContext(chapterId);\n    const cached = quizCache.get<{ title: string; context: string; board?: string; level?: string }>(cacheKey);\n\n    if (cached) {\n        console.log(`[QUIZ-CACHE] Hit for chapter ${chapterId}`);\n        return cached;\n    }\n\n    console.log(`[QUIZ-CACHE] Miss for chapter ${chapterId}, fetching from DB`);\n\n    // Fetch chapter metadata with relations\n    const chapter = await prisma.chapter.findUnique({\n        where: { id: BigInt(chapterId) },\n        select: {\n            title: true,\n            subject: {\n                select: {\n                    program: {\n                        select: {\n                            name: true,\n                            board: {\n                                select: { id: true }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n    });\n\n    if (!chapter) throw new Error(\"Chapter not found\");\n\n    // Fetch all chunks for this chapter (this is where the actual content is!)\n    const chunks = await prisma.chapterChunk.findMany({\n        where: { chapter_id: BigInt(chapterId) },\n        select: { content: true, chunk_index: true },\n        orderBy: { chunk_index: 'asc' },\n    });\n\n    console.log(`[QUIZ-CACHE] Found ${chunks.length} chunks for chapter ${chapterId}`);\n\n    // Concatenate all chunk content\n    const context = chunks.map(chunk => chunk.content).join(\"\\n\\n\");\n\n    console.log(`[QUIZ-CACHE] Total context length: ${context.length} characters`);\n\n    const result = {\n        title: chapter.title,\n        context,\n        board: chapter.subject?.program?.board?.id,\n        level: chapter.subject?.program?.name\n    };\n\n    // Cache for 1 hour\n    quizCache.set(cacheKey, result, 60 * 60 * 1000);\n\n    return result;\n}\n\n/**\n * Get subject-level context with random chapter sampling\n */\n/**\n * Get subject-level context with random chapter sampling\n */\nasync function getSubjectContext(subjectId: number): Promise<{ context: string; board?: string; level?: string }> {\n    const cacheKey = CacheKeys.subjectContext(subjectId);\n    const cached = quizCache.get<{ context: string; board?: string; level?: string }>(cacheKey);\n\n    if (cached) {\n        console.log(`[QUIZ-CACHE] Hit for subject ${subjectId}`);\n        return cached;\n    }\n\n    console.log(`[QUIZ-CACHE] Miss for subject ${subjectId}, fetching from DB`);\n\n    // Fetch Subject Metadata\n    const subject = await prisma.subject.findUnique({\n        where: { id: subjectId },\n        select: {\n            program: {\n                select: {\n                    name: true,\n                    board: { select: { id: true } }\n                }\n            }\n        }\n    });\n\n    // Get all chapter IDs, then randomly sample 3\n    const chapterIds = await prisma.chapter.findMany({\n        where: { subject_id: subjectId, is_active: true },\n        select: { id: true },\n    });\n\n    if (chapterIds.length === 0) {\n        throw new Error(\"No chapters found for subject\");\n    }\n\n    // Random sampling\n    const sampleSize = Math.min(3, chapterIds.length);\n    const shuffled = [...chapterIds].sort(() => Math.random() - 0.5);\n    const selectedIds = shuffled.slice(0, sampleSize).map(c => c.id);\n\n    console.log(`[QUIZ-CACHE] Sampling ${sampleSize} chapters for subject context`);\n\n    // Fetch chunks from selected chapters\n    const chunks = await prisma.chapterChunk.findMany({\n        where: { chapter_id: { in: selectedIds } },\n        select: { content: true, chunk_index: true, chapter_id: true },\n        orderBy: [\n            { chapter_id: 'asc' },\n            { chunk_index: 'asc' }\n        ],\n    });\n\n    console.log(`[QUIZ-CACHE] Found ${chunks.length} total chunks from ${sampleSize} chapters`);\n\n    const context = chunks.map(c => c.content).join(\"\\n\\n\");\n\n    const result = {\n        context,\n        board: subject?.program?.board?.id,\n        level: subject?.program?.name\n    };\n\n    // Cache for 30 minutes (less than chapter since it's random)\n    quizCache.set(cacheKey, result, 30 * 60 * 1000);\n\n    return result;\n}\n\n\nexport async function generateQuizAction(\n    subjectId: number,\n    chapterId: number | null,\n    difficulty: \"easy\" | \"medium\" | \"hard\" | \"exam\",\n    questionCount: number,\n    questionTypes: QuestionType[],\n    useAiFallback: boolean = true // New parameter, defaults to true for backward compatibility\n) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        let quizTitle = \"\";\n        let quizDescription = \"\";\n        let finalQuestions: any[] = [];\n\n        // STRATEGY 1: Question Bank (Priority)\n        if (chapterId) {\n            const bigChapterId = BigInt(chapterId);\n\n            // Build query filter\n            const whereClause: any = {\n                chapter_id: bigChapterId,\n                is_active: true,\n            };\n\n            // If difficulty is \"exam\", ONLY fetch exam questions and ignore types\n            if (difficulty === \"exam\") {\n                whereClause.difficulty = \"exam\";\n                // We intentionally ignore questionTypes for exam mode to get all available past paper questions\n            } else {\n                // Normal mode: filter by selected types and difficulty + exam questions\n                whereClause.question_type = { in: questionTypes };\n                // Include both selected difficulty AND exam questions (as they are high quality)\n                whereClause.difficulty = { in: [difficulty, \"exam\"] };\n            }\n\n            let availableQuestions = await prisma.question.findMany({\n                where: whereClause,\n                select: { id: true }\n            });\n\n            // For Exam Mode, we strictly require questions from the bank\n            if (difficulty === \"exam\") {\n                if (availableQuestions.length === 0) {\n                    throw new Error(\"No exam questions found for this chapter. Please upload past papers first.\");\n                }\n                // Use all found questions (up to limit)\n                console.log(`[QUIZ-GEN] Found ${availableQuestions.length} exam questions.`);\n            }\n\n            // FALLBACK STRATEGY: If strict mode (no AI) and not enough questions, try ANY difficulty\n            // This block is only relevant for non-exam difficulties if useAiFallback is false\n            if (difficulty !== \"exam\" && availableQuestions.length < questionCount && !useAiFallback) {\n                console.log(`[QUIZ-GEN] Not enough ${difficulty} questions. Trying ALL difficulties from bank...`);\n                const allDifficultyQuestions = await prisma.question.findMany({\n                    where: {\n                        chapter_id: bigChapterId,\n                        question_type: { in: questionTypes },\n                        is_active: true\n                    },\n                    select: { id: true }\n                });\n                // Add unique ones\n                const existingIds = new Set(availableQuestions.map(q => q.id));\n                for (const q of allDifficultyQuestions) {\n                    if (!existingIds.has(q.id)) {\n                        availableQuestions.push(q);\n                        existingIds.add(q.id);\n                    }\n                }\n            }\n\n            if (availableQuestions.length >= questionCount || (difficulty === \"exam\" && availableQuestions.length > 0)) {\n                console.log(`[QUIZ-GEN] Found ${availableQuestions.length} questions in bank for chapter ${chapterId}. Using Bank.`);\n\n                // Randomly select IDs\n                const shuffled = availableQuestions.sort(() => 0.5 - Math.random());\n                const selectedIds = shuffled.slice(0, questionCount).map(q => q.id);\n\n                // Fetch full question details\n                const questions = await prisma.question.findMany({\n                    where: { id: { in: selectedIds } }\n                });\n\n                finalQuestions = questions.map(q => ({\n                    question_text: q.question_text,\n                    question_type: q.question_type,\n                    options: q.options ? (q.options as any) : undefined,\n                    correct_answer: q.correct_answer,\n                    points: q.points,\n                    explanation: q.explanation || \"Correct answer\",\n                }));\n\n                const chapter = await prisma.chapter.findUnique({\n                    where: { id: bigChapterId },\n                    select: { title: true }\n                });\n\n                quizTitle = `${chapter?.title || 'Chapter'} Quiz`;\n                quizDescription = `A ${difficulty} difficulty quiz on ${chapter?.title}`;\n            } else {\n                console.log(`[QUIZ-GEN] Not enough questions in bank (${availableQuestions.length}/${questionCount}).`);\n\n                if (!useAiFallback) {\n                    throw new Error(`Not enough questions in the Question Bank for this chapter. Found ${availableQuestions.length}, needed ${questionCount}. Please contact admin.`);\n                }\n\n                console.log(`[QUIZ-GEN] Falling back to AI.`);\n            }\n        }\n\n        // STRATEGY 2: AI Generation (Fallback or Subject-level)\n        if (finalQuestions.length === 0) {\n            if (!useAiFallback) {\n                throw new Error(\"AI generation is disabled for this request (Battle Mode). Please select a chapter with existing questions.\");\n            }\n\n            // 1. Fetch Context (with caching)\n            let context = \"\";\n            let topicName = \"\";\n            let boardName = \"\";\n            let levelName = \"\";\n\n            const subject = await prisma.subject.findUnique({\n                where: { id: subjectId },\n                select: { name: true },\n            });\n            if (!subject) throw new Error(\"Subject not found\");\n            const subjectName = subject.name;\n\n            if (chapterId) {\n                const chapterData = await getChapterContext(chapterId);\n                topicName = chapterData.title;\n                context = chapterData.context;\n                boardName = chapterData.board || \"\";\n                levelName = chapterData.level || \"\";\n            } else {\n                topicName = \"General Review\";\n                const subjectData = await getSubjectContext(subjectId);\n                context = subjectData.context;\n                boardName = subjectData.board || \"\";\n                levelName = subjectData.level || \"\";\n            }\n\n            // Early validation\n            if (!context || context.trim().length < 200) {\n                throw new Error(\"Insufficient content available for quiz generation. Please ensure the chapter has content.\");\n            }\n\n            // 2. Generate Quiz via AI\n            const config: QuizGenerationConfig = {\n                subject: subjectName,\n                topic: topicName,\n                difficulty: difficulty as any, // Cast to any since AI service might not strictly type \"exam\" yet\n                questionCount,\n                questionTypes: questionTypes as any, // Cast to match AI service types\n                context,\n            };\n\n            const aiQuiz = await generateQuiz(config, {\n                board: boardName,\n                level: levelName\n            });\n            finalQuestions = aiQuiz.questions;\n            quizTitle = aiQuiz.title;\n            quizDescription = aiQuiz.description;\n\n            // OPTIONAL: We could save these to the Question Bank here for future use!\n            // But for now, we'll keep the existing behavior for AI generation.\n        }\n\n        // 3. Save to DB\n        const quiz = await prisma.quiz.create({\n            data: {\n                user_id: userId,\n                subject_id: subjectId,\n                chapter_id: chapterId ? BigInt(chapterId) : null,\n                title: quizTitle,\n                description: quizDescription,\n                total_points: finalQuestions.reduce((sum, q) => sum + q.points, 0),\n                questions: {\n                    create: finalQuestions.map(q => ({\n                        question_text: q.question_text,\n                        question_type: q.question_type as QuestionType,\n                        options: q.options ? q.options : undefined,\n                        correct_answer: q.correct_answer,\n                        points: q.points,\n                        explanation: q.explanation,\n                    })),\n                },\n            },\n            include: {\n                questions: true,\n            },\n        });\n\n        // Serialize BigInt for client\n        return {\n            ...quiz,\n            chapter_id: quiz.chapter_id?.toString() || null,\n            questions: quiz.questions.map(q => ({\n                ...q,\n                // Hide correct answer and explanation for the client!\n                correct_answer: null,\n                explanation: null,\n            })),\n        };\n\n    } catch (error: any) {\n        console.error(\"Error in generateQuizAction:\", error);\n        throw new Error(error.message || \"Failed to generate quiz\");\n    }\n}\n\nexport async function submitQuizAction(\n    quizId: string,\n    answers: Record<string, any> // questionId -> answer\n) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        const quiz = await prisma.quiz.findUnique({\n            where: { id: quizId },\n            include: { questions: true },\n        });\n\n        if (!quiz) throw new Error(\"Quiz not found\");\n        if (quiz.user_id !== userId) throw new Error(\"Unauthorized\");\n        if (quiz.status === \"COMPLETED\") {\n            return { success: true, score: quiz.score, totalPoints: quiz.total_points };\n        }\n\n        let totalScore = 0;\n        const updates = [];\n        const questionsToGrade = [];\n\n        for (const question of quiz.questions) {\n            const userAnswer = answers[question.id];\n            let isCorrect = false;\n            let pointsAwarded = 0;\n            let feedback = null;\n\n            if ([\"SHORT_ANSWER\", \"LONG_ANSWER\"].includes(question.question_type)) {\n                // Defer to AI grading\n                questionsToGrade.push({\n                    id: question.id,\n                    question_text: question.question_text,\n                    user_answer: String(userAnswer),\n                    correct_answer: String(question.correct_answer),\n                    type: question.question_type,\n                    max_points: question.points,\n                });\n                continue; // Skip immediate update\n            } else {\n                // Auto-grade objective questions\n                // Handle various answer formats: string vs array vs mixed\n\n                const correctAnswer = question.correct_answer;\n                const userAnswerNormalized = userAnswer;\n                const correctAnswerNormalized = correctAnswer;\n\n                // Normalize to arrays for comparison\n                const userArray = Array.isArray(userAnswerNormalized) ? userAnswerNormalized : [userAnswerNormalized];\n                const correctArray = Array.isArray(correctAnswerNormalized) ? correctAnswerNormalized : [correctAnswerNormalized];\n\n                // Compare as sets (order-independent, handles both single and multi-select)\n                const correctSet = new Set(correctArray.map((a: any) => String(a).trim()));\n                const userSet = new Set(userArray.map((a: any) => String(a).trim()));\n\n                // Check if sets are equal (works for single-select AND multi-select)\n                if (correctSet.size === userSet.size &&\n                    [...correctSet].every(item => userSet.has(item))) {\n                    isCorrect = true;\n                    pointsAwarded = question.points;\n                }\n            }\n\n            totalScore += pointsAwarded;\n            updates.push(\n                prisma.quizQuestion.update({\n                    where: { id: question.id },\n                    data: {\n                        user_answer: userAnswer,\n                        is_correct: isCorrect,\n                    },\n                })\n            );\n        }\n\n        // Run AI grading if needed\n        if (questionsToGrade.length > 0) {\n            const grades = await gradeQuiz(questionsToGrade);\n\n            for (const grade of grades) {\n                // Find original question to get ID and max points\n                // The gradeQuiz returns array in same order or we need to match by text?\n                // Better to pass ID through gradeQuiz or match by text.\n                // gradeQuiz returns { question_text, is_correct, score_percentage, feedback }\n\n                const originalQ = questionsToGrade.find(q => q.question_text === grade.question_text);\n                if (originalQ) {\n                    const points = Math.round((grade.score_percentage / 100) * originalQ.max_points);\n                    totalScore += points;\n\n                    updates.push(\n                        prisma.quizQuestion.update({\n                            where: { id: originalQ.id },\n                            data: {\n                                user_answer: originalQ.user_answer,\n                                is_correct: grade.is_correct,\n                                feedback: grade.feedback,\n                            },\n                        })\n                    );\n                }\n            }\n        }\n\n        // Execute all question updates\n        await prisma.$transaction(updates);\n\n        // Update Quiz status and score\n        const updatedQuiz = await prisma.quiz.update({\n            where: { id: quizId },\n            data: {\n                status: \"COMPLETED\",\n                score: totalScore,\n                completed_at: new Date(),\n            },\n        });\n\n        // Award User Points\n        if (totalScore > 0) {\n            await prisma.userPoints.create({\n                data: {\n                    user_id: userId,\n                    points: totalScore,\n                    reason: \"quiz_completion\",\n                    metadata: { quiz_id: quizId, title: quiz.title },\n                },\n            });\n\n            // Check for streak badges\n            // We need to calculate streak AFTER adding the new point (activity)\n            // But calculateStreak checks DB, so it should be fine.\n            // Wait, calculateStreak checks created_at. The point we just added has now().\n            // So it counts as today's activity.\n\n            // Import dynamically to avoid circular deps if any (though unlikely here)\n            const { calculateStreak, checkAndAwardBadges } = await import(\"@/lib/streak-service\");\n            const currentStreak = await calculateStreak(userId);\n            await checkAndAwardBadges(userId, currentStreak);\n        }\n\n        return { success: true, score: totalScore, totalPoints: quiz.total_points };\n\n    } catch (error) {\n        console.error(\"Error submitting quiz:\", error);\n        throw new Error(\"Failed to submit quiz\");\n    }\n}\n\nexport async function getLeaderboardAction(limit = 10) {\n    try {\n        // Aggregate points by user\n        const leaderboard = await prisma.userPoints.groupBy({\n            by: ['user_id'],\n            _sum: {\n                points: true,\n            },\n            orderBy: {\n                _sum: {\n                    points: 'desc',\n                },\n            },\n            take: limit,\n        });\n\n        // Fetch user details\n        const userIds = leaderboard.map(l => l.user_id);\n        const users = await prisma.user.findMany({\n            where: { id: { in: userIds } },\n            select: { id: true, username: true }, // Add avatar if available\n        });\n\n        // Combine data\n        return leaderboard.map(entry => {\n            const user = users.find(u => u.id === entry.user_id);\n            return {\n                userId: entry.user_id,\n                username: user?.username || \"Unknown User\",\n                points: entry._sum.points || 0,\n            };\n        });\n\n    } catch (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        throw new Error(\"Failed to fetch leaderboard\");\n    }\n}\n\nexport async function getUserStatsAction() {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        // Get user's total points\n        const userPointsResult = await prisma.userPoints.aggregate({\n            where: { user_id: userId },\n            _sum: { points: true },\n        });\n        const totalPoints = userPointsResult._sum.points || 0;\n\n        // Get quiz count\n        const quizCount = await prisma.quiz.count({\n            where: { user_id: userId, status: \"COMPLETED\" },\n        });\n\n        // Get average score\n        const quizzes = await prisma.quiz.findMany({\n            where: { user_id: userId, status: \"COMPLETED\" },\n            select: { score: true, total_points: true },\n        });\n        const avgPercentage = quizzes.length > 0\n            ? quizzes.reduce((sum, q) => sum + (q.score / q.total_points) * 100, 0) / quizzes.length\n            : 0;\n\n        // Calculate user's rank\n        const allUserPoints = await prisma.userPoints.groupBy({\n            by: ['user_id'],\n            _sum: { points: true },\n            orderBy: { _sum: { points: 'desc' } },\n        });\n        const userRank = allUserPoints.findIndex(entry => entry.user_id === userId) + 1;\n\n        // Get recent point history\n        const recentPoints = await prisma.userPoints.findMany({\n            where: { user_id: userId },\n            orderBy: { created_at: 'desc' },\n            take: 10,\n            select: {\n                points: true,\n                reason: true,\n                created_at: true,\n                metadata: true,\n            },\n        });\n\n        return {\n            totalPoints,\n            rank: userRank || null,\n            quizCount,\n            avgScore: Math.round(avgPercentage),\n            recentPoints: recentPoints.map(p => ({\n                ...p,\n                created_at: p.created_at.toISOString(),\n            })),\n        };\n    } catch (error) {\n        console.error(\"Error fetching user stats:\", error);\n        throw new Error(\"Failed to fetch user stats\");\n    }\n}\n\nexport async function getQuizHistory() {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        return null;\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        const quizzes = await prisma.quiz.findMany({\n            where: {\n                user_id: userId,\n                status: QuizStatus.COMPLETED,\n            },\n            include: {\n                subject: { select: { name: true } },\n                chapter: { select: { title: true } },\n            },\n            orderBy: { completed_at: 'desc' },\n        });\n\n        return quizzes;\n    } catch (error) {\n        console.error(\"Error fetching quiz history:\", error);\n        throw new Error(\"Failed to fetch quiz history\");\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}