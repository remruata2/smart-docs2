{"version":3,"sources":["../../../../src/lib/file-validation.ts","../../../../src/app/app/files/actions.ts"],"sourcesContent":["/**\n * File validation utilities for secure file uploads\n * Validates file types using magic bytes, not just extensions\n */\n\nimport { fileTypeFromBuffer } from \"file-type\";\n\n// Allowed file types mapped by category\nexport const ALLOWED_FILE_TYPES: Record<string, { mimeTypes: readonly string[]; extensions: readonly string[] }> = {\n    documents: {\n        mimeTypes: [\n            \"application/pdf\",\n            \"application/msword\",\n            \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"text/plain\",\n            \"text/markdown\",\n        ],\n        extensions: [\"pdf\", \"doc\", \"docx\", \"txt\", \"md\"],\n    },\n    images: {\n        mimeTypes: [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"],\n        extensions: [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\"],\n    },\n};\nexport type FileCategory = keyof typeof ALLOWED_FILE_TYPES;\n\nexport interface FileValidationResult {\n    valid: boolean;\n    error?: string;\n    detectedType?: {\n        mime: string;\n        ext: string;\n    };\n}\n\n/**\n * Validates a file using magic bytes detection\n * This is more secure than checking file extension alone\n */\nexport async function validateFileType(\n    buffer: Buffer,\n    allowedCategory: FileCategory = \"documents\",\n    originalFilename?: string\n): Promise<FileValidationResult> {\n    const allowedConfig = ALLOWED_FILE_TYPES[allowedCategory];\n\n    // Detect file type from magic bytes\n    const detectedType = await fileTypeFromBuffer(buffer);\n\n    // Handle text-based files that don't have magic bytes\n    // (txt, md, and some other text files)\n    if (!detectedType) {\n        const ext = originalFilename?.split(\".\").pop()?.toLowerCase();\n        if (ext && [\"txt\", \"md\"].includes(ext)) {\n            // Check if content appears to be text\n            const isText = isPlainText(buffer);\n            if (isText) {\n                return {\n                    valid: true,\n                    detectedType: {\n                        mime: ext === \"md\" ? \"text/markdown\" : \"text/plain\",\n                        ext: ext,\n                    },\n                };\n            }\n        }\n        return {\n            valid: false,\n            error: \"Unable to determine file type. The file may be corrupted or empty.\",\n        };\n    }\n\n    // Check if detected MIME type is allowed\n    if (!allowedConfig.mimeTypes.includes(detectedType.mime)) {\n        return {\n            valid: false,\n            error: `File type \"${detectedType.mime}\" is not allowed. Allowed types: ${allowedConfig.extensions.join(\", \")}`,\n            detectedType: {\n                mime: detectedType.mime,\n                ext: detectedType.ext,\n            },\n        };\n    }\n\n    // Verify file extension matches detected type (prevent extension spoofing)\n    if (originalFilename) {\n        const declaredExt = originalFilename.split(\".\").pop()?.toLowerCase();\n        if (declaredExt && !allowedConfig.extensions.includes(declaredExt)) {\n            return {\n                valid: false,\n                error: `File extension \".${declaredExt}\" is not allowed. Detected type: ${detectedType.mime}`,\n                detectedType: {\n                    mime: detectedType.mime,\n                    ext: detectedType.ext,\n                },\n            };\n        }\n    }\n\n    return {\n        valid: true,\n        detectedType: {\n            mime: detectedType.mime,\n            ext: detectedType.ext,\n        },\n    };\n}\n\n/**\n * Check if buffer appears to contain plain text\n */\nfunction isPlainText(buffer: Buffer): boolean {\n    // Check first 8KB for binary content\n    const sampleSize = Math.min(buffer.length, 8192);\n    for (let i = 0; i < sampleSize; i++) {\n        const byte = buffer[i];\n        // Check for null bytes or other non-printable characters\n        // Allow common whitespace characters\n        if (byte === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Maximum file size in bytes (50MB)\n */\nexport const MAX_FILE_SIZE = 50 * 1024 * 1024;\n\n/**\n * Validates file size\n */\nexport function validateFileSize(\n    size: number,\n    maxSize: number = MAX_FILE_SIZE\n): FileValidationResult {\n    if (size > maxSize) {\n        const maxMB = Math.round(maxSize / 1024 / 1024);\n        return {\n            valid: false,\n            error: `File size exceeds maximum allowed size of ${maxMB}MB`,\n        };\n    }\n    return { valid: true };\n}\n","\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { getServerSession } from \"next-auth/next\";\nimport { authOptions } from \"@/lib/auth-options\";\nimport { revalidatePath } from \"next/cache\";\nimport { z } from \"zod\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { existsSync, mkdirSync } from \"fs\";\nimport { SemanticVectorService } from \"../../../lib/semantic-vector\";\nimport {\n\tvalidateFileType,\n\tvalidateFileSize,\n\tMAX_FILE_SIZE,\n} from \"@/lib/file-validation\";\n\n// Upload directory configuration\nconst UPLOAD_DIR = path.join(process.cwd(), \"public\", \"uploads\", \"documents\");\n\nfunction ensureUploadDirExists() {\n\tif (!existsSync(UPLOAD_DIR)) {\n\t\tmkdirSync(UPLOAD_DIR, { recursive: true });\n\t}\n}\n\n// Pagination + filtering types\nexport type GetFilesParams = {\n\tpage?: number;\n\tpageSize?: number;\n\tq?: string;\n\tcategory?: string;\n\tyear?: number; // calendar year from entry_date_real\n};\n\nexport type FileListEntry = {\n\tid: number;\n\tcategory: string;\n\ttitle: string;\n\tentry_date_real: string | null;\n\tcreated_at: string | null;\n\tdoc1: string | null;\n\tparsing_status: string | null;\n\tparsing_error: string | null;\n\tparsed_at: string | null;\n};\n\nexport type PaginatedFiles = {\n\titems: FileListEntry[];\n\ttotal: number;\n\tpage: number;\n\tpageSize: number;\n};\n\n// Server-side pagination + filtering for files list\nexport async function getFilesPaginated(\n\tparams: GetFilesParams = {}\n): Promise<PaginatedFiles> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn { items: [], total: 0, page: 1, pageSize: 50 };\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\tconst page = Math.max(1, params.page ?? 1);\n\tconst pageSize = Math.min(200, Math.max(1, params.pageSize ?? 50));\n\n\t// Build where clause\n\tconst where: any = {\n\t\tuser_id: userId,\n\t};\n\n\tif (params.category && params.category.trim() !== \"\") {\n\t\twhere.category = params.category;\n\t}\n\n\t// Year filter -> between Jan 1 and Dec 31\n\tif (params.year && Number.isFinite(params.year)) {\n\t\tconst y = params.year;\n\t\tconst start = new Date(Date.UTC(y, 0, 1));\n\t\tconst end = new Date(Date.UTC(y + 1, 0, 1));\n\t\twhere.entry_date_real = {\n\t\t\tgte: start,\n\t\t\tlt: end,\n\t\t};\n\t}\n\n\t// Simple text search across title, category (case-insensitive)\n\tif (params.q && params.q.trim() !== \"\") {\n\t\tconst q = params.q.trim();\n\t\twhere.OR = [\n\t\t\t{ title: { contains: q, mode: \"insensitive\" as const } },\n\t\t\t{ category: { contains: q, mode: \"insensitive\" as const } },\n\t\t];\n\t}\n\n\ttry {\n\t\tconst [total, rows] = await Promise.all([\n\t\t\tprisma.fileList.count({ where }),\n\t\t\tprisma.fileList.findMany({\n\t\t\t\twhere,\n\t\t\t\torderBy: [{ entry_date_real: \"desc\" }, { id: \"desc\" }],\n\t\t\t\tselect: {\n\t\t\t\t\tid: true,\n\t\t\t\t\tcategory: true,\n\t\t\t\t\ttitle: true,\n\t\t\t\t\tentry_date_real: true,\n\t\t\t\t\tcreated_at: true,\n\t\t\t\t\tdoc1: true,\n\t\t\t\t\tparsing_status: true,\n\t\t\t\t\tparsing_error: true,\n\t\t\t\t\tparsed_at: true,\n\t\t\t\t},\n\t\t\t\tskip: (page - 1) * pageSize,\n\t\t\t\ttake: pageSize,\n\t\t\t}),\n\t\t]);\n\n\t\tconst items: FileListEntry[] = rows.map((file) => ({\n\t\t\t...file,\n\t\t\tentry_date_real: file.entry_date_real?.toISOString() || null,\n\t\t\tcreated_at: file.created_at?.toISOString() || null,\n\t\t\tparsed_at: file.parsed_at?.toISOString() || null,\n\t\t}));\n\n\t\treturn { items, total, page, pageSize };\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching paginated files:\", error);\n\t\tconsole.error(\n\t\t\t\"Error details:\",\n\t\t\terror instanceof Error ? error.message : String(error)\n\t\t);\n\t\tconsole.error(\n\t\t\t\"Error stack:\",\n\t\t\terror instanceof Error ? error.stack : \"No stack\"\n\t\t);\n\t\tthrow new Error(\n\t\t\t`Failed to fetch files: ${error instanceof Error ? error.message : String(error)\n\t\t\t}`\n\t\t);\n\t}\n}\n\nexport type FileFilterOptions = {\n\tcategories: string[];\n\tyears: number[];\n};\n\nexport async function getFilterOptions(): Promise<FileFilterOptions> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn { categories: [], years: [] };\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\ttry {\n\t\t// Distinct categories via raw SQL\n\t\tconst categoriesRows: Array<{ category: string | null }> =\n\t\t\tawait prisma.$queryRaw`\n      SELECT DISTINCT category\n      FROM file_list\n      WHERE category IS NOT NULL AND category <> '' AND user_id = ${userId}\n      ORDER BY category ASC\n    `;\n\t\tconst categories = categoriesRows\n\t\t\t.map((r) => r.category)\n\t\t\t.filter((c): c is string => typeof c === \"string\" && c.trim() !== \"\");\n\n\t\t// Distinct years via raw SQL\n\t\tconst yearsRows: Array<{ year: number | null }> = await prisma.$queryRaw`\n      SELECT DISTINCT EXTRACT(YEAR FROM entry_date_real)::int AS year\n      FROM file_list\n      WHERE entry_date_real IS NOT NULL AND user_id = ${userId}\n      ORDER BY year DESC\n    `;\n\t\tconst years = yearsRows\n\t\t\t.map((r) => (typeof r.year === \"number\" ? r.year : null))\n\t\t\t.filter((y): y is number => y !== null);\n\n\t\treturn { categories, years };\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching filter options:\", error);\n\t\treturn { categories: [], years: [] };\n\t}\n}\n\n// Comprehensive HTML to plain text conversion for AI consumption\nfunction htmlToPlainText(html: string | null | undefined): string | null {\n\tif (!html) return null;\n\n\tlet text = html;\n\ttext = text.replace(/<br\\s*\\/?>/gi, \"\\n\");\n\ttext = text.replace(/<\\/?(p|div)[^>]*>/gi, \"\\n\\n\");\n\ttext = text.replace(/<li[^>]*>/gi, \"\\n• \");\n\ttext = text.replace(/<\\/li>/gi, \"\");\n\ttext = text.replace(/<[^>]+>/g, \"\");\n\n\t// Decode HTML entities (simplified for brevity, can reuse full map if needed)\n\ttext = text.replace(/&nbsp;/g, \" \");\n\ttext = text.replace(/&amp;/g, \"&\");\n\ttext = text.replace(/&lt;/g, \"<\");\n\ttext = text.replace(/&gt;/g, \">\");\n\ttext = text.replace(/&quot;/g, '\"');\n\n\ttext = text.replace(/[ \\t]+/g, \" \");\n\ttext = text.replace(/\\n\\s*\\n\\s*\\n/g, \"\\n\\n\");\n\ttext = text.replace(/^\\s+|\\s+$/g, \"\");\n\ttext = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n\n\treturn text || null;\n}\n\nconst imagePlaceholder = \"[Image removed - please upload images separately]\";\n\nconst removeImagePlaceholder = (content: string | null | undefined): string => {\n\tif (!content) return \"\";\n\treturn content\n\t\t.replace(\n\t\t\tnew RegExp(\n\t\t\t\timagePlaceholder.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"),\n\t\t\t\t\"g\"\n\t\t\t),\n\t\t\t\"\"\n\t\t)\n\t\t.trim();\n};\n\n// Zod schema for file validation\nconst fileSchema = z.object({\n\tcategory: z\n\t\t.string()\n\t\t.max(500, { message: \"Category must be 500 characters or less\" })\n\t\t.optional(), // Optional - required per-file for uploads, or for manual entry\n\ttitle: z\n\t\t.string()\n\t\t.max(500, { message: \"Title must be 500 characters or less\" })\n\t\t.optional(), // Optional - will be generated from filename if not provided\n\tnote: z.string().optional(),\n\tentry_date: z.string().optional().nullable(),\n\tcontent_format: z.enum([\"html\", \"markdown\"]).optional(),\n});\n\nexport type FileDetail = {\n\tid: number;\n\tcategory: string;\n\ttitle: string;\n\tnote: string | null;\n\tdoc1: string | null;\n\tentry_date: string | null;\n\tentry_date_real: string | null;\n\tcreated_at: string | null;\n\tupdated_at: string | null;\n\tcontent_format?: \"html\" | \"markdown\";\n};\n\ntype PrismaFileSelectResult = {\n\tid: number;\n\tcategory: string;\n\ttitle: string;\n\tnote: string | null;\n\tcontent_format: string | null;\n\tdoc1: string | null;\n\tentry_date: string | null;\n\tentry_date_real: Date | null;\n\tcreated_at: Date | null;\n\tupdated_at: Date | null;\n};\n\nexport async function getFileById(id: number): Promise<FileDetail | null> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn null;\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\ttry {\n\t\tconst file = await prisma.fileList.findFirst({\n\t\t\twhere: {\n\t\t\t\tid,\n\t\t\t\tuser_id: userId,\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tid: true,\n\t\t\t\tcategory: true,\n\t\t\t\ttitle: true,\n\t\t\t\tnote: true,\n\t\t\t\tcontent_format: true,\n\t\t\t\tdoc1: true,\n\t\t\t\tentry_date: true,\n\t\t\t\tentry_date_real: true,\n\t\t\t\tcreated_at: true,\n\t\t\t\tupdated_at: true,\n\t\t\t},\n\t\t});\n\t\tif (!file) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst selectedFile = file as PrismaFileSelectResult;\n\n\t\treturn {\n\t\t\tid: selectedFile.id,\n\t\t\tcategory: selectedFile.category,\n\t\t\ttitle: selectedFile.title,\n\t\t\tnote: selectedFile.note,\n\t\t\tcontent_format: selectedFile.content_format as\n\t\t\t\t| \"html\"\n\t\t\t\t| \"markdown\"\n\t\t\t\t| undefined,\n\t\t\tdoc1: selectedFile.doc1,\n\t\t\tentry_date: selectedFile.entry_date,\n\t\t\tentry_date_real:\n\t\t\t\tselectedFile.entry_date_real?.toISOString().split(\"T\")[0] || \"\",\n\t\t\tcreated_at: selectedFile.created_at?.toISOString() || null,\n\t\t\tupdated_at: selectedFile.updated_at?.toISOString() || null,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(`Error fetching file with id ${id}:`, error);\n\t\tthrow new Error(\"Failed to fetch file details.\");\n\t}\n}\n\nexport type ActionResponse = {\n\tsuccess: boolean;\n\tmessage?: string;\n\terror?: string;\n\tfieldErrors?: Record<string, string[] | undefined>;\n};\n\nexport async function createFileAction(\n\tformData: FormData\n): Promise<ActionResponse> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn { success: false, error: \"Unauthorized\" };\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\t// Check usage limit before upload\n\tconst { enforceUsageLimit, checkUsageLimit } = await import(\n\t\t\"@/lib/usage-limits\"\n\t);\n\tconst { UsageType } = await import(\"@/generated/prisma\");\n\n\t// First check if user has any remaining uploads\n\tconst limitCheck = await checkUsageLimit(UsageType.file_upload, userId);\n\tif (!limitCheck.allowed) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: limitCheck.reason || \"Usage limit exceeded\",\n\t\t};\n\t}\n\n\t// Enforce the limit (this will throw if limit exceeded)\n\tconst enforceCheck = await enforceUsageLimit(UsageType.file_upload, userId);\n\tif (!enforceCheck.success) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: enforceCheck.error || \"Usage limit exceeded\",\n\t\t};\n\t}\n\n\tensureUploadDirExists();\n\n\tconst file = formData.get(\"doc1\") as File | null;\n\tconst rawFormData = Object.fromEntries(formData.entries());\n\tif (file && file.size === 0) {\n\t\tdelete rawFormData.doc1;\n\t}\n\n\tconst validatedFields = fileSchema.safeParse(rawFormData);\n\n\tif (!validatedFields.success) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Validation failed. Please check the fields.\",\n\t\t\tfieldErrors: validatedFields.error.flatten().fieldErrors,\n\t\t};\n\t}\n\n\tlet doc1Path: string | null = null;\n\tconst finalNote = removeImagePlaceholder(validatedFields.data.note);\n\n\tif (file && file.size > 0) {\n\t\ttry {\n\t\t\tconst buffer = Buffer.from(await file.arrayBuffer());\n\n\t\t\t// SECURITY: Validate file size\n\t\t\tconst sizeValidation = validateFileSize(buffer.length, MAX_FILE_SIZE);\n\t\t\tif (!sizeValidation.valid) {\n\t\t\t\treturn { success: false, error: sizeValidation.error || \"File too large\" };\n\t\t\t}\n\n\t\t\t// SECURITY: Validate file type using magic bytes\n\t\t\tconst typeValidation = await validateFileType(\n\t\t\t\tbuffer,\n\t\t\t\t\"documents\",\n\t\t\t\tfile.name\n\t\t\t);\n\t\t\tif (!typeValidation.valid) {\n\t\t\t\treturn { success: false, error: typeValidation.error || \"Invalid file type\" };\n\t\t\t}\n\n\t\t\tconst sanitizedOriginalName = file.name.replace(/[^a-zA-Z0-9._-]/g, \"_\");\n\n\t\t\t// Generate unique filename to prevent duplicates\n\t\t\tlet filename: string;\n\t\t\tlet filePath: string;\n\t\t\tlet attempts = 0;\n\t\t\tconst maxAttempts = 10;\n\n\t\t\tdo {\n\t\t\t\tconst uniqueSuffix = Date.now() + \"-\" + Math.round(Math.random() * 1e9);\n\t\t\t\tfilename = uniqueSuffix + \"-\" + sanitizedOriginalName;\n\t\t\t\tfilePath = path.join(UPLOAD_DIR, filename);\n\t\t\t\tattempts++;\n\n\t\t\t\t// Check if file already exists\n\t\t\t\tif (existsSync(filePath)) {\n\t\t\t\t\tif (attempts >= maxAttempts) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Unable to generate unique filename after multiple attempts\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// Wait a tiny bit and try again with new timestamp\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 1));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} while (attempts < maxAttempts);\n\n\t\t\tawait fs.writeFile(filePath, buffer);\n\t\t\tdoc1Path = `/uploads/documents/${filename}`;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error uploading file:\", error);\n\t\t\treturn { success: false, error: \"File upload failed. Please try again.\" };\n\t\t}\n\t}\n\n\t// ... existing code ...\n\tconst { note, entry_date, content_format, ...restOfData } =\n\t\tvalidatedFields.data;\n\n\t// Remove district if it exists (legacy field, no longer in schema)\n\tconst { district, ...cleanRestOfData } = restOfData as any;\n\n\tconst contentFormat =\n\t\tcontent_format ?? (file && file.size > 0 ? \"markdown\" : \"html\");\n\n\tlet entryDateReal: Date | null = null;\n\tif (entry_date && entry_date.trim() !== \"\") {\n\t\tconst parsedDate = new Date(entry_date);\n\t\tif (!isNaN(parsedDate.getTime())) {\n\t\t\tentryDateReal = parsedDate;\n\t\t}\n\t}\n\n\t// Generate title from filename if not provided (for file uploads)\n\tlet fileTitle = cleanRestOfData.title;\n\tif (!fileTitle && file && file.size > 0) {\n\t\t// Remove extension from filename\n\t\tfileTitle = file.name.replace(/\\.[^/.]+$/, \"\");\n\t}\n\t// For manual entry, title is required (enforced by frontend validation)\n\n\t// Category is required - should be provided per-file for uploads or in form for manual entry\n\tconst fileCategory = cleanRestOfData.category;\n\tif (!fileCategory || fileCategory.trim().length === 0) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Category is required\",\n\t\t\tfieldErrors: {\n\t\t\t\tcategory: [\"Category is required\"],\n\t\t\t},\n\t\t};\n\t}\n\n\ttry {\n\t\t// Determine parsing status: if file is uploaded, set to pending; otherwise completed (manual entry)\n\t\tconst parsingStatus = file && file.size > 0 ? \"pending\" : \"completed\";\n\n\t\t// Use transaction to ensure atomicity of file creation and usage tracking\n\t\tconst newFile = await prisma.$transaction(async (tx) => {\n\t\t\t// Create the file record with user_id (exclude district as it no longer exists)\n\t\t\tconst createdFile = await tx.fileList.create({\n\t\t\t\tdata: {\n\t\t\t\t\t...cleanRestOfData,\n\t\t\t\t\ttitle: fileTitle || \"Untitled\", // Fallback to \"Untitled\" if somehow still missing\n\t\t\t\t\tcategory: fileCategory, // Use the provided category\n\t\t\t\t\tnote: finalNote,\n\t\t\t\t\tcontent_format: contentFormat,\n\t\t\t\t\tdoc1: doc1Path,\n\t\t\t\t\tentry_date: entry_date,\n\t\t\t\t\tentry_date_real: entryDateReal,\n\t\t\t\t\tuser_id: userId,\n\t\t\t\t\tparsing_status: parsingStatus,\n\t\t\t\t\t// If manual entry (no file), mark as parsed immediately\n\t\t\t\t\tparsed_at: parsingStatus === \"completed\" ? new Date() : null,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Update search_vector with metadata (title, category, note) - this is fine to do immediately\n\t\t\tawait tx.$executeRaw`\n        UPDATE file_list\n        SET search_vector = to_tsvector('english',\n          COALESCE('Title: ' || title, '') || ' | ' ||\n          COALESCE('Category: ' || category, '') || ' | ' ||\n          COALESCE('Content: ' || ${finalNote}, '') || ' | ' ||\n          COALESCE(entry_date, '') || ' ' ||\n          COALESCE(EXTRACT(YEAR FROM entry_date_real)::text, '')\n        )\n        WHERE id = ${createdFile.id}\n      `;\n\n\t\t\t// Track file upload usage when file is created (not after parsing)\n\t\t\t// This must be in the transaction to ensure consistency\n\t\t\t// This ensures limits are enforced immediately\n\t\t\ttry {\n\t\t\t\tconst { trackUsage } = await import(\"@/lib/usage-tracking\");\n\t\t\t\tconst { UsageType } = await import(\"@/generated/prisma\");\n\t\t\t\tawait trackUsage(userId, UsageType.file_upload);\n\t\t\t} catch (trackingError) {\n\t\t\t\tconsole.error(\"Usage tracking failed:\", trackingError);\n\t\t\t\t// Don't fail the transaction if tracking fails, but log it\n\t\t\t}\n\n\t\t\treturn createdFile;\n\t\t});\n\n\t\t// For manual entries (no file), generate semantic vector immediately\n\t\t// For files with documents, semantic vectors will be generated during background parsing\n\t\tif (parsingStatus === \"completed\") {\n\t\t\ttry {\n\t\t\t\tawait SemanticVectorService.updateSemanticVector(newFile.id);\n\t\t\t} catch (vectorError) {\n\t\t\t\tconsole.error(\"Semantic vector update failed:\", vectorError);\n\t\t\t}\n\t\t}\n\n\t\trevalidatePath(\"/app/files\");\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `File created successfully.`,\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error creating file:\", error);\n\t\treturn { success: false, error: \"Database error: Failed to create file.\" };\n\t}\n}\n\nexport async function updateFileAction(\n\tid: number,\n\tformData: FormData\n): Promise<ActionResponse> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn { success: false, error: \"Unauthorized\" };\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\tensureUploadDirExists();\n\n\t// 1. Extract file and validate the rest of the form data\n\tconst file = formData.get(\"doc1\") as File | null;\n\tconst rawFormData = Object.fromEntries(formData.entries());\n\tif (file && file.size === 0) {\n\t\tdelete rawFormData.doc1;\n\t}\n\n\tconst validatedFields = fileSchema.safeParse(rawFormData);\n\n\tif (!validatedFields.success) {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Validation failed. Please check the fields.\",\n\t\t\tfieldErrors: validatedFields.error.flatten().fieldErrors,\n\t\t};\n\t}\n\n\t// 2. Prepare data for database update\n\tconst { note, entry_date, content_format, ...restOfData } =\n\t\tvalidatedFields.data;\n\tconst finalNote = removeImagePlaceholder(note);\n\n\tconst contentFormat =\n\t\tcontent_format ?? (file && file.size > 0 ? \"markdown\" : \"html\");\n\n\tlet entryDateReal: Date | null = null;\n\tif (entry_date && entry_date.trim() !== \"\") {\n\t\tconst parsedDate = new Date(entry_date);\n\t\tif (!isNaN(parsedDate.getTime())) {\n\t\t\tentryDateReal = parsedDate;\n\t\t}\n\t} else if (entry_date === \"\") {\n\t\tentryDateReal = null;\n\t}\n\n\tconst prismaDataForUpdate: any = {\n\t\t...restOfData,\n\t\tnote: finalNote,\n\t\tcontent_format: contentFormat,\n\t\tentry_date: entry_date,\n\t\tentry_date_real: entryDateReal,\n\t};\n\n\t// 4. Handle file upload for update\n\tif (file && file.size > 0) {\n\t\ttry {\n\t\t\tconst existingFileRecord = await prisma.fileList.findFirst({\n\t\t\t\twhere: { id, user_id: userId },\n\t\t\t\tselect: { doc1: true },\n\t\t\t});\n\n\t\t\tif (!existingFileRecord) {\n\t\t\t\treturn { success: false, error: \"File not found or unauthorized.\" };\n\t\t\t}\n\n\t\t\tif (existingFileRecord?.doc1) {\n\t\t\t\tconst oldFilePathServer = path.join(\n\t\t\t\t\tprocess.cwd(),\n\t\t\t\t\t\"public\",\n\t\t\t\t\texistingFileRecord.doc1\n\t\t\t\t);\n\t\t\t\tif (existsSync(oldFilePathServer)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait fs.unlink(oldFilePathServer);\n\t\t\t\t\t} catch (delError) {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t`Error deleting old file ${oldFilePathServer}:`,\n\t\t\t\t\t\t\tdelError\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.from(await file.arrayBuffer());\n\n\t\t\t// SECURITY: Validate file size\n\t\t\tconst sizeValidation = validateFileSize(buffer.length, MAX_FILE_SIZE);\n\t\t\tif (!sizeValidation.valid) {\n\t\t\t\treturn { success: false, error: sizeValidation.error || \"File too large\" };\n\t\t\t}\n\n\t\t\t// SECURITY: Validate file type using magic bytes\n\t\t\tconst typeValidation = await validateFileType(\n\t\t\t\tbuffer,\n\t\t\t\t\"documents\",\n\t\t\t\tfile.name\n\t\t\t);\n\t\t\tif (!typeValidation.valid) {\n\t\t\t\treturn { success: false, error: typeValidation.error || \"Invalid file type\" };\n\t\t\t}\n\n\t\t\tconst uniqueSuffix = Date.now() + \"-\" + Math.round(Math.random() * 1e9);\n\t\t\tconst sanitizedOriginalName = file.name.replace(/[^a-zA-Z0-9._-]/g, \"_\");\n\t\t\tconst filename = uniqueSuffix + \"-\" + sanitizedOriginalName;\n\t\t\tconst newFilePathOnServer = path.join(UPLOAD_DIR, filename);\n\t\t\tawait fs.writeFile(newFilePathOnServer, buffer);\n\t\t\tprismaDataForUpdate.doc1 = `/uploads/documents/${filename}`;\n\t\t\tprismaDataForUpdate.note = finalNote;\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Error uploading file during update:\", error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: \"File upload failed during update. Please try again.\",\n\t\t\t};\n\t\t}\n\t}\n\n\t// 5. Update the file record in the database\n\ttry {\n\t\t// Ensure user owns the file\n\t\tconst existing = await prisma.fileList.findFirst({\n\t\t\twhere: { id, user_id: userId },\n\t\t});\n\n\t\tif (!existing) {\n\t\t\treturn { success: false, error: \"File not found or unauthorized.\" };\n\t\t}\n\n\t\tawait prisma.fileList.update({\n\t\t\twhere: { id },\n\t\t\tdata: prismaDataForUpdate,\n\t\t});\n\n\t\t// 6. Update the search vector with metadata\n\t\tawait prisma.$executeRaw`\n      UPDATE file_list\n      SET search_vector = to_tsvector('english',\n        COALESCE('Title: ' || title, '') || ' | ' ||\n        COALESCE('Category: ' || category, '') || ' | ' ||\n        COALESCE('Content: ' || ${finalNote}, '') || ' | ' ||\n        COALESCE(entry_date, '') || ' ' ||\n        COALESCE(EXTRACT(YEAR FROM entry_date_real)::text, '')\n      )\n      WHERE id = ${id}\n    `;\n\n\t\t// 7. Generate and update semantic vector with metadata\n\t\ttry {\n\t\t\tawait SemanticVectorService.updateSemanticVector(id);\n\t\t} catch (vectorError) {\n\t\t\tconsole.error(\"❌ Semantic vector update failed:\", vectorError);\n\t\t}\n\n\t\trevalidatePath(\"/app/files\");\n\t\trevalidatePath(`/app/files/${id}/edit`);\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"File updated successfully.\",\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(`Error updating file ${id}:`, error);\n\t\treturn { success: false, error: \"Database error: Failed to update file.\" };\n\t}\n}\n\nexport async function deleteFileAction(id: number): Promise<ActionResponse> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn { success: false, error: \"Unauthorized\" };\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\ttry {\n\t\t// Ensure user owns the file\n\t\tconst existing = await prisma.fileList.findFirst({\n\t\t\twhere: { id, user_id: userId },\n\t\t});\n\n\t\tif (!existing) {\n\t\t\treturn { success: false, error: \"File not found or unauthorized.\" };\n\t\t}\n\n\t\t// Delete associated files before deleting the database record\n\t\ttry {\n\t\t\t// 1. Delete page images directory: /public/files/{fileId}/\n\t\t\tconst imagesDir = path.join(process.cwd(), \"public\", \"files\", String(id));\n\t\t\tif (existsSync(imagesDir)) {\n\t\t\t\tawait fs.rm(imagesDir, { recursive: true, force: true });\n\t\t\t\tconsole.log(`[DELETE-FILE] Deleted images directory: ${imagesDir}`);\n\t\t\t}\n\n\t\t\t// 2. Delete the uploaded document file (doc1)\n\t\t\tif (existing.doc1) {\n\t\t\t\tconst docPath = path.join(process.cwd(), \"public\", existing.doc1);\n\t\t\t\tif (existsSync(docPath)) {\n\t\t\t\t\tawait fs.unlink(docPath);\n\t\t\t\t\tconsole.log(`[DELETE-FILE] Deleted document file: ${docPath}`);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (fileError) {\n\t\t\tconsole.error(\n\t\t\t\t`[DELETE-FILE] Error deleting files for file ${id}:`,\n\t\t\t\tfileError\n\t\t\t);\n\t\t\t// Continue with database deletion even if file deletion fails\n\t\t}\n\n\t\t// 3. Delete the database record (this will cascade delete DocumentPage and FileChunk records)\n\t\tawait prisma.fileList.delete({\n\t\t\twhere: { id },\n\t\t});\n\n\t\trevalidatePath(\"/app/files\");\n\t\treturn { success: true, message: \"File deleted successfully.\" };\n\t} catch (error) {\n\t\tconsole.error(\"Error deleting file:\", error);\n\t\treturn { success: false, error: \"Database error: Failed to delete file.\" };\n\t}\n}\n\n/**\n * Retry parsing for a failed file\n */\nexport async function retryFileParsingAction(\n\tfileId: number\n): Promise<ActionResponse> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn { success: false, error: \"Unauthorized\" };\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\ttry {\n\t\t// Check if file exists and belongs to user\n\t\tconst file = await prisma.fileList.findFirst({\n\t\t\twhere: {\n\t\t\t\tid: fileId,\n\t\t\t\tuser_id: userId,\n\t\t\t},\n\t\t});\n\n\t\tif (!file) {\n\t\t\treturn { success: false, error: \"File not found or access denied.\" };\n\t\t}\n\n\t\t// Reset parsing status to pending\n\t\tawait prisma.fileList.update({\n\t\t\twhere: { id: fileId },\n\t\t\tdata: {\n\t\t\t\tparsing_status: \"pending\",\n\t\t\t\tparsing_error: null,\n\t\t\t},\n\t\t});\n\n\t\trevalidatePath(\"/app/files\");\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage:\n\t\t\t\t\"File parsing queued for retry. Processing will happen in the background.\",\n\t\t};\n\t} catch (error) {\n\t\tconsole.error(\"Error retrying file parsing:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: \"Database error: Failed to retry parsing.\",\n\t\t};\n\t}\n}\n\nexport interface CategoryListItem {\n\tid: number;\n\tcategory: string;\n}\n\nexport async function getCategoryListItems(): Promise<CategoryListItem[]> {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user?.id) {\n\t\treturn [];\n\t}\n\tconst userId = parseInt(session.user.id as string);\n\n\ttry {\n\t\tconst items = await prisma.categoryList.findMany({\n\t\t\twhere: { user_id: userId },\n\t\t\tselect: {\n\t\t\t\tid: true,\n\t\t\t\tcategory: true,\n\t\t\t},\n\t\t\torderBy: {\n\t\t\t\tcategory: \"asc\",\n\t\t\t},\n\t\t});\n\t\treturn items;\n\t} catch (error) {\n\t\tconsole.error(\"Error fetching category list items:\", error);\n\t\treturn [];\n\t}\n}\n"],"names":[],"mappings":"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"}