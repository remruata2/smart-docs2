{"version":3,"sources":["../../../../src/lib/prisma.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","turbopack:///[project]/node_modules/openid-client/package.json","../../../../src/lib/db.ts","../../../../node_modules/next/src/server/web/spec-extension/cookies.ts","../../../../node_modules/next-auth/core/types.js","../../../../node_modules/next-auth/index.js","../../../../src/lib/auth.ts","../../../../src/lib/semantic-vector.ts","../../../../src/lib/supabase.ts","../../../../src/app/actions/admin.ts","../../../../.next-internal/server/app/admin/boards/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["import { db } from \"./db\";\n\nexport const prisma = db;\nexport default prisma;\n","/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","{\"name\":\"openid-client\",\"version\":\"5.7.1\",\"description\":\"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs\",\"keywords\":[\"auth\",\"authentication\",\"basic\",\"certified\",\"client\",\"connect\",\"dynamic\",\"electron\",\"hybrid\",\"identity\",\"implicit\",\"oauth\",\"oauth2\",\"oidc\",\"openid\",\"passport\",\"relying party\",\"strategy\"],\"homepage\":\"https://github.com/panva/openid-client\",\"repository\":\"panva/openid-client\",\"funding\":{\"url\":\"https://github.com/sponsors/panva\"},\"license\":\"MIT\",\"author\":\"Filip Skokan <panva.ip@gmail.com>\",\"exports\":{\"types\":\"./types/index.d.ts\",\"import\":\"./lib/index.mjs\",\"require\":\"./lib/index.js\"},\"main\":\"./lib/index.js\",\"types\":\"./types/index.d.ts\",\"files\":[\"lib\",\"types/index.d.ts\"],\"scripts\":{\"format\":\"npx prettier --loglevel silent --write ./lib ./test ./certification ./types\",\"test\":\"mocha test/**/*.test.js\"},\"dependencies\":{\"jose\":\"^4.15.9\",\"lru-cache\":\"^6.0.0\",\"object-hash\":\"^2.2.0\",\"oidc-token-hash\":\"^5.0.3\"},\"devDependencies\":{\"@types/node\":\"^16.18.106\",\"@types/passport\":\"^1.0.16\",\"base64url\":\"^3.0.1\",\"chai\":\"^4.5.0\",\"mocha\":\"^10.7.3\",\"nock\":\"^13.5.5\",\"prettier\":\"^2.8.8\",\"readable-mock-req\":\"^0.2.2\",\"sinon\":\"^9.2.4\",\"timekeeper\":\"^2.3.1\"},\"standard-version\":{\"scripts\":{\"postchangelog\":\"sed -i '' -e 's/### \\\\[/## [/g' CHANGELOG.md\"},\"types\":[{\"type\":\"feat\",\"section\":\"Features\"},{\"type\":\"fix\",\"section\":\"Fixes\"},{\"type\":\"chore\",\"hidden\":true},{\"type\":\"docs\",\"hidden\":true},{\"type\":\"style\",\"hidden\":true},{\"type\":\"refactor\",\"section\":\"Refactor\",\"hidden\":false},{\"type\":\"perf\",\"section\":\"Performance\",\"hidden\":false},{\"type\":\"test\",\"hidden\":true}]}}","import { PrismaClient } from '../generated/prisma';\n\n// Define the global type for PrismaClient\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\n// PrismaClient is attached to the `global` object in development to prevent\n// exhausting your database connection limit.\nexport const db = global.prisma || new PrismaClient();\n\n// In development, keep the connection alive between hot reloads\nif (process.env.NODE_ENV !== 'production') global.prisma = db;\n","export {\n  RequestCookies,\n  ResponseCookies,\n  stringifyCookie,\n} from 'next/dist/compiled/@edge-runtime/cookies'\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {};\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return _next.default;\n  }\n});\nvar _types = require(\"./core/types\");\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\nvar _next = _interopRequireWildcard(require(\"./next\"));\nObject.keys(_next).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _next[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _next[key];\n    }\n  });\n});\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }","import { type DefaultSession } from \"next-auth\";\nimport { UserRole } from \"@/generated/prisma\";\n\n// Define the role hierarchy\nconst ROLE_HIERARCHY = {\n\tstudent: 0,\n\tinstitution: 1,\n\tadmin: 2,\n} as const;\n\n/**\n * Check if a user has the required role or higher\n * @param userRole The user's role\n * @param requiredRole The minimum role required\n * @returns boolean indicating if the user has the required role or higher\n */\nexport const hasRequiredRole = (\n\tuserRole: UserRole,\n\trequiredRole: UserRole\n): boolean => {\n\treturn ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];\n};\n\n/**\n * Check if a user has admin privileges\n * @param userRole The user's role\n * @returns boolean indicating if the user is an admin\n */\nexport const isAdmin = (userRole: UserRole): boolean => {\n\treturn userRole === \"admin\";\n};\n\n/**\n * Type guard to check if a user has a valid role\n * @param role The role to check\n * @returns boolean indicating if the role is valid\n */\nexport const isValidRole = (role: string): role is UserRole => {\n\treturn role === \"admin\" || role === \"institution\";\n};\n\n/**\n * Get the user's role from the session\n * @param session The session object\n * @returns The user's role or null if not available\n */\nexport const getUserRole = (\n\tsession: DefaultSession | null\n): UserRole | null => {\n\tif (!session?.user) return null;\n\tconst role = (session.user as any).role;\n\treturn isValidRole(role) ? role : null;\n};\n\n// Export the role constants\nexport const ROLES = {\n\tADMIN: \"admin\" as UserRole,\n\tINSTITUTION: \"institution\" as UserRole,\n} as const;\n\n// Type for the role values\nexport type UserRoleType = keyof typeof ROLES;\n","// semantic-vector.ts\nimport { pipeline } from \"@xenova/transformers\";\nimport { db as prisma } from \"./db\";\n\n// Define the model we want to use.\n// 'Xenova/all-MiniLM-L6-v2' is standard for RAG: fast, small (23MB), and accurate.\nconst EMBEDDING_MODEL = \"Xenova/all-MiniLM-L6-v2\";\n\nexport class SemanticVectorService {\n\t// Singleton instance of the embedder pipeline to avoid reloading model on every call\n\tprivate static embedder: any = null;\n\n\t/**\n\t * Initialize the local embedding pipeline.\n\t * This downloads the model files (once) and caches them.\n\t */\n\tstatic async initialize() {\n\t\tif (!this.embedder) {\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Initializing local embedder model: ${EMBEDDING_MODEL}...`\n\t\t\t);\n\t\t\tthis.embedder = await pipeline(\"feature-extraction\", EMBEDDING_MODEL);\n\t\t\tconsole.log(\"[SEMANTIC] Embedder initialized successfully\");\n\t\t}\n\t}\n\n\t/**\n\t * Generates a vector embedding locally using Transformers.js\n\t * No API limits, no costs.\n\t */\n\tstatic async generateEmbedding(text: string): Promise<number[]> {\n\t\tawait this.initialize();\n\n\t\tif (!text || !text.trim()) {\n\t\t\tthrow new Error(\"Text is required for embedding generation\");\n\t\t}\n\n\t\t// 1. Pre-process text:\n\t\t// Replace newlines to keep semantic meaning consistent and trim\n\t\tconst cleanedText = text.replace(/\\n+/g, \" \").trim();\n\n\t\t// 2. Truncate text to avoid model limits (512 tokens approx ~2000 chars)\n\t\t// We truncate to 2000 characters to be safe.\n\t\t// For full document search, you should ideally chunk the document and average the vectors,\n\t\t// but for a simple file-level vector, truncating the first 2000 chars (header + summary) works well.\n\t\tconst truncatedText = cleanedText.substring(0, 2000);\n\n\t\ttry {\n\t\t\t// 3. Run inference\n\t\t\tconst result = await this.embedder(truncatedText, {\n\t\t\t\tpooling: \"mean\", // Average the token vectors to get one sentence vector\n\t\t\t\tnormalize: true, // Important for cosine similarity\n\t\t\t});\n\n\t\t\t// 4. Convert Float32Array to regular number array\n\t\t\treturn Array.from(result.data);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"[SEMANTIC] Error generating embedding:\", error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the semantic vector for a specific file.\n\t * @deprecated This function references the old file_list table. Use chapter-processor.ts for chapter chunks instead.\n\t */\n\tstatic async updateSemanticVector(fileId: number) {\n\t\ttry {\n\t\t\tconst file = await prisma.fileList.findUnique({\n\t\t\t\twhere: { id: fileId },\n\t\t\t\tselect: { title: true, category: true, note: true },\n\t\t\t});\n\n\t\t\tif (!file) {\n\t\t\t\tthrow new Error(`File with ID ${fileId} not found`);\n\t\t\t}\n\n\t\t\t// Combine fields.\n\t\t\t// Tip: Put the most important keywords (Title/Category) FIRST\n\t\t\t// because truncation happens at the end.\n\t\t\tconst textToEmbed = `Title: ${file.title}. Category: ${file.category\n\t\t\t\t}. Content: ${file.note || \"\"}`;\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Generating vector for file ${fileId} (${textToEmbed.length} chars)...`\n\t\t\t);\n\n\t\t\tconst embedding = await this.generateEmbedding(textToEmbed);\n\n\t\t\t// Update DB using raw query for pgvector compatibility\n\t\t\tawait prisma.$executeRaw`\n\t\t\t\tUPDATE file_list\n\t\t\t\tSET semantic_vector = ${JSON.stringify(embedding)}::vector\n\t\t\t\tWHERE id = ${fileId}\n\t\t\t`;\n\n\t\t\tconsole.log(`[SEMANTIC] Successfully updated vector for file ${fileId}`);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[SEMANTIC] Failed to update vector for file ${fileId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\t// Don't throw here if this is part of a background batch job, just log it.\n\t\t\t// throw error;\n\t\t}\n\t}\n\n\t/**\n\t * Generate semantic vectors for file chunks\n\t * @deprecated This function references the old file_chunks table. Use chapter-processor.ts for chapter chunks instead.\n\t */\n\tstatic async generateChunkVectors(fileId: number) {\n\t\ttry {\n\t\t\t// Get all chunks for this file\n\t\t\tconst chunks = await prisma.fileChunk.findMany({\n\t\t\t\twhere: { file_id: fileId },\n\t\t\t\tselect: { id: true, content: true },\n\t\t\t});\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Generating vectors for ${chunks.length} chunks of file ${fileId}...`\n\t\t\t);\n\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst embedding = await this.generateEmbedding(chunk.content);\n\n\t\t\t\t\t// Update chunk's semantic vector\n\t\t\t\t\tawait prisma.$executeRaw`\n\t\t\t\t\t\tUPDATE file_chunks\n\t\t\t\t\t\tSET semantic_vector = ${JSON.stringify(embedding)}::vector\n\t\t\t\t\t\tWHERE id = ${chunk.id}\n\t\t\t\t\t`;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`[SEMANTIC] Failed to generate vector for chunk ${chunk.id}:`,\n\t\t\t\t\t\terr\n\t\t\t\t\t);\n\t\t\t\t\t// Continue with other chunks\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Successfully updated vectors for file ${fileId} chunks`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[SEMANTIC] Failed to generate chunk vectors for file ${fileId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Batch/Repair function: Find all files missing vectors and generate them.\n\t * @deprecated This function references the old file_list table. Use updateSearchVectors() in ai-service-enhanced.ts for chapter chunks instead.\n\t */\n\tstatic async batchUpdateSemanticVectors() {\n\t\tconsole.log(\"[SEMANTIC] Starting batch update for missing vectors...\");\n\n\t\t// Find IDs where vector is NULL\n\t\tconst records = await prisma.$queryRaw<{ id: number }[]>`\n\t\t\tSELECT id FROM file_list WHERE semantic_vector IS NULL\n\t\t`;\n\n\t\tconsole.log(`[SEMANTIC] Found ${records.length} records to update.`);\n\n\t\tfor (const record of records) {\n\t\t\tawait this.updateSemanticVector(record.id);\n\t\t}\n\n\t\tconsole.log(\"[SEMANTIC] Batch update completed.\");\n\t}\n}\n","import { createClient } from \"@supabase/supabase-js\";\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceRoleKey) {\n\tconsole.warn(\n\t\t\"Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY environment variables\"\n\t);\n}\n\n// Supabase Admin client with Service Role Key for backend operations\n// Only create client if env vars are present to avoid errors\nexport const supabaseAdmin =\n\tsupabaseUrl && supabaseServiceRoleKey\n\t\t? createClient(supabaseUrl, supabaseServiceRoleKey, {\n\t\t\t\tauth: {\n\t\t\t\t\tautoRefreshToken: false,\n\t\t\t\t\tpersistSession: false,\n\t\t\t\t},\n\t\t  })\n\t\t: null;\n\n/**\n * Validates Supabase Storage connection and bucket access\n * @param bucketName Name of the bucket to test\n * @returns Object with connection status and details\n */\nexport async function validateSupabaseStorage(\n\tbucketName: string = \"chapter_pages\"\n): Promise<{\n\tconnected: boolean;\n\tbucketExists: boolean;\n\terror?: string;\n\tdetails?: {\n\t\turl: string;\n\t\tbucket: string;\n\t\tavailableBuckets?: string[];\n\t};\n}> {\n\ttry {\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Starting validation for bucket: ${bucketName}`\n\t\t);\n\n\t\t// Check environment variables\n\t\tif (!supabaseUrl || !supabaseServiceRoleKey) {\n\t\t\tconst error =\n\t\t\t\t\"Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY environment variables\";\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\treturn {\n\t\t\t\tconnected: false,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(`[SUPABASE-VALIDATION] Supabase URL: ${supabaseUrl}`);\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Service Role Key: ${supabaseServiceRoleKey.substring(\n\t\t\t\t0,\n\t\t\t\t10\n\t\t\t)}...`\n\t\t);\n\n\t\t// Check if client was created\n\t\tif (!supabaseAdmin) {\n\t\t\tconst error =\n\t\t\t\t\"Supabase client not initialized (missing environment variables)\";\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\treturn {\n\t\t\t\tconnected: false,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\n\t\t// Test connection by listing buckets\n\t\tconsole.log(`[SUPABASE-VALIDATION] Attempting to list buckets...`);\n\t\tconst { data: buckets, error: listError } =\n\t\t\tawait supabaseAdmin.storage.listBuckets();\n\n\t\tif (listError) {\n\t\t\tconst error = `Failed to connect to Supabase Storage: ${listError.message}`;\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] Error details:`, {\n\t\t\t\tname: listError.name,\n\t\t\t\tmessage: listError.message,\n\t\t\t\tstatus: (listError as any).status,\n\t\t\t\tstatusCode: (listError as any).statusCode,\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tconnected: false,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Successfully connected. Found ${\n\t\t\t\tbuckets?.length || 0\n\t\t\t} buckets`\n\t\t);\n\t\tconst availableBuckets = buckets?.map((b) => b.name) || [];\n\t\tconsole.log(`[SUPABASE-VALIDATION] Available buckets:`, availableBuckets);\n\n\t\t// Check if target bucket exists\n\t\tconst bucketExists =\n\t\t\tbuckets?.some((bucket) => bucket.name === bucketName) || false;\n\n\t\tif (!bucketExists) {\n\t\t\tconst error = `Bucket '${bucketName}' does not exist. Available buckets: ${\n\t\t\t\tavailableBuckets.join(\", \") || \"none\"\n\t\t\t}`;\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\treturn {\n\t\t\t\tconnected: true,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t\tdetails: {\n\t\t\t\t\turl: supabaseUrl,\n\t\t\t\t\tbucket: bucketName,\n\t\t\t\t\tavailableBuckets,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Bucket '${bucketName}' exists. Testing write access...`\n\t\t);\n\n\t\t// Test write access with a small test file\n\t\tconst testPath = `_test_connection_${Date.now()}.txt`;\n\t\tconst testContent = new Blob([\"connection test\"], { type: \"text/plain\" });\n\n\t\tconst { error: uploadError } = await supabaseAdmin.storage\n\t\t\t.from(bucketName)\n\t\t\t.upload(testPath, testContent, {\n\t\t\t\tcontentType: \"text/plain\",\n\t\t\t\tupsert: true,\n\t\t\t});\n\n\t\tif (uploadError) {\n\t\t\tconst error = `Bucket exists but write access failed: ${uploadError.message}`;\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] Upload error details:`, {\n\t\t\t\tname: uploadError.name,\n\t\t\t\tmessage: uploadError.message,\n\t\t\t\tstatus: (uploadError as any).status,\n\t\t\t\tstatusCode: (uploadError as any).statusCode,\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tconnected: true,\n\t\t\t\tbucketExists: true,\n\t\t\t\terror,\n\t\t\t\tdetails: {\n\t\t\t\t\turl: supabaseUrl,\n\t\t\t\t\tbucket: bucketName,\n\t\t\t\t\tavailableBuckets,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Write access successful. Cleaning up test file...`\n\t\t);\n\n\t\t// Clean up test file\n\t\tconst { error: deleteError } = await supabaseAdmin.storage\n\t\t\t.from(bucketName)\n\t\t\t.remove([testPath]);\n\t\tif (deleteError) {\n\t\t\tconsole.warn(\n\t\t\t\t`[SUPABASE-VALIDATION] Failed to delete test file (non-critical):`,\n\t\t\t\tdeleteError.message\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(`[SUPABASE-VALIDATION] âœ… Validation successful!`);\n\t\treturn {\n\t\t\tconnected: true,\n\t\t\tbucketExists: true,\n\t\t\tdetails: {\n\t\t\t\turl: supabaseUrl,\n\t\t\t\tbucket: bucketName,\n\t\t\t\tavailableBuckets,\n\t\t\t},\n\t\t};\n\t} catch (error: any) {\n\t\tconst errorMsg = `Connection validation failed: ${error.message}`;\n\t\tconsole.error(`[SUPABASE-VALIDATION] ${errorMsg}`);\n\t\tconsole.error(`[SUPABASE-VALIDATION] Error stack:`, error.stack);\n\t\treturn {\n\t\t\tconnected: false,\n\t\t\tbucketExists: false,\n\t\t\terror: errorMsg,\n\t\t};\n\t}\n}\n","'use server';\n\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath } from \"next/cache\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth-options\";\nimport { isAdmin } from \"@/lib/auth\";\n\n// --- Board Actions ---\n\nexport async function createBoard(formData: FormData) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user || !isAdmin((session.user as any).role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const id = formData.get(\"id\") as string;\n    const name = formData.get(\"name\") as string;\n    const countryId = formData.get(\"countryId\") as string;\n    const state = formData.get(\"state\") as string;\n\n    if (!id || !name || !countryId) {\n        return { success: false, error: \"Missing required fields\" };\n    }\n\n    try {\n        await prisma.board.create({\n            data: {\n                id,\n                name,\n                country_id: countryId,\n                state: state || null,\n            },\n        });\n        revalidatePath(\"/admin/boards\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error creating board:\", error);\n        return { success: false, error: \"Failed to create board\" };\n    }\n}\n\nexport async function updateBoardStatus(boardId: string, isActive: boolean) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user || !isAdmin((session.user as any).role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    try {\n        await prisma.board.update({\n            where: { id: boardId },\n            data: { is_active: isActive },\n        });\n        revalidatePath(\"/admin/boards\");\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error updating board status:\", error);\n        return { success: false, error: \"Failed to update board status\" };\n    }\n}\n\n// --- Chapter Actions ---\n\nexport async function updateChapterStatus(chapterId: number | bigint, isActive: boolean) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user || !isAdmin((session.user as any).role)) {\n        throw new Error(\"Unauthorized\");\n    }\n\n    try {\n        await prisma.chapter.update({\n            where: { id: BigInt(chapterId) },\n            data: { is_active: isActive },\n        });\n        revalidatePath(\"/admin/chapters\");\n    } catch (error) {\n        console.error(\"Error updating chapter status:\", error);\n        throw error;\n    }\n}\n\nimport { LlamaParseDocumentParser } from \"@/lib/llamaparse-document-parser\";\nimport { SemanticVectorService } from \"@/lib/semantic-vector\";\nimport { writeFile, unlink } from \"fs/promises\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\nimport { generatePageImages, uploadPageImages } from \"@/lib/pdf-image-generator\";\n\n// ... (imports)\n\nexport async function ingestChapter(formData: FormData) {\n    // ... (auth check)\n    const session = await getServerSession(authOptions);\n    if (!session?.user || !isAdmin((session.user as any).role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const file = formData.get(\"file\") as File;\n    const title = formData.get(\"title\") as string;\n    const subjectId = formData.get(\"subjectId\") as string;\n    const chapterNumber = formData.get(\"chapterNumber\") as string;\n    const accessibleBoards = formData.getAll(\"accessibleBoards\") as string[];\n\n    if (!file || !title || !subjectId) {\n        return { success: false, error: \"Missing required fields (file, title, subjectId)\" };\n    }\n\n    const tempFilePath = join(tmpdir(), `upload-${Date.now()}-${file.name}`);\n    // Create a unique folder name for this upload's images\n    const uploadId = `chapter-${Date.now()}`;\n    const imagesDir = join(tmpdir(), `${uploadId}-images`);\n\n    try {\n        // ... (subject/board logic)\n        const subject = await prisma.subject.findUnique({\n            where: { id: parseInt(subjectId) },\n            include: { program: { include: { board: true } } }\n        });\n\n        if (!subject) return { success: false, error: \"Subject not found\" };\n        const primaryBoardId = subject.program.board.id;\n\n        let isGlobal = false;\n        let finalAccessibleBoards: string[] = [];\n        if (accessibleBoards.includes(\"GLOBAL\")) {\n            isGlobal = true;\n            finalAccessibleBoards = [];\n        } else if (accessibleBoards.length > 0) {\n            isGlobal = false;\n            finalAccessibleBoards = accessibleBoards.filter(b => b !== \"GLOBAL\");\n        } else {\n            isGlobal = false;\n            finalAccessibleBoards = [primaryBoardId];\n        }\n\n        // 1. Save file to temp\n        const bytes = await file.arrayBuffer();\n        const buffer = Buffer.from(bytes);\n        await writeFile(tempFilePath, buffer);\n\n        // 2. Parse with LlamaParse\n        const parser = new LlamaParseDocumentParser();\n        const pages = await parser.parseFile(tempFilePath, { fastMode: false });\n\n        // 3. Generate & Upload Images\n        // We do this in parallel with parsing ideally, but sequential is safer for now\n        let pageUrlMap = new Map<number, string>();\n        try {\n            const imagePaths = await generatePageImages(tempFilePath, imagesDir, uploadId);\n            pageUrlMap = await uploadPageImages(imagePaths, uploadId);\n        } catch (imgErr) {\n            console.error(\"Failed to generate/upload images:\", imgErr);\n            // Continue without images\n        }\n\n        // 4. Create Chapter\n        const chapter = await prisma.chapter.create({\n            data: {\n                title,\n                subject_id: parseInt(subjectId),\n                chapter_number: chapterNumber ? parseInt(chapterNumber) : null,\n                content_json: pages as any,\n                accessible_boards: finalAccessibleBoards,\n                is_global: isGlobal,\n            },\n        });\n\n        // 5. Create Chunks & Vectors\n        for (let i = 0; i < pages.length; i++) {\n            const page = pages[i];\n            const content = page.md || page.text || \"\";\n            if (!content.trim()) continue;\n\n            const embedding = await SemanticVectorService.generateEmbedding(content);\n\n            const chunk = await prisma.chapterChunk.create({\n                data: {\n                    chapter_id: chapter.id,\n                    chunk_index: i,\n                    content: content,\n                    page_number: page.page,\n                    bbox: page.items as any,\n                    subject_id: parseInt(subjectId),\n                },\n            });\n\n            await prisma.$executeRaw`\n                UPDATE \"chapter_chunks\"\n                SET semantic_vector = ${JSON.stringify(embedding)}::vector\n                WHERE id = ${chunk.id}\n            `;\n\n            if (!isGlobal && finalAccessibleBoards.length > 0) {\n                for (const bid of finalAccessibleBoards) {\n                    await prisma.chapterChunkBoard.create({\n                        data: { chunk_id: chunk.id, board_id: bid }\n                    });\n                }\n            }\n        }\n\n        // 6. Create Chapter Pages\n        for (const page of pages) {\n            await prisma.chapterPage.create({\n                data: {\n                    chapter_id: chapter.id,\n                    page_number: page.page,\n                    image_url: pageUrlMap.get(page.page) || \"\",\n                    width: page.width || null,\n                    height: page.height || null\n                }\n            });\n        }\n\n        revalidatePath(\"/admin/chapters\");\n        return { success: true };\n\n    } catch (error: any) {\n        console.error(\"Error ingesting chapter:\", error);\n        return { success: false, error: error.message || \"Failed to ingest chapter\" };\n    } finally {\n        // Cleanup\n        try {\n            await unlink(tempFilePath);\n            // Cleanup images dir\n            const { rm } = await import(\"fs/promises\");\n            await rm(imagesDir, { recursive: true, force: true });\n        } catch (e) { }\n    }\n}\n\nexport async function batchCreateChapters(formData: FormData) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user || !isAdmin((session.user as any).role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const file = formData.get(\"file\") as File; // Re-uploaded file\n    const subjectId = formData.get(\"subjectId\") as string;\n    const accessibleBoards = formData.getAll(\"accessibleBoards\") as string[];\n    const chaptersJson = formData.get(\"chapters\") as string;\n    const fullPagesJson = formData.get(\"fullPages\") as string;\n\n    if (!subjectId || !chaptersJson || !fullPagesJson) {\n        return { success: false, error: \"Missing required fields\" };\n    }\n\n    const tempFilePath = file ? join(tmpdir(), `batch-${Date.now()}-${file.name}`) : \"\";\n    const uploadId = `textbook-${Date.now()}`;\n    const imagesDir = join(tmpdir(), `${uploadId}-images`);\n\n    try {\n        // ... (subject/board logic)\n        const subject = await prisma.subject.findUnique({\n            where: { id: parseInt(subjectId) },\n            include: { program: { include: { board: true } } }\n        });\n\n        if (!subject) return { success: false, error: \"Subject not found\" };\n        const primaryBoardId = subject.program.board.id;\n\n        let isGlobal = false;\n        let finalAccessibleBoards: string[] = [];\n        if (accessibleBoards.includes(\"GLOBAL\")) {\n            isGlobal = true;\n            finalAccessibleBoards = [];\n        } else if (accessibleBoards.length > 0) {\n            isGlobal = false;\n            finalAccessibleBoards = accessibleBoards.filter(b => b !== \"GLOBAL\");\n        } else {\n            isGlobal = false;\n            finalAccessibleBoards = [primaryBoardId];\n        }\n\n        const detectedChapters = JSON.parse(chaptersJson);\n        const fullPages = JSON.parse(fullPagesJson);\n\n        // Generate Images if file provided\n        let pageUrlMap = new Map<number, string>();\n        if (file) {\n            try {\n                const bytes = await file.arrayBuffer();\n                await writeFile(tempFilePath, Buffer.from(bytes));\n\n                const imagePaths = await generatePageImages(tempFilePath, imagesDir, uploadId);\n                pageUrlMap = await uploadPageImages(imagePaths, uploadId);\n            } catch (imgErr) {\n                console.error(\"Failed to generate/upload images:\", imgErr);\n            }\n        }\n\n        let successCount = 0;\n        let errorCount = 0;\n\n        for (const detectedChapter of detectedChapters) {\n            try {\n                const chapterPages = fullPages.filter(\n                    (p: any) => p.page >= detectedChapter.startPage && p.page <= detectedChapter.endPage\n                );\n\n                const chapter = await prisma.chapter.create({\n                    data: {\n                        title: detectedChapter.title,\n                        subject_id: parseInt(subjectId),\n                        chapter_number: detectedChapter.chapterNumber,\n                        content_json: chapterPages as any,\n                        accessible_boards: finalAccessibleBoards,\n                        is_global: isGlobal,\n                    },\n                });\n\n                for (let i = 0; i < chapterPages.length; i++) {\n                    const page = chapterPages[i];\n                    const content = page.md || page.text || \"\";\n                    if (!content.trim()) continue;\n\n                    const embedding = await SemanticVectorService.generateEmbedding(content);\n\n                    const chunk = await prisma.chapterChunk.create({\n                        data: {\n                            chapter_id: chapter.id,\n                            chunk_index: i,\n                            content: content,\n                            page_number: page.page,\n                            bbox: page.items as any,\n                            subject_id: parseInt(subjectId),\n                        },\n                    });\n\n                    await prisma.$executeRaw`\n                        UPDATE \"chapter_chunks\"\n                        SET semantic_vector = ${JSON.stringify(embedding)}::vector\n                        WHERE id = ${chunk.id}\n                    `;\n\n                    if (!isGlobal && finalAccessibleBoards.length > 0) {\n                        for (const bid of finalAccessibleBoards) {\n                            await prisma.chapterChunkBoard.create({\n                                data: { chunk_id: chunk.id, board_id: bid }\n                            });\n                        }\n                    }\n                }\n\n                for (const page of chapterPages) {\n                    await prisma.chapterPage.create({\n                        data: {\n                            chapter_id: chapter.id,\n                            page_number: page.page,\n                            image_url: pageUrlMap.get(page.page) || \"\",\n                            width: page.width || null,\n                            height: page.height || null\n                        }\n                    });\n                }\n\n                successCount++;\n            } catch (chapterError: any) {\n                console.error(`Error creating chapter \"${detectedChapter.title}\":`, chapterError);\n                errorCount++;\n            }\n        }\n\n        revalidatePath(\"/admin/chapters\");\n        return {\n            success: true,\n            message: `Created ${successCount} chapter(s)${errorCount > 0 ? `, ${errorCount} failed` : ''}`,\n            createdCount: successCount,\n            errorCount\n        };\n    } catch (error: any) {\n        console.error(\"Error in batch create chapters:\", error);\n        return { success: false, error: error.message || \"Failed to create chapters\" };\n    } finally {\n        if (tempFilePath) {\n            try {\n                await unlink(tempFilePath);\n                const { rm } = await import(\"fs/promises\");\n                await rm(imagesDir, { recursive: true, force: true });\n            } catch (e) { }\n        }\n    }\n}\n\n/**\n * Analyze textbook PDF and detect chapters (server-side only)\n */\nexport async function analyzeTextbook(formData: FormData) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user || !isAdmin((session.user as any).role)) {\n        return { success: false, error: \"Unauthorized\" };\n    }\n\n    const file = formData.get(\"file\") as File;\n\n    if (!file) {\n        return { success: false, error: \"No file provided\" };\n    }\n\n    const tempFilePath = join(tmpdir(), `analyze-${Date.now()}-${file.name}`);\n\n    try {\n        // Save file to temp\n        const bytes = await file.arrayBuffer();\n        const buffer = Buffer.from(bytes);\n        await writeFile(tempFilePath, buffer);\n\n        // Parse with LlamaParse\n        const parser = new LlamaParseDocumentParser();\n        const pages = await parser.parseFile(tempFilePath, { fastMode: false });\n\n        // Return pages for client-side chapter detection\n        return {\n            success: true,\n            pages: pages\n        };\n    } catch (error: any) {\n        console.error(\"Error analyzing textbook:\", error);\n        return { success: false, error: error.message || \"Failed to analyze textbook\" };\n    } finally {\n        // Cleanup\n        try {\n            await unlink(tempFilePath);\n        } catch (e) {\n            // Ignore cleanup error\n        }\n    }\n}\n","export {createBoard as '40156b02c54632f3ae6c8d3b14a7134aabadc62498'} from 'ACTIONS_MODULE0'\nexport {updateBoardStatus as '60bc3a43b5a72b3fea35d30ba3e677f6333ad2ad3b'} from 'ACTIONS_MODULE0'\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error","RequestCookies","ResponseCookies","stringifyCookie"],"mappings":"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","ignoreList":[1,2,5,6,7]}