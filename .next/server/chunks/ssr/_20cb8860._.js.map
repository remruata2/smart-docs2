{"version":3,"sources":["../../../../src/lib/question-bank-service.ts","../../../../src/lib/chapter-processor.ts","../../../../src/app/admin/chapters/actions-async.ts","../../../../.next-internal/server/app/admin/chapters/new/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["import { prisma } from \"@/lib/prisma\";\nimport { generateBatchQuestions } from \"@/lib/ai-service-enhanced\";\nimport { QuestionType } from \"@/generated/prisma\";\n\nexport interface QuestionBankConfig {\n    difficulty: \"easy\" | \"medium\" | \"hard\";\n    typeCounts: {\n        [key in QuestionType]?: number;\n    };\n}\n\nexport interface FullQuestionBankConfig {\n    easy: { [key in QuestionType]?: number };\n    medium: { [key in QuestionType]?: number };\n    hard: { [key in QuestionType]?: number };\n}\n\n/**\n * Generate a comprehensive Question Bank for a chapter\n * - Fetches all chunks for the chapter\n * - Groups them into logical sections (e.g., 3-5 pages)\n * - Distributes the total question quota among sections\n * - Generates questions in parallel batches\n */\nexport async function generateQuestionBank(\n    chapterId: string,\n    config: FullQuestionBankConfig\n) {\n    console.log(`[QUESTION-BANK] Starting generation for chapter ${chapterId}`);\n\n    try {\n        const bigChapterId = BigInt(chapterId);\n\n        // 1. Fetch all chunks for the chapter\n        const chunks = await prisma.chapterChunk.findMany({\n            where: { chapter_id: bigChapterId },\n            orderBy: { chunk_index: 'asc' },\n            select: {\n                id: true,\n                content: true,\n                page_number: true,\n                chunk_index: true\n            }\n        });\n\n        if (chunks.length === 0) {\n            console.warn(`[QUESTION-BANK] No chunks found for chapter ${chapterId}`);\n            return;\n        }\n\n        // 2. Group chunks into logical sections (e.g., ~3 pages per section)\n        // This ensures thorough coverage of the entire chapter\n        const PAGES_PER_SECTION = 3;\n        const sections: {\n            startPage: number;\n            endPage: number;\n            content: string;\n            chunkIds: bigint[];\n        }[] = [];\n\n        let currentSectionChunks: typeof chunks = [];\n        let currentStartPage = chunks[0].page_number || 1;\n\n        for (const chunk of chunks) {\n            const pageNum = chunk.page_number || 0;\n\n            // If we have collected enough pages, close the section\n            // Or if there's a large gap in page numbers (new unit?)\n            if (\n                currentSectionChunks.length > 0 &&\n                (pageNum > currentStartPage + PAGES_PER_SECTION || pageNum > (currentSectionChunks[currentSectionChunks.length - 1].page_number || 0) + 2)\n            ) {\n                sections.push({\n                    startPage: currentStartPage,\n                    endPage: currentSectionChunks[currentSectionChunks.length - 1].page_number || currentStartPage,\n                    content: currentSectionChunks.map(c => c.content).join(\"\\n\\n\"),\n                    chunkIds: currentSectionChunks.map(c => c.id)\n                });\n                currentSectionChunks = [];\n                currentStartPage = pageNum;\n            }\n            currentSectionChunks.push(chunk);\n        }\n\n        // Add the last section\n        if (currentSectionChunks.length > 0) {\n            sections.push({\n                startPage: currentStartPage,\n                endPage: currentSectionChunks[currentSectionChunks.length - 1].page_number || currentStartPage,\n                content: currentSectionChunks.map(c => c.content).join(\"\\n\\n\"),\n                chunkIds: currentSectionChunks.map(c => c.id)\n            });\n        }\n\n        console.log(`[QUESTION-BANK] Split chapter into ${sections.length} sections for processing`);\n\n        // 3. Calculate quota per section\n        // We need to distribute the total requested questions among the sections\n        // We'll do this proportionally, but for now, simple division is fine\n        // If 6 sections and 20 Easy MCQs requested -> ~3-4 per section\n\n        const totalSections = sections.length;\n\n        // Helper to distribute count\n        const distribute = (total: number) => {\n            const base = Math.floor(total / totalSections);\n            const remainder = total % totalSections;\n            return { base, remainder };\n        };\n\n        // Prepare jobs for each section\n        const jobs = sections.map((section, idx) => {\n            const sectionConfig: FullQuestionBankConfig = {\n                easy: {},\n                medium: {},\n                hard: {}\n            };\n\n            // Distribute counts for each difficulty and type\n            (['easy', 'medium', 'hard'] as const).forEach(diff => {\n                Object.entries(config[diff]).forEach(([type, count]) => {\n                    const { base, remainder } = distribute(count as number);\n                    // Distribute remainder to first few sections\n                    const sectionCount = base + (idx < remainder ? 1 : 0);\n\n                    if (sectionCount > 0) {\n                        sectionConfig[diff][type as QuestionType] = sectionCount;\n                    }\n                });\n            });\n\n            return {\n                section,\n                config: sectionConfig\n            };\n        });\n\n        // 4. Process sections in parallel (with concurrency limit)\n        // We'll process 3 sections at a time to avoid rate limits\n        const BATCH_SIZE = 3;\n        for (let i = 0; i < jobs.length; i += BATCH_SIZE) {\n            const batch = jobs.slice(i, i + BATCH_SIZE);\n\n            await Promise.all(batch.map(async (job) => {\n                // Skip if no questions needed for this section\n                const hasQuestions = Object.values(job.config).some(d => Object.keys(d).length > 0);\n                if (!hasQuestions) return;\n\n                console.log(`[QUESTION-BANK] Generating questions for section Pages ${job.section.startPage}-${job.section.endPage}`);\n\n                try {\n                    const questions = await generateBatchQuestions({\n                        context: job.section.content,\n                        config: job.config,\n                        chapterTitle: `Pages ${job.section.startPage}-${job.section.endPage}` // Context for AI\n                    });\n\n                    // Save to DB\n                    if (questions.length > 0) {\n                        await prisma.question.createMany({\n                            data: questions.map(q => ({\n                                chapter_id: bigChapterId,\n                                question_text: q.question_text,\n                                question_type: q.question_type as QuestionType,\n                                difficulty: q.difficulty,\n                                options: q.options ? q.options : undefined,\n                                correct_answer: q.correct_answer,\n                                explanation: q.explanation,\n                                points: q.points,\n                                is_active: true\n                            }))\n                        });\n                        console.log(`[QUESTION-BANK] Saved ${questions.length} questions for section Pages ${job.section.startPage}-${job.section.endPage}`);\n                    }\n                } catch (error) {\n                    console.error(`[QUESTION-BANK] Failed to generate for section Pages ${job.section.startPage}-${job.section.endPage}:`, error);\n                    // Continue with other sections even if one fails\n                }\n            }));\n        }\n\n        console.log(`[QUESTION-BANK] Completed generation for chapter ${chapterId}`);\n\n    } catch (error) {\n        console.error(`[QUESTION-BANK] Critical error generating question bank for ${chapterId}:`, error);\n        throw error;\n    }\n}\n","/**\n * Background Chapter Processor\n * Handles async processing of chapters with LlamaParse and embedding generation\n */\n\nimport { prisma } from \"@/lib/prisma\";\nimport { revalidatePath } from \"next/cache\";\nimport { LlamaParseDocumentParser } from \"./llamaparse-document-parser\";\nimport { SemanticVectorService } from \"./semantic-vector\";\nimport { writeFile, unlink } from \"fs/promises\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\nimport { generatePageImages, uploadPageImages } from \"./pdf-image-generator\";\nimport { generateStudyMaterials, StudyMaterialsConfig } from \"./ai-service-enhanced\";\nimport { searchYouTubeVideos } from \"./youtube-service\";\nimport { generateQuestionBank, FullQuestionBankConfig } from \"./question-bank-service\";\n\nexport interface ChapterProcessingJob {\n\tchapterId: string;\n\tpdfBuffer: Buffer;\n\tfileName: string;\n\tstartPage?: number;\n\tendPage?: number;\n\tquestionConfig?: FullQuestionBankConfig;\n}\n\n/**\n * Generate study materials for a chapter in the background (non-blocking)\n */\nasync function generateStudyMaterialsBackground(\n\tchapterId: string,\n\tchapterInfo: { title: string; subject: { name: string } }\n) {\n\ttry {\n\t\tconst bigChapterId = BigInt(chapterId);\n\n\t\t// Check if already exists\n\t\tconst existing = await prisma.studyMaterial.findUnique({\n\t\t\twhere: { chapter_id: bigChapterId },\n\t\t});\n\n\t\tif (existing) {\n\t\t\tconsole.log(`[BG-PROCESSOR] Study materials already exist for chapter ${chapterId}, skipping`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Get full chapter content\n\t\tconst chapter = await prisma.chapter.findUnique({\n\t\t\twhere: { id: bigChapterId },\n\t\t});\n\n\t\tif (!chapter) return;\n\n\t\t// Extract content\n\t\tconst content: any = chapter.content_json;\n\t\tconst chapterContent = content.text || content.markdown || JSON.stringify(content);\n\n\t\t// Generate with AI\n\t\tconst config: StudyMaterialsConfig = {\n\t\t\tsubject: chapterInfo.subject.name,\n\t\t\tchapterTitle: chapterInfo.title,\n\t\t\tcontent: chapterContent,\n\t\t};\n\n\t\tconst aiMaterials = await generateStudyMaterials(config);\n\n\t\t// Search YouTube\n\t\tconst videoSearches = await Promise.all(\n\t\t\taiMaterials.youtube_search_queries.map(query =>\n\t\t\t\tsearchYouTubeVideos({ query, maxResults: 2 })\n\t\t\t)\n\t\t);\n\t\tconst curatedVideos = videoSearches.flat().slice(0, 6);\n\n\t\t// Save to database\n\t\tawait prisma.studyMaterial.create({\n\t\t\tdata: {\n\t\t\t\tchapter_id: bigChapterId,\n\t\t\t\tsummary: {\n\t\t\t\t\tbrief: aiMaterials.summary_markdown,\n\t\t\t\t\tkey_points: aiMaterials.key_terms.map(t => t.term),\n\t\t\t\t\timportant_formulas: aiMaterials.important_formulas || [],\n\t\t\t\t},\n\t\t\t\tdefinitions: aiMaterials.key_terms,\n\t\t\t\tflashcards: aiMaterials.flashcards,\n\t\t\t\tmind_map: aiMaterials.mind_map_mermaid,\n\t\t\t\tvideo_queries: aiMaterials.youtube_search_queries,\n\t\t\t\tcurated_videos: curatedVideos as any, // Cast as any for JSON field\n\t\t\t},\n\t\t});\n\n\t\tconsole.log(`[BG-PROCESSOR] Successfully generated study materials for chapter ${chapterId}`);\n\t} catch (error) {\n\t\tconsole.error(`[BG-PROCESSOR] Error generating study materials for chapter ${chapterId}:`, error);\n\t\t// Don't throw - this is a background job\n\t}\n}\n\n/**\n * Process a chapter in the background\n * - Runs LlamaParse on the PDF\n * - Generates embeddings for chunks\n * - Generates and uploads page screenshots\n * - Generates study materials\n */\nexport async function processChapterBackground(job: ChapterProcessingJob) {\n\tconst { chapterId, pdfBuffer, fileName, startPage, endPage } = job;\n\tconst bigChapterId = BigInt(chapterId);\n\n\ttry {\n\t\t// Update status to PROCESSING\n\t\tawait prisma.chapter.update({\n\t\t\twhere: { id: bigChapterId },\n\t\t\tdata: {\n\t\t\t\tprocessing_status: \"PROCESSING\",\n\t\t\t\terror_message: null,\n\t\t\t},\n\t\t});\n\n\t\tconst rangeText = startPage && endPage ? `(Pages ${startPage}-${endPage})` : \"(Full Document)\";\n\t\tconsole.log(`[BG-PROCESSOR] Starting processing for chapter ${chapterId} ${rangeText}`);\n\n\t\t// 1. Write PDF to temporary file\n\t\tconst tempFilePath = join(\n\t\t\ttmpdir(),\n\t\t\t`chapter-${chapterId}-${Date.now()}.pdf`\n\t\t);\n\t\tawait writeFile(tempFilePath, pdfBuffer);\n\n\t\t// 2. Run LlamaParse for high-quality parsing\n\t\tconsole.log(`[BG-PROCESSOR] Running LlamaParse...`);\n\t\tconst parser = new LlamaParseDocumentParser();\n\n\t\t// We pass the whole file to LlamaParse because splitting PDFs before parsing \n\t\t// can be tricky with some libraries, and LlamaParse handles whole docs well.\n\t\t// We will filter the pages afterwards.\n\t\tconst parseResult = await parser.parseFile(tempFilePath);\n\n\t\t// parseFile returns the pages array directly, not an object with pages property\n\t\tif (\n\t\t\t!parseResult ||\n\t\t\t!Array.isArray(parseResult) ||\n\t\t\tparseResult.length === 0\n\t\t) {\n\t\t\tthrow new Error(\"LlamaParse returned no pages\");\n\t\t}\n\n\t\t// Filter pages based on chapter range if provided, otherwise use all pages\n\t\tlet chapterPages = parseResult;\n\t\tif (startPage !== undefined && endPage !== undefined) {\n\t\t\t// LlamaParse pages are typically 1-indexed in their 'page' property\n\t\t\tchapterPages = parseResult.filter(p => p.page >= startPage && p.page <= endPage);\n\t\t}\n\n\t\tif (chapterPages.length === 0) {\n\t\t\tconst rangeMsg = startPage && endPage ? `in range ${startPage}-${endPage}` : \"in document\";\n\t\t\tconsole.warn(`[BG-PROCESSOR] No pages found ${rangeMsg}. LlamaParse returned pages: ${parseResult.map(p => p.page).join(', ')}`);\n\t\t\tthrow new Error(`No content found ${rangeMsg}`);\n\t\t}\n\n\t\tconsole.log(`[BG-PROCESSOR] Processing ${chapterPages.length} pages (from ${parseResult.length} total)`);\n\n\t\t// 3. Update chapter with LlamaParse content (only relevant pages)\n\t\tawait prisma.chapter.update({\n\t\t\twhere: { id: bigChapterId },\n\t\t\tdata: {\n\t\t\t\tcontent_json: chapterPages as any,\n\t\t\t\tparsed_at: new Date(),\n\t\t\t},\n\t\t});\n\n\t\tconsole.log(`[BG-PROCESSOR] Parsed ${chapterPages.length} pages`);\n\n\t\t// Helper function to convert PDF point coordinates to percentages (0-1)\n\t\t// This is essential for split-screen citation highlighting to work correctly\n\t\tfunction convertBBoxToPercentages(\n\t\t\tbbox: { x: number; y: number; w: number; h: number },\n\t\t\tactualPageWidth: number = 595,\n\t\t\tactualPageHeight: number = 842\n\t\t): number[] {\n\t\t\t// Validate bbox values and handle null/undefined\n\t\t\tconst x = bbox.x ?? 0;\n\t\t\tconst y = bbox.y ?? 0;\n\t\t\tconst w = bbox.w ?? 1;\n\t\t\tconst h = bbox.h ?? 1;\n\n\t\t\t// Ensure dimensions are valid (greater than 0)\n\t\t\tif (actualPageWidth <= 0 || actualPageHeight <= 0) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[BG-PROCESSOR] Invalid page dimensions: ${actualPageWidth}x${actualPageHeight}, using defaults`\n\t\t\t\t);\n\t\t\t\tactualPageWidth = 595;\n\t\t\t\tactualPageHeight = 842;\n\t\t\t}\n\n\t\t\treturn [\n\t\t\t\tMath.max(0, Math.min(1, x / actualPageWidth)),\n\t\t\t\tMath.max(0, Math.min(1, y / actualPageHeight)),\n\t\t\t\tMath.max(0, Math.min(1, w / actualPageWidth)),\n\t\t\t\tMath.max(0, Math.min(1, h / actualPageHeight)),\n\t\t\t];\n\t\t}\n\n\t\t// 4. Create chunks from LlamaParse output\n\t\t// ONE chunk per page (consolidate all items on a page)\n\t\tconst chunks: any[] = [];\n\t\tfor (const pageData of chapterPages) {\n\t\t\tconst items = pageData.items || [];\n\t\t\tconst pageWidth = pageData.width || 595; // Default to A4 width\n\t\t\tconst pageHeight = pageData.height || 842; // Default to A4 height\n\n\t\t\t// Consolidate all text items for this page into one chunk\n\t\t\tlet fullPageText = \"\";\n\t\t\tlet layoutItemsArray: Array<{ text: string; bbox: number[] }> = [];\n\n\t\t\tfor (const item of items) {\n\t\t\t\tif (!item.md || item.md.trim().length === 0) continue;\n\n\t\t\t\tconst text = item.md.trim();\n\t\t\t\tfullPageText += text + \"\\n\\n\";\n\n\t\t\t\t// Collect bbox information for split-screen citations\n\t\t\t\tconst itemBBox = item.bbox || item.bBox;\n\t\t\t\tif (itemBBox && typeof itemBBox === \"object\") {\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof itemBBox.x === \"number\" &&\n\t\t\t\t\t\ttypeof itemBBox.y === \"number\" &&\n\t\t\t\t\t\ttypeof itemBBox.w === \"number\" &&\n\t\t\t\t\t\ttypeof itemBBox.h === \"number\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst bbox = convertBBoxToPercentages(itemBBox, pageWidth, pageHeight);\n\t\t\t\t\t\tconst textSnippet = text; // Store full text for the overlay\n\t\t\t\t\t\tlayoutItemsArray.push({\n\t\t\t\t\t\t\ttext: textSnippet,\n\t\t\t\t\t\t\tbbox: bbox,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`[BG-PROCESSOR] Invalid bbox structure for item on page ${pageData.page}:`,\n\t\t\t\t\t\t\titemBBox\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fallback: if no items but page has text/md, use that\n\t\t\tif (!fullPageText.trim() && (pageData.text || pageData.md)) {\n\t\t\t\tfullPageText = (pageData.text || pageData.md || \"\").trim();\n\t\t\t}\n\n\t\t\t// Skip empty pages\n\t\t\tif (!fullPageText.trim()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Create ONE chunk per page with all content\n\t\t\t// Store layout items array in bbox field for split-screen citations\n\t\t\tchunks.push({\n\t\t\t\tcontent: fullPageText.trim(),\n\t\t\t\tpage_number: pageData.page,\n\t\t\t\tbbox: layoutItemsArray.length > 0 ? layoutItemsArray : null, // Array of bbox items for this page\n\t\t\t});\n\t\t}\n\n\t\tconsole.log(`[BG-PROCESSOR] Created ${chunks.length} chunks (one per page)`);\n\n\t\t// 5. Insert chunks into database\n\t\tconst chapter = await prisma.chapter.findUnique({\n\t\t\twhere: { id: bigChapterId },\n\t\t\tselect: { subject_id: true, accessible_boards: true, is_global: true },\n\t\t});\n\n\t\tif (!chapter) throw new Error(\"Chapter not found\");\n\n\t\tconst createdChunks = await Promise.all(\n\t\t\tchunks.map((chunk, index) =>\n\t\t\t\tprisma.chapterChunk.create({\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tchapter_id: bigChapterId,\n\t\t\t\t\t\tchunk_index: index,\n\t\t\t\t\t\tcontent: chunk.content,\n\t\t\t\t\t\tpage_number: chunk.page_number,\n\t\t\t\t\t\tbbox: chunk.bbox,\n\t\t\t\t\t\tsubject_id: chapter.subject_id,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t)\n\t\t);\n\n\t\tconsole.log(\n\t\t\t`[BG-PROCESSOR] Inserted ${createdChunks.length} chunks into DB`\n\t\t);\n\n\t\t// 6. Create chapter_chunk_boards entries for board access\n\t\t// This is critical for the hybrid search query to find chunks\n\t\tif (!chapter.is_global && chapter.accessible_boards.length > 0) {\n\t\t\tconsole.log(\n\t\t\t\t`[BG-PROCESSOR] Creating board access entries for ${createdChunks.length} chunks...`\n\t\t\t);\n\n\t\t\tconst boardEntries = [];\n\t\t\tfor (const chunk of createdChunks) {\n\t\t\t\tfor (const boardId of chapter.accessible_boards) {\n\t\t\t\t\tboardEntries.push({\n\t\t\t\t\t\tchunk_id: chunk.id,\n\t\t\t\t\t\tboard_id: boardId,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Batch insert board access entries\n\t\t\tif (boardEntries.length > 0) {\n\t\t\t\tawait prisma.chapterChunkBoard.createMany({\n\t\t\t\t\tdata: boardEntries,\n\t\t\t\t});\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[BG-PROCESSOR] Created ${boardEntries.length} board access entries`\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (chapter.is_global) {\n\t\t\tconsole.log(\n\t\t\t\t`[BG-PROCESSOR] Chapter is global, skipping board access entries`\n\t\t\t);\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t`[BG-PROCESSOR] Chapter has no accessible_boards and is not global - chunks may not be searchable!`\n\t\t\t);\n\t\t}\n\n\t\t// 7. Get chapter and subject info for search_vector generation\n\t\tconst chapterInfo = await prisma.chapter.findUnique({\n\t\t\twhere: { id: bigChapterId },\n\t\t\tselect: {\n\t\t\t\ttitle: true,\n\t\t\t\tsubject: {\n\t\t\t\t\tselect: {\n\t\t\t\t\t\tname: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (!chapterInfo) {\n\t\t\tthrow new Error(\"Chapter not found for vector generation\");\n\t\t}\n\n\t\t// 8. Generate embeddings and search vectors for chunks\n\t\tconsole.log(`[BG-PROCESSOR] Generating embeddings and search vectors...`);\n\n\t\tfor (const chunk of createdChunks) {\n\t\t\t// Generate semantic vector\n\t\t\tconst embedding = await SemanticVectorService.generateEmbedding(\n\t\t\t\tchunk.content\n\t\t\t);\n\n\t\t\t// Generate search_vector (tsvector) with weighted fields:\n\t\t\t// - Chapter title: weight 'A' (highest priority)\n\t\t\t// - Subject name: weight 'B' (medium priority)\n\t\t\t// - Chunk content: weight 'C' (lower priority)\n\t\t\tawait prisma.$executeRaw`\n                UPDATE \"chapter_chunks\"\n                SET semantic_vector = ${JSON.stringify(embedding)}::vector,\n                    search_vector = setweight(to_tsvector('english', COALESCE(${chapterInfo.title || \"\"\n\t\t\t\t}, '')), 'A') ||\n                                   setweight(to_tsvector('english', COALESCE(${chapterInfo.subject.name || \"\"\n\t\t\t\t}, '')), 'B') ||\n                                   setweight(to_tsvector('english', COALESCE(${chunk.content || \"\"\n\t\t\t\t}, '')), 'C')\n                WHERE id = ${chunk.id}\n            `;\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[BG-PROCESSOR] Generated embeddings and search vectors for all chunks`\n\t\t);\n\n\t\t// 9. Generate page screenshots and upload to Supabase\n\t\tconsole.log(`[BG-PROCESSOR] Generating page screenshots...`);\n\t\tconst outputDir = join(tmpdir(), `chapter-${chapterId}-images`);\n\t\tconst imagePaths = await generatePageImages(\n\t\t\ttempFilePath,\n\t\t\toutputDir,\n\t\t\tchapterId,\n\t\t\tstartPage,\n\t\t\tendPage\n\t\t);\n\n\t\tconst imageUrls = await uploadPageImages(\n\t\t\timagePaths,\n\t\t\t`chapter-${chapterId}`\n\t\t);\n\n\t\t// 10. Create ChapterPage records\n\t\tconst pageRecords = parseResult.map((page: any) => ({\n\t\t\tchapter_id: bigChapterId,\n\t\t\tpage_number: page.page,\n\t\t\timage_url: imageUrls.get(page.page) || \"\",\n\t\t\twidth: page.width || null,\n\t\t\theight: page.height || null,\n\t\t}));\n\n\t\tawait prisma.chapterPage.createMany({\n\t\t\tdata: pageRecords,\n\t\t});\n\n\t\tconsole.log(`[BG-PROCESSOR] Created ${pageRecords.length} page records`);\n\n\t\t// 9. Clean up temporary files\n\t\tawait unlink(tempFilePath);\n\n\t\t// 12. Generate study materials (wait for completion)\n\t\tconsole.log(`[BG-PROCESSOR] Generating study materials...`);\n\t\tawait generateStudyMaterialsBackground(chapterId, chapterInfo);\n\t\tconsole.log(`[BG-PROCESSOR] Study materials generated for chapter ${chapterId}`);\n\n\t\t// 13. Generate Question Bank if config provided (wait for completion)\n\t\tif (job.questionConfig) {\n\t\t\tconsole.log(`[BG-PROCESSOR] Generating Question Bank...`);\n\t\t\tawait generateQuestionBank(chapterId, job.questionConfig);\n\t\t\tconsole.log(`[BG-PROCESSOR] Question Bank generated for chapter ${chapterId}`);\n\t\t}\n\n\t\t// 14. Update status to COMPLETED (only after all processing is done)\n\t\tawait prisma.chapter.update({\n\t\t\twhere: { id: bigChapterId },\n\t\t\tdata: {\n\t\t\t\tprocessing_status: \"COMPLETED\",\n\t\t\t\tprocessed_at: new Date(),\n\t\t\t\terror_message: null,\n\t\t\t},\n\t\t});\n\n\t\t// revalidatePath is not supported in background jobs\n\t\t// The admin list will need to be refreshed manually or via polling\n\t\tconsole.log(`[BG-PROCESSOR] Chapter ${chapterId} completed successfully`);\n\t} catch (error: any) {\n\t\tconsole.error(\n\t\t\t`[BG-PROCESSOR] Error processing chapter ${chapterId}:`,\n\t\t\terror\n\t\t);\n\n\t\t// Update status to FAILED with error message\n\t\tawait prisma.chapter.update({\n\t\t\twhere: { id: bigChapterId },\n\t\t\tdata: {\n\t\t\t\tprocessing_status: \"FAILED\",\n\t\t\t\terror_message: error.message || \"Unknown error during processing\",\n\t\t\t},\n\t\t});\n\n\t\t// revalidatePath is not supported in background jobs\n\n\t\tthrow error;\n\t}\n}\n\n/**\n * Process multiple chapters in sequence\n */\nexport async function processBatchChapters(jobs: ChapterProcessingJob[]) {\n\tconst results = [];\n\n\tfor (const job of jobs) {\n\t\ttry {\n\t\t\tawait processChapterBackground(job);\n\t\t\tresults.push({ chapterId: job.chapterId, success: true });\n\t\t} catch (error) {\n\t\t\tresults.push({\n\t\t\t\tchapterId: job.chapterId,\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t\t});\n\t\t}\n\t}\n\n\treturn results;\n}\n","\"use server\";\n\nimport {\n\tprocessChapterBackground,\n\ttype ChapterProcessingJob,\n} from \"@/lib/chapter-processor\";\nimport { prisma } from \"@/lib/prisma\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth-options\";\nimport { isAdmin } from \"@/lib/auth\";\n\n/**\n * Create chapters with PENDING status and trigger background processing\n */\nexport async function batchCreateChaptersAsync(formData: FormData) {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user || !isAdmin((session.user as any).role)) {\n\t\treturn { success: false, error: \"Unauthorized\" };\n\t}\n\n\ttry {\n\t\tconst subjectId = formData.get(\"subjectId\") as string;\n\t\tconst chapters = JSON.parse(formData.get(\"chapters\") as string);\n\t\tconst fullPages = JSON.parse(formData.get(\"fullPages\") as string);\n\t\tconst file = formData.get(\"file\") as File;\n\t\tconst accessibleBoards = formData.getAll(\"accessibleBoards\") as string[];\n\t\tconst questionConfigStr = formData.get(\"questionConfig\") as string;\n\t\tconst questionConfig = questionConfigStr ? JSON.parse(questionConfigStr) : undefined;\n\n\t\tif (!file || !subjectId || !chapters || chapters.length === 0) {\n\t\t\treturn { success: false, error: \"Missing required fields\" };\n\t\t}\n\n\t\t// Get subject to derive board from hierarchy (Board → Program → Subject → Chapter)\n\t\tconst subject = await prisma.subject.findUnique({\n\t\t\twhere: { id: parseInt(subjectId) },\n\t\t\tinclude: {\n\t\t\t\tprogram: {\n\t\t\t\t\tinclude: {\n\t\t\t\t\t\tboard: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (!subject) {\n\t\t\treturn { success: false, error: \"Subject not found\" };\n\t\t}\n\n\t\t// Auto-derive board from subject's program (unless explicitly set to global)\n\t\tconst subjectBoardId = subject.program.board_id;\n\t\tconst isGlobal = accessibleBoards.includes(\"GLOBAL\");\n\n\t\t// If global is selected, use empty array\n\t\t// If specific boards are selected, use those\n\t\t// Otherwise, auto-populate with subject's program's board\n\t\tconst finalAccessibleBoards = isGlobal\n\t\t\t? []\n\t\t\t: accessibleBoards.length > 0\n\t\t\t\t? accessibleBoards.filter((b) => b !== \"GLOBAL\")\n\t\t\t\t: [subjectBoardId]; // Auto-add subject's board if not specified\n\n\t\t// Read PDF file buffer\n\t\tconst pdfBuffer = Buffer.from(await file.arrayBuffer());\n\n\t\tconst createdChapterIds: string[] = [];\n\t\tconst processingJobs: ChapterProcessingJob[] = [];\n\n\t\t// Create all chapters with PENDING status\n\t\tfor (const detectedChapter of chapters) {\n\t\t\tconst chapter = await prisma.chapter.create({\n\t\t\t\tdata: {\n\t\t\t\t\ttitle: detectedChapter.title,\n\t\t\t\t\tsubject_id: parseInt(subjectId),\n\t\t\t\t\tchapter_number: detectedChapter.chapterNumber,\n\t\t\t\t\tcontent_json: [], // Empty for now, will be filled by background processor\n\t\t\t\t\taccessible_boards: finalAccessibleBoards,\n\t\t\t\t\tis_global: isGlobal,\n\t\t\t\t\tis_active: true, // Explicitly set to true\n\t\t\t\t\tprocessing_status: \"PENDING\",\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tcreatedChapterIds.push(chapter.id.toString());\n\n\t\t\t// Prepare background processing job\n\t\t\tprocessingJobs.push({\n\t\t\t\tchapterId: chapter.id.toString(),\n\t\t\t\tpdfBuffer,\n\t\t\t\tfileName: file.name,\n\t\t\t\tstartPage: detectedChapter.startPage,\n\t\t\t\tendPage: detectedChapter.endPage,\n\t\t\t\tquestionConfig,\n\t\t\t});\n\t\t}\n\n\t\t// Trigger background processing (fire and forget)\n\t\t// Note: In production, you'd use a proper queue like BullMQ\n\t\tsetImmediate(async () => {\n\t\t\tfor (const job of processingJobs) {\n\t\t\t\ttry {\n\t\t\t\t\tawait processChapterBackground(job);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(`Failed to process chapter ${job.chapterId}:`, error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: `Created ${chapters.length} chapter(s) - Processing in background`,\n\t\t\tchapterIds: createdChapterIds,\n\t\t};\n\t} catch (error: any) {\n\t\tconsole.error(\"Error creating chapters:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error.message || \"Failed to create chapters\",\n\t\t};\n\t}\n}\n\n/**\n * Ingest a single chapter asynchronously\n * - Creates chapter with PENDING status\n * - Triggers background processing for the whole file\n */\nexport async function ingestChapterAsync(formData: FormData) {\n\tconst session = await getServerSession(authOptions);\n\tif (!session?.user || !isAdmin((session.user as any).role)) {\n\t\treturn { success: false, error: \"Unauthorized\" };\n\t}\n\n\ttry {\n\t\tconst file = formData.get(\"file\") as File;\n\t\tconst title = formData.get(\"title\") as string;\n\t\tconst subjectId = formData.get(\"subjectId\") as string;\n\t\tconst chapterNumber = formData.get(\"chapterNumber\") as string;\n\t\tconst accessibleBoards = formData.getAll(\"accessibleBoards\") as string[];\n\t\tconst questionConfigStr = formData.get(\"questionConfig\") as string;\n\t\tconst questionConfig = questionConfigStr ? JSON.parse(questionConfigStr) : undefined;\n\n\t\tif (!file || !title || !subjectId) {\n\t\t\treturn { success: false, error: \"Missing required fields\" };\n\t\t}\n\n\t\t// Get subject to derive board\n\t\tconst subject = await prisma.subject.findUnique({\n\t\t\twhere: { id: parseInt(subjectId) },\n\t\t\tinclude: {\n\t\t\t\tprogram: {\n\t\t\t\t\tinclude: {\n\t\t\t\t\t\tboard: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tif (!subject) {\n\t\t\treturn { success: false, error: \"Subject not found\" };\n\t\t}\n\n\t\tconst subjectBoardId = subject.program.board_id;\n\t\tconst isGlobal = accessibleBoards.includes(\"GLOBAL\");\n\n\t\tconst finalAccessibleBoards = isGlobal\n\t\t\t? []\n\t\t\t: accessibleBoards.length > 0\n\t\t\t\t? accessibleBoards.filter((b) => b !== \"GLOBAL\")\n\t\t\t\t: [subjectBoardId];\n\n\t\t// Read PDF file buffer\n\t\tconst pdfBuffer = Buffer.from(await file.arrayBuffer());\n\n\t\t// Create chapter with PENDING status\n\t\tconst chapter = await prisma.chapter.create({\n\t\t\tdata: {\n\t\t\t\ttitle,\n\t\t\t\tsubject_id: parseInt(subjectId),\n\t\t\t\tchapter_number: chapterNumber ? parseInt(chapterNumber) : null,\n\t\t\t\tcontent_json: [], // Empty for now\n\t\t\t\taccessible_boards: finalAccessibleBoards,\n\t\t\t\tis_global: isGlobal,\n\t\t\t\tis_active: true,\n\t\t\t\tprocessing_status: \"PENDING\",\n\t\t\t},\n\t\t});\n\n\t\t// Trigger background processing (fire and forget)\n\t\tsetImmediate(async () => {\n\t\t\ttry {\n\t\t\t\tawait processChapterBackground({\n\t\t\t\t\tchapterId: chapter.id.toString(),\n\t\t\t\t\tpdfBuffer,\n\t\t\t\t\tfileName: file.name,\n\t\t\t\t\t// No start/end page means process whole document\n\t\t\t\t\tquestionConfig,\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(`Failed to process chapter ${chapter.id}:`, error);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"Chapter created - Processing in background\",\n\t\t\tchapterId: chapter.id.toString(),\n\t\t};\n\t} catch (error: any) {\n\t\tconsole.error(\"Error ingesting chapter:\", error);\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: error.message || \"Failed to ingest chapter\",\n\t\t};\n\t}\n}\n","export {ingestChapterAsync as '4054eccc7d78f138ed33536b4ab6af09891ec8d3ce'} from 'ACTIONS_MODULE0'\nexport {batchCreateChaptersAsync as '4008add61ba6e0f825c8aa3f65c3c51dc87e9799fa'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":"8CAAA,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,iBAuBO,eAAe,EAClB,CAAiB,CACjB,CAA8B,EAE9B,QAAQ,GAAG,CAAC,CAAC,gDAAgD,EAAE,EAAA,CAAW,EAE1E,GAAI,CACA,IAAM,EAAe,OAAO,GAGtB,EAAS,MAAM,EAAA,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAC9C,MAAO,CAAE,WAAY,CAAa,EAClC,QAAS,CAAE,YAAa,KAAM,EAC9B,OAAQ,CACJ,IAAI,EACJ,SAAS,EACT,aAAa,EACb,aAAa,CACjB,CACJ,GAEA,GAAI,AAAkB,MAAX,MAAM,CAAQ,YACrB,QAAQ,IAAI,CAAC,CAAC,4CAA4C,EAAE,EAAA,CAAW,EAO3E,IAAM,EAKA,EAAE,CAEJ,EAAsC,EAAE,CACxC,EAAmB,CAAM,CAAC,EAAE,CAAC,WAAW,EAAI,EAEhD,IAAK,IAAM,KAAS,EAAQ,CACxB,IAAM,EAAU,EAAM,WAAW,EAAI,CAKjC,GAAqB,MAAM,CAAG,IAC7B,CAAD,CAAW,EAlBO,GAkBiC,EAAU,CAAC,CAAoB,CAAC,EAAqB,MAAM,CAAG,AAAnF,EAAqF,CAAC,WAAW,GAAI,CAAC,EAAI,CAAC,GAC3I,AACE,EAAS,IAAI,CAAC,CACV,UAAW,EACX,QAAS,CAAoB,CAAC,EAAqB,MAAM,CAAG,EAAE,CAAC,WAAW,EAAI,EAC9E,QAAS,EAAqB,GAAG,CAAC,GAAK,EAAE,OAAO,EAAE,IAAI,CAAC,QACvD,SAAU,EAAqB,GAAG,CAAC,GAAK,EAAE,EAAE,CAChD,GACA,EAAuB,EAAE,CACzB,EAAmB,GAEvB,EAAqB,IAAI,CAAC,EAC9B,CAGI,EAAqB,MAAM,CAAG,GAAG,AACjC,EAAS,IAAI,CAAC,CACV,UAAW,EACX,QAAS,CAAoB,CAAC,EAAqB,MAAM,CAAG,EAAE,CAAC,WAAW,EAAI,EAC9E,QAAS,EAAqB,GAAG,CAAC,GAAK,EAAE,OAAO,EAAE,IAAI,CAAC,QACvD,SAAU,EAAqB,GAAG,CAAC,GAAK,EAAE,EAAE,CAChD,GAGJ,QAAQ,GAAG,CAAC,CAAC,mCAAmC,EAAE,EAAS,MAAM,CAAC,wBAAwB,CAAC,EAO3F,IAAM,EAAgB,EAAS,MAAM,CAU/B,EAAO,EAAS,GAAG,CAAC,CAAC,EAAS,KAChC,IAAM,EAAwC,CAC1C,KAAM,CAAC,EACP,OAAQ,CAAC,EACT,KAAM,CAAC,CACX,EAeA,MAZC,CAAC,OAAQ,SAAU,OAAO,CAAW,OAAO,CAAC,IAC1C,OAAO,OAAO,CAAC,CAAM,CAAC,EAAK,EAAE,OAAO,CAAC,CAAC,CAAC,EAAM,EAAM,OACzC,CAAE,MAAI,CAAE,WAAS,CAAE,CAd1B,CAAE,CAc2B,IAhBvB,KAAK,KAAK,CAAC,AAgBuB,EAhBf,GAEjB,UADG,EAAQ,CACD,EAgBX,EAAe,KAAQ,EAAD,AAAO,CAAA,EAE/B,EAF2C,AAE5B,GAAG,CAF6B,AAG/C,CAHgD,AAGnC,CAAC,EAAK,CAAC,EAAqB,CAAG,CAAA,CAEpD,EACJ,GAEO,SACH,EACA,OAAQ,CACZ,CACJ,GAKA,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,GADd,EACmB,AAAY,CAC9C,IAAM,EAAQ,EAAK,KAAK,CAAC,EAAG,IAAI,AAEhC,OAAM,QAAQ,GAAG,CAAC,EAAM,GAAG,CAAC,MAAO,IAG/B,GADqB,CACjB,CAAC,KADuB,MAAM,CAAC,EAAI,AACpB,MAD0B,EAAE,IAAI,CAAC,GAAK,OAAO,IAAI,CAAC,GAAG,MAAM,CAAG,IAGjF,QAAQ,GAAG,CAAC,CAAC,uDAAuD,EAAE,EAAI,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,EAAI,OAAO,CAAC,OAAO,CAAA,CAAE,EAEpH,GAAI,CACA,IAAM,EAAY,MAAM,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,CAC3C,QAAS,EAAI,OAAO,CAAC,OAAO,CAC5B,OAAQ,EAAI,MAAM,CAClB,aAAc,CAAC,MAAM,EAAE,EAAI,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,EAAI,OAAO,CAAC,OAAO,CAAA,CAAE,AACzE,CAD0E,EAItE,EAAU,MAAM,CAAG,GAAG,CACtB,EALuF,IAKjF,EAAA,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAC7B,KAAM,EAAU,GAAG,CAAC,IAAK,AAAC,CACtB,WAAY,EACZ,cAAe,EAAE,aAAa,CAC9B,cAAe,EAAE,aAAa,CAC9B,WAAY,EAAE,UAAU,CACxB,QAAS,EAAE,OAAO,CAAG,EAAE,OAAO,MAAG,EACjC,eAAgB,EAAE,cAAc,CAChC,YAAa,EAAE,WAAW,CAC1B,OAAQ,EAAE,MAAM,CAChB,WAAW,EACf,CAAC,CACL,GACA,QAAQ,GAAG,CAAC,CAAC,sBAAsB,EAAE,EAAU,MAAM,CAAC,6BAA6B,EAAE,EAAI,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,EAAI,OAAO,CAAC,OAAO,CAAA,CAAE,EAE3I,CAAE,MAAO,EAAO,CACZ,QAAQ,KAAK,CAAC,CAAC,qDAAqD,EAAE,EAAI,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,EAAI,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAE,EAE3H,EACJ,GACJ,CAEA,QAAQ,GAAG,CAAC,CAAC,iDAAiD,EAAE,EAAA,CAAW,CAE/E,CAAE,MAAO,EAAO,CAEZ,MADA,QAAQ,KAAK,CAAC,CAAC,4DAA4D,EAAE,EAAU,CAAC,CAAC,CAAE,GACrF,CACV,CACJ,qHCtLA,IAAA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,oBAcA,eAAe,EACd,CAAiB,CACjB,CAAyD,EAEzD,GAAI,CACH,IAAM,EAAe,OAAO,GAO5B,GAJiB,CAIb,KAJmB,EAAA,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,CACtD,MAAO,CAAE,WAAY,CAAa,CACnC,GAEc,YACb,QAAQ,GAAG,CAAC,CAAC,yDAAyD,EAAE,EAAU,UAAU,CAAC,EAK9F,IAAM,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAC/C,MAAO,CAAE,GAAI,CAAa,CAC3B,GAEA,GAAI,CAAC,EAAS,OAGd,IAAM,EAAe,EAAQ,YAAY,CACnC,EAAiB,EAAQ,IAAI,EAAI,EAAQ,QAAQ,EAAI,KAAK,SAAS,CAAC,GAGpE,EAA+B,CACpC,QAAS,EAAY,OAAO,CAAC,IAAI,CACjC,aAAc,EAAY,KAAK,CAC/B,QAAS,CACV,EAEM,EAAc,MAAM,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,GAQ3C,EAAgB,CALA,MAAM,QAAQ,GAAG,CACtC,EAAY,sBAAsB,CAAC,GAAG,CAAC,GACtC,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,OAAE,EAAO,WAAY,CAAE,IAAA,EAGT,IAAI,GAAG,KAAK,CAAC,EAAG,EAGpD,OAAM,EAAA,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,CACjC,KAAM,CACL,WAAY,EACZ,QAAS,CACR,MAAO,EAAY,gBAAgB,CACnC,WAAY,EAAY,SAAS,CAAC,GAAG,CAAC,GAAK,EAAE,IAAI,EACjD,mBAAoB,EAAY,kBAAkB,EAAI,EAAE,AACzD,EACA,YAAa,EAAY,SAAS,CAClC,WAAY,EAAY,UAAU,CAClC,SAAU,EAAY,gBAAgB,CACtC,cAAe,EAAY,sBAAsB,CACjD,eAAgB,CACjB,CACD,GAEA,QAAQ,GAAG,CAAC,CAAC,kEAAkE,EAAE,EAAA,CAAW,CAC7F,CAAE,MAAO,EAAO,CACf,QAAQ,KAAK,CAAC,CAAC,4DAA4D,EAAE,EAAU,CAAC,CAAC,CAAE,EAE5F,CACD,CASO,eAAe,EAAyB,CAAyB,EACvE,GAAM,WAAE,CAAS,WAAE,CAAS,CAAE,UAAQ,WAAE,CAAS,SAAE,CAAO,CAAE,CAAG,EACzD,EAAe,OAAO,GAE5B,GAAI,CAEH,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3B,MAAO,CAAE,GAAI,CAAa,EAC1B,KAAM,CACL,kBAAmB,aACnB,cAAe,IAChB,CACD,GAEA,IAAM,EAAY,GAAa,EAAU,CAAC,OAAO,EAAE,EAAU,CAAC,EAAE,EAAQ,CAAC,CAAC,CAAG,kBAC7E,QAAQ,GAAG,CAAC,CAAC,+CAA+C,EAAE,EAAU,CAAC,EAAE,EAAA,CAAW,EAGtF,IAAM,EAAe,CAAA,EAAA,EAAA,IAAA,AAAI,EACxB,CAAA,EAAA,EAAA,MAAA,AAAM,IACN,CAAC,QAAQ,EAAE,EAAU,CAAC,EAAE,KAAK,GAAG,GAAG,IAAI,CAAC,CAEzC,OAAM,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,EAAc,GAG9B,QAAQ,GAAG,CAAC,CAAC,oCAAoC,CAAC,EAClD,IAAM,EAAS,IAAI,EAAA,wBAAwB,CAKrC,EAAc,MAAM,EAAO,SAAS,CAAC,GAG3C,GACC,CAAC,GACD,CAAC,MAAM,OAAO,CAAC,IACf,AAAuB,GACtB,GADW,MAAM,CAElB,MAAU,AAAJ,MAAU,gCAIjB,IAAI,EAAe,EAMnB,QALkB,IAAd,GAA2B,KAAY,QAE1C,EAAe,CAFsC,CAE1B,MAAM,CAAC,GAAK,EAAE,IAAI,EAAI,GAAa,EAAE,IAAI,EAAI,EAAA,EAG7C,IAAxB,EAAa,MAAM,CAAQ,CAC9B,IAAM,EAAW,GAAa,EAAU,CAAC,SAAS,EAAE,EAAU,CAAC,EAAE,EAAA,CAAS,CAAG,aAE7E,OADA,QAAQ,IAAI,CAAC,CAAC,8BAA8B,EAAE,EAAS,6BAA6B,EAAE,EAAY,GAAG,CAAC,GAAK,EAAE,IAAI,EAAE,IAAI,CAAC,MAAA,CAAO,EACzH,AAAI,MAAM,CAAC,iBAAiB,EAAE,EAAA,CAAU,CAC/C,CAEA,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,EAAa,MAAM,CAAC,aAAa,EAAE,EAAY,MAAM,CAAC,OAAO,CAAC,EAGvG,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3B,MAAO,CAAE,GAAI,CAAa,EAC1B,KAAM,CACL,aAAc,EACd,UAAW,IAAI,IAChB,CACD,GAEA,QAAQ,GAAG,CAAC,CAAC,sBAAsB,EAAE,EAAa,MAAM,CAAC,MAAM,CAAC,EAkChE,IAAM,EAAgB,EAAE,CACxB,IAAK,IAAM,KAAY,EAAc,CACpC,IAAM,EAAQ,EAAS,KAAK,EAAI,EAAE,CAC5B,EAAY,EAAS,KAAK,EAAI,IAC9B,CADmC,CACtB,EAAS,MAAM,EAAI,IAGlC,CAHuC,CAGxB,GACf,EAL2D,AAKC,EAAE,CAElE,IAAK,IAAM,KAAQ,CAN+C,CAMxC,CACzB,GAAI,CAAC,EAAK,EAAE,EAA8B,IAA1B,EAAK,EAAE,CAAC,IAAI,GAAG,MAAM,CAAQ,SAE7C,IAAM,EAAO,EAAK,EAAE,CAAC,IAAI,GACzB,GAAgB,EAAO,OAGvB,IAAM,EAAW,EAAK,IAAI,EAAI,EAAK,IAAI,CACvC,GAAI,GAAgC,UAApB,AAA8B,OAAvB,EACtB,GACuB,UAAtB,OAAO,EAAS,CAAC,EACjB,AAAsB,iBAAf,EAAS,CAAC,EACK,UAAtB,OAAO,EAAS,CAAC,EACjB,AAAsB,iBAAf,EAAS,CAAC,CAChB,CACD,IAAM,EAAO,AAvDjB,SAAS,AACR,CAAoD,CACpD,EAA0B,GAAG,CAC7B,EAA2B,GAAG,EAG9B,IAAM,EAAI,EAAK,CAAC,EAAI,EACd,EAAI,EAAK,CAAC,EAAI,EACd,EAAI,EAAK,CAAC,EAAI,EACd,EAAI,EAAK,CAAC,EAAI,EAWpB,OARI,GAAmB,GAAK,IAAoB,GAAG,CAClD,QAAQ,IAAI,CACX,CAAC,wCAAwC,EAAE,EAAgB,CAAC,EAAE,EAAiB,gBAAgB,CAAC,EAEjG,EAAkB,IAClB,EAAmB,KAGb,CACN,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,EAAG,EAAI,IAC5B,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,EAAG,EAAI,IAC5B,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,EAAG,EAAI,IAC5B,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,EAAG,EAAI,IAC5B,AACF,EA6B0C,EAAU,EAAW,GAE3D,EAAiB,IAAI,CAAC,CACrB,KAFmB,CAEb,CACN,IAHyB,CAGnB,CACP,EACD,MACC,CADM,OACE,IAAI,CACX,CAAC,UAP0D,6CAOH,EAAE,EAAS,IAAI,CAAC,CAAC,CAAC,CAC1E,EAIJ,CAGI,CAAC,EAAa,IAAI,KAAO,CAAD,CAAU,IAAI,EAAI,EAAS,EAAA,AAAE,GAAG,CAC3D,EAAe,CAAC,EAAS,IAAI,EAAI,EAAS,EAAE,EAAI,EAAA,CAAE,CAAE,IAAI,EAAA,EAIpD,EAAa,IAAI,IAAI,AAM1B,EAAO,IAAI,CAAC,CACX,QAAS,EAAa,IAAI,GAC1B,YAAa,EAAS,IAAI,CAC1B,KAAM,EAAiB,MAAM,CAAG,EAAI,EAAmB,IACxD,EACD,CAEA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,EAAO,MAAM,CAAC,sBAAsB,CAAC,EAG3E,IAAM,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAC/C,MAAO,CAAE,GAAI,CAAa,EAC1B,OAAQ,CAAE,YAAY,EAAM,mBAAmB,EAAM,WAAW,CAAK,CACtE,GAEA,GAAI,CAAC,EAAS,MAAM,AAAI,MAAM,qBAE9B,IAAM,EAAgB,MAAM,QAAQ,GAAG,CACtC,EAAO,GAAG,CAAC,CAAC,EAAO,IAClB,EAAA,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,CAC1B,KAAM,CACL,WAAY,EACZ,YAAa,EACb,QAAS,EAAM,OAAO,CACtB,YAAa,EAAM,WAAW,CAC9B,KAAM,EAAM,IAAI,CAChB,WAAY,EAAQ,UAAU,AAC/B,CACD,KAUF,GANA,QAAQ,GAAG,CACV,CAAC,wBAAwB,EAAE,EAAc,MAAM,CAAC,eAAe,CAAC,EAK7D,CAAC,EAAQ,SAAS,EAAI,EAAQ,iBAAiB,CAAC,MAAM,CAAG,EAAG,CAC/D,QAAQ,GAAG,CACV,CAAC,iDAAiD,EAAE,EAAc,MAAM,CAAC,UAAU,CAAC,EAGrF,IAAM,EAAe,EAAE,CACvB,IAAK,IAAM,KAAS,EACnB,IAAK,IAAM,IADuB,CACZ,EAAQ,iBAAiB,CAAE,AAChD,EAAa,IAAI,CAAC,CACjB,SAAU,EAAM,EAAE,CAClB,SAAU,CACX,GAKE,EAAa,MAAM,CAAG,GAAG,CAC5B,MAAM,EAAA,MAAM,CAAC,iBAAiB,CAAC,UAAU,CAAC,CACzC,KAAM,CACP,GACA,QAAQ,GAAG,CACV,CAAC,uBAAuB,EAAE,EAAa,MAAM,CAAC,qBAAqB,CAAC,EAGvE,MAAW,CAAJ,CAAY,SAAS,CAC3B,CAD6B,OACrB,GAAG,CACV,CAAC,+DAA+D,CAAC,EAGlE,QAAQ,IAAI,CACX,CAAC,iGAAiG,CAAC,EAKrG,IAAM,EAAc,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CACnD,MAAO,CAAE,GAAI,CAAa,EAC1B,OAAQ,CACP,OAAO,EACP,QAAS,CACR,OAAQ,CACP,MAAM,CACP,CACD,CACD,CACD,GAEA,GAAI,CAAC,EACJ,MAAM,AAAI,KADO,CACD,2CAMjB,IAAK,IAAM,KAFX,QAAQ,GAAG,CAAC,CAAC,0DAA0D,CAAC,EAEpD,GAAe,CAElC,IAAM,EAAY,MAAM,EAAA,qBAAqB,CAAC,iBAAiB,CAC9D,EAAM,OAAO,CAOd,OAAM,EAAA,MAAM,CAAC,WAAW,CAAC;;sCAEU,EAAE,KAAK,SAAS,CAAC,GAAW;8EACY,EAAE,EAAY,KAAK,EAAI,GAChG;6EACwE,EAAE,EAAY,OAAO,CAAC,IAAI,EAAI,GACtG;6EACwE,EAAE,EAAM,OAAO,EAAI,GAC3F;2BACsB,EAAE,EAAM,EAAE,CAAC;YAC1B,CAAC,AACX,CAEA,QAAQ,GAAG,CACV,CAAC,qEAAqE,CAAC,EAIxE,QAAQ,GAAG,CAAC,CAAC,6CAA6C,CAAC,EAC3D,IAAM,EAAY,CAAA,EAAA,EAAA,IAAA,AAAI,EAAC,CAAA,EAAA,EAAA,MAAA,AAAM,IAAI,CAAC,QAAQ,EAAE,EAAU,OAAO,CAAC,EACxD,EAAa,MAAM,CAAA,EAAA,EAAA,kBAAA,AAAkB,EAC1C,EACA,EACA,EACA,EACA,GAGK,EAAY,MAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,EACvC,EACA,CAAC,QAAQ,EAAE,EAAA,CAAW,EAIjB,EAAc,EAAY,GAAG,CAAC,AAAC,IAAe,CACnD,EADkD,SACtC,EACZ,YAAa,EAAK,IAAI,CACtB,UAAW,EAAU,GAAG,CAAC,EAAK,IAAI,GAAK,GACvC,MAAO,EAAK,KAAK,EAAI,KACrB,OAAQ,EAAK,MAAM,EAAI,KACxB,CAAC,CAED,OAAM,EAAA,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC,CACnC,KAAM,CACP,GAEA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,EAAY,MAAM,CAAC,aAAa,CAAC,EAGvE,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,GAGb,QAAQ,GAAG,CAAC,CAAC,4CAA4C,CAAC,EAC1D,MAAM,EAAiC,EAAW,GAClD,QAAQ,GAAG,CAAC,CAAC,qDAAqD,EAAE,EAAA,CAAW,EAG3E,EAAI,cAAc,EAAE,CACvB,QAAQ,GAAG,CAAC,CAAC,0CAA0C,CAAC,EACxD,MAAM,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,EAAW,EAAI,cAAc,EACxD,QAAQ,GAAG,CAAC,CAAC,mDAAmD,EAAE,EAAA,CAAW,GAI9E,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3B,MAAO,CAAE,GAAI,CAAa,EAC1B,KAAM,CACL,kBAAmB,YACnB,aAAc,IAAI,KAClB,cAAe,IAChB,CACD,GAIA,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,EAAU,uBAAuB,CAAC,CACzE,CAAE,MAAO,EAAY,CAiBpB,MAhBA,QAAQ,KAAK,CACZ,CAAC,wCAAwC,EAAE,EAAU,CAAC,CAAC,CACvD,GAID,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3B,MAAO,CAAE,GAAI,CAAa,EAC1B,KAAM,CACL,kBAAmB,SACnB,cAAe,EAAM,OAAO,EAAI,iCACjC,CACD,GAIM,CACP,CACD,+ICpcA,EAAA,EAAA,CAAA,CAAA,QAIA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,+BAKO,eAAe,EAAyB,CAAkB,EAChE,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAA,WAAW,EAClD,GAAI,CAAC,GAAS,MAAQ,CAAC,CAAA,EAAA,EAAA,OAAA,AAAO,EAAE,EAAQ,IAAI,CAAS,IAAI,EACxD,CAD2D,KACpD,CAAE,SAAS,EAAO,MAAO,cAAe,EAGhD,GAAI,CACH,IAAM,EAAY,EAAS,GAAG,CAAC,aACzB,EAAW,KAAK,KAAK,CAAC,EAAS,GAAG,CAAC,aACvB,KAAK,KAAK,CAAC,EAAS,GAAG,CAAC,cAC1C,IAAM,EAAO,EAAS,GAAG,CAAC,QACpB,EAAmB,EAAS,MAAM,CAAC,oBACnC,EAAoB,EAAS,GAAG,CAAC,kBACjC,EAAiB,EAAoB,KAAK,KAAK,CAAC,QAAqB,EAE3E,GAAI,CAAC,GAAQ,CAAC,GAAa,CAAC,GAAgC,GAAG,CAAvB,EAAS,MAAM,CACtD,MAAO,CAAE,SAAS,EAAO,MAAO,yBAA0B,EAI3D,IAAM,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAC/C,MAAO,CAAE,GAAI,SAAS,EAAW,EACjC,QAAS,CACR,QAAS,CACR,QAAS,CACR,OAAO,CACR,CACD,CACD,CACD,GAEA,GAAI,CAAC,EACJ,MAAO,CADM,AACJ,SAAS,EAAO,MAAO,mBAAoB,EAIrD,IAAM,EAAiB,EAAQ,OAAO,CAAC,QAAQ,CACzC,EAAW,EAAiB,QAAQ,CAAC,UAKrC,EAAwB,EAC3B,EAAE,CACF,EAAiB,MAAM,CAAG,EACzB,EAAiB,MAAM,CAAC,AAAC,GAAY,WAAN,GAC/B,CAAC,EAAe,CAGd,CAHgB,CAGJ,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,IAE9C,EAA8B,EAAE,CAChC,EAAyC,CANmB,CAMjB,CAGjD,IAAK,IAAM,KAAmB,EAAU,CACvC,IAAM,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3C,KAAM,CACL,MAAO,EAAgB,KAAK,CAC5B,WAAY,SAAS,GACrB,eAAgB,EAAgB,aAAa,CAC7C,aAAc,EAAE,CAChB,kBAAmB,EACnB,UAAW,EACX,WAAW,EACX,kBAAmB,SACpB,CACD,GAEA,EAAkB,IAAI,CAAC,EAAQ,EAAE,CAAC,QAAQ,IAG1C,EAAe,IAAI,CAAC,CACnB,UAAW,EAAQ,EAAE,CAAC,QAAQ,aAC9B,EACA,SAAU,EAAK,IAAI,CACnB,UAAW,EAAgB,SAAS,CACpC,QAAS,EAAgB,OAAO,CAChC,gBACD,EACD,CAcA,OAVA,aAAa,UACZ,IAAK,IAAM,KAAO,EACjB,GAAI,CACH,MAAM,CAAA,EAF0B,AAE1B,EAAA,wBAAA,AAAwB,EAAC,EAChC,CAAE,MAAO,EAAO,CACf,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,EAAI,SAAS,CAAC,CAAC,CAAC,CAAE,EAC9D,CAEF,GAEO,CACN,SAAS,EACT,QAAS,CAAC,QAAQ,EAAE,EAAS,MAAM,CAAC,sCAAsC,CAAC,CAC3E,WAAY,CACb,CACD,CAAE,MAAO,EAAY,CAEpB,OADA,QAAQ,KAAK,CAAC,2BAA4B,GACnC,CACN,SAAS,EACT,MAAO,EAAM,OAAO,EAAI,2BACzB,CACD,CACD,CAOO,eAAe,EAAmB,CAAkB,EAC1D,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAA,WAAW,EAClD,GAAI,CAAC,GAAS,MAAQ,CAAC,CAAA,EAAA,EAAA,OAAA,AAAO,EAAE,EAAQ,IAAI,CAAS,IAAI,EACxD,CAD2D,KACpD,CAAE,SAAS,EAAO,MAAO,cAAe,EAGhD,GAAI,CACH,IAAM,EAAO,EAAS,GAAG,CAAC,QACpB,EAAQ,EAAS,GAAG,CAAC,SACrB,EAAY,EAAS,GAAG,CAAC,aACzB,EAAgB,EAAS,GAAG,CAAC,iBAC7B,EAAmB,EAAS,MAAM,CAAC,oBACnC,EAAoB,EAAS,GAAG,CAAC,kBACjC,EAAiB,EAAoB,KAAK,KAAK,CAAC,QAAqB,EAE3E,GAAI,CAAC,GAAQ,CAAC,GAAS,CAAC,EACvB,MAAO,CAAE,EADyB,OAChB,EAAO,MAAO,yBAA0B,EAI3D,IAAM,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAC/C,MAAO,CAAE,GAAI,SAAS,EAAW,EACjC,QAAS,CACR,QAAS,CACR,QAAS,CACR,OAAO,CACR,CACD,CACD,CACD,GAEA,GAAI,CAAC,EACJ,MAAO,CAAE,AADI,SACK,EAAO,MAAO,mBAAoB,EAGrD,IAAM,EAAiB,EAAQ,OAAO,CAAC,QAAQ,CACzC,EAAW,EAAiB,QAAQ,CAAC,UAErC,EAAwB,EAC3B,EAAE,CACF,EAAiB,MAAM,CAAG,EACzB,EAAiB,MAAM,CAAE,AAAD,GAAa,WAAN,GAC/B,CAAC,EAAe,CAGd,EAAY,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,IAG9C,EAAU,MAAM,EAAA,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3C,KAAM,OACL,EACA,WAAY,SAAS,GACrB,eAAgB,EAAgB,SAAS,GAAiB,KAC1D,aAAc,EAAE,CAChB,kBAAmB,EACnB,UAAW,EACX,WAAW,EACX,kBAAmB,SACpB,CACD,GAiBA,OAdA,aAAa,UACZ,GAAI,CACH,MAAM,CAAA,EAAA,EAAA,wBAAA,AAAwB,EAAC,CAC9B,UAAW,EAAQ,EAAE,CAAC,QAAQ,aAC9B,EACA,SAAU,EAAK,IAAI,gBAEnB,CACD,EACD,CAAE,MAAO,EAAO,CACf,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,EAAQ,EAAE,CAAC,CAAC,CAAC,CAAE,EAC3D,CACD,GAEO,CACN,QAAS,GACT,QAAS,6CACT,UAAW,EAAQ,EAAE,CAAC,QAAQ,EAC/B,CACD,CAAE,MAAO,EAAY,CAEpB,OADA,QAAQ,KAAK,CAAC,2BAA4B,GACnC,CACN,SAAS,EACT,MAAO,EAAM,OAAO,EAAI,0BACzB,CACD,CACD,0DAzMsB,EAiHA,IAjHA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MAiHA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,gIC/HtB,IAAA,EAAA,EAAA,CAAA,CAAA"}