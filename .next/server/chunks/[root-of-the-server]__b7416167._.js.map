{"version":3,"sources":["../../../src/lib/db.ts","../../../src/lib/prisma.ts","turbopack:///[project]/node_modules/openid-client/package.json","../../../node_modules/next-auth/core/types.js","../../../node_modules/next-auth/index.js","../../../src/lib/semantic-vector.ts","../../../node_modules/%40vercel/oidc/dist/token-error.js","../../../src/lib/app-settings.ts","../../../src/lib/supabase.ts","../../../src/lib/battle-service.ts","../../../node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts","../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../src/lib/quiz-cache.ts"],"sourcesContent":["import { PrismaClient } from '../generated/prisma';\n\n// Define the global type for PrismaClient\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\n// PrismaClient is attached to the `global` object in development to prevent\n// exhausting your database connection limit.\nexport const db = global.prisma || new PrismaClient();\n\n// In development, keep the connection alive between hot reloads\nif (process.env.NODE_ENV !== 'production') global.prisma = db;\n","import { db } from \"./db\";\n\nexport const prisma = db;\nexport default prisma;\n","{\"name\":\"openid-client\",\"version\":\"5.7.1\",\"description\":\"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs\",\"keywords\":[\"auth\",\"authentication\",\"basic\",\"certified\",\"client\",\"connect\",\"dynamic\",\"electron\",\"hybrid\",\"identity\",\"implicit\",\"oauth\",\"oauth2\",\"oidc\",\"openid\",\"passport\",\"relying party\",\"strategy\"],\"homepage\":\"https://github.com/panva/openid-client\",\"repository\":\"panva/openid-client\",\"funding\":{\"url\":\"https://github.com/sponsors/panva\"},\"license\":\"MIT\",\"author\":\"Filip Skokan <panva.ip@gmail.com>\",\"exports\":{\"types\":\"./types/index.d.ts\",\"import\":\"./lib/index.mjs\",\"require\":\"./lib/index.js\"},\"main\":\"./lib/index.js\",\"types\":\"./types/index.d.ts\",\"files\":[\"lib\",\"types/index.d.ts\"],\"scripts\":{\"format\":\"npx prettier --loglevel silent --write ./lib ./test ./certification ./types\",\"test\":\"mocha test/**/*.test.js\"},\"dependencies\":{\"jose\":\"^4.15.9\",\"lru-cache\":\"^6.0.0\",\"object-hash\":\"^2.2.0\",\"oidc-token-hash\":\"^5.0.3\"},\"devDependencies\":{\"@types/node\":\"^16.18.106\",\"@types/passport\":\"^1.0.16\",\"base64url\":\"^3.0.1\",\"chai\":\"^4.5.0\",\"mocha\":\"^10.7.3\",\"nock\":\"^13.5.5\",\"prettier\":\"^2.8.8\",\"readable-mock-req\":\"^0.2.2\",\"sinon\":\"^9.2.4\",\"timekeeper\":\"^2.3.1\"},\"standard-version\":{\"scripts\":{\"postchangelog\":\"sed -i '' -e 's/### \\\\[/## [/g' CHANGELOG.md\"},\"types\":[{\"type\":\"feat\",\"section\":\"Features\"},{\"type\":\"fix\",\"section\":\"Fixes\"},{\"type\":\"chore\",\"hidden\":true},{\"type\":\"docs\",\"hidden\":true},{\"type\":\"style\",\"hidden\":true},{\"type\":\"refactor\",\"section\":\"Refactor\",\"hidden\":false},{\"type\":\"perf\",\"section\":\"Performance\",\"hidden\":false},{\"type\":\"test\",\"hidden\":true}]}}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {};\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return _next.default;\n  }\n});\nvar _types = require(\"./core/types\");\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\nvar _next = _interopRequireWildcard(require(\"./next\"));\nObject.keys(_next).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _next[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _next[key];\n    }\n  });\n});\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }","// semantic-vector.ts\nimport { pipeline } from \"@xenova/transformers\";\nimport { db as prisma } from \"./db\";\n\n// Define the model we want to use.\n// 'Xenova/all-MiniLM-L6-v2' is standard for RAG: fast, small (23MB), and accurate.\nconst EMBEDDING_MODEL = \"Xenova/all-MiniLM-L6-v2\";\n\nexport class SemanticVectorService {\n\t// Singleton instance of the embedder pipeline to avoid reloading model on every call\n\tprivate static embedder: any = null;\n\n\t/**\n\t * Initialize the local embedding pipeline.\n\t * This downloads the model files (once) and caches them.\n\t */\n\tstatic async initialize() {\n\t\tif (!this.embedder) {\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Initializing local embedder model: ${EMBEDDING_MODEL}...`\n\t\t\t);\n\t\t\tthis.embedder = await pipeline(\"feature-extraction\", EMBEDDING_MODEL);\n\t\t\tconsole.log(\"[SEMANTIC] Embedder initialized successfully\");\n\t\t}\n\t}\n\n\t/**\n\t * Generates a vector embedding locally using Transformers.js\n\t * No API limits, no costs.\n\t */\n\tstatic async generateEmbedding(text: string): Promise<number[]> {\n\t\tawait this.initialize();\n\n\t\tif (!text || !text.trim()) {\n\t\t\tthrow new Error(\"Text is required for embedding generation\");\n\t\t}\n\n\t\t// 1. Pre-process text:\n\t\t// Replace newlines to keep semantic meaning consistent and trim\n\t\tconst cleanedText = text.replace(/\\n+/g, \" \").trim();\n\n\t\t// 2. Truncate text to avoid model limits (512 tokens approx ~2000 chars)\n\t\t// We truncate to 2000 characters to be safe.\n\t\t// For full document search, you should ideally chunk the document and average the vectors,\n\t\t// but for a simple file-level vector, truncating the first 2000 chars (header + summary) works well.\n\t\tconst truncatedText = cleanedText.substring(0, 2000);\n\n\t\ttry {\n\t\t\t// 3. Run inference\n\t\t\tconst result = await this.embedder(truncatedText, {\n\t\t\t\tpooling: \"mean\", // Average the token vectors to get one sentence vector\n\t\t\t\tnormalize: true, // Important for cosine similarity\n\t\t\t});\n\n\t\t\t// 4. Convert Float32Array to regular number array\n\t\t\treturn Array.from(result.data);\n\t\t} catch (error) {\n\t\t\tconsole.error(\"[SEMANTIC] Error generating embedding:\", error);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the semantic vector for a specific file.\n\t * @deprecated This function references the old file_list table. Use chapter-processor.ts for chapter chunks instead.\n\t */\n\tstatic async updateSemanticVector(fileId: number) {\n\t\ttry {\n\t\t\tconst file = await prisma.fileList.findUnique({\n\t\t\t\twhere: { id: fileId },\n\t\t\t\tselect: { title: true, category: true, note: true },\n\t\t\t});\n\n\t\t\tif (!file) {\n\t\t\t\tthrow new Error(`File with ID ${fileId} not found`);\n\t\t\t}\n\n\t\t\t// Combine fields.\n\t\t\t// Tip: Put the most important keywords (Title/Category) FIRST\n\t\t\t// because truncation happens at the end.\n\t\t\tconst textToEmbed = `Title: ${file.title}. Category: ${file.category\n\t\t\t\t}. Content: ${file.note || \"\"}`;\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Generating vector for file ${fileId} (${textToEmbed.length} chars)...`\n\t\t\t);\n\n\t\t\tconst embedding = await this.generateEmbedding(textToEmbed);\n\n\t\t\t// Update DB using raw query for pgvector compatibility\n\t\t\tawait prisma.$executeRaw`\n\t\t\t\tUPDATE file_list\n\t\t\t\tSET semantic_vector = ${JSON.stringify(embedding)}::vector\n\t\t\t\tWHERE id = ${fileId}\n\t\t\t`;\n\n\t\t\tconsole.log(`[SEMANTIC] Successfully updated vector for file ${fileId}`);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[SEMANTIC] Failed to update vector for file ${fileId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t\t// Don't throw here if this is part of a background batch job, just log it.\n\t\t\t// throw error;\n\t\t}\n\t}\n\n\t/**\n\t * Generate semantic vectors for file chunks\n\t * @deprecated This function references the old file_chunks table. Use chapter-processor.ts for chapter chunks instead.\n\t */\n\tstatic async generateChunkVectors(fileId: number) {\n\t\ttry {\n\t\t\t// Get all chunks for this file\n\t\t\tconst chunks = await prisma.fileChunk.findMany({\n\t\t\t\twhere: { file_id: fileId },\n\t\t\t\tselect: { id: true, content: true },\n\t\t\t});\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Generating vectors for ${chunks.length} chunks of file ${fileId}...`\n\t\t\t);\n\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst embedding = await this.generateEmbedding(chunk.content);\n\n\t\t\t\t\t// Update chunk's semantic vector\n\t\t\t\t\tawait prisma.$executeRaw`\n\t\t\t\t\t\tUPDATE file_chunks\n\t\t\t\t\t\tSET semantic_vector = ${JSON.stringify(embedding)}::vector\n\t\t\t\t\t\tWHERE id = ${chunk.id}\n\t\t\t\t\t`;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`[SEMANTIC] Failed to generate vector for chunk ${chunk.id}:`,\n\t\t\t\t\t\terr\n\t\t\t\t\t);\n\t\t\t\t\t// Continue with other chunks\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(\n\t\t\t\t`[SEMANTIC] Successfully updated vectors for file ${fileId} chunks`\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconsole.error(\n\t\t\t\t`[SEMANTIC] Failed to generate chunk vectors for file ${fileId}:`,\n\t\t\t\terror\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Batch/Repair function: Find all files missing vectors and generate them.\n\t * @deprecated This function references the old file_list table. Use updateSearchVectors() in ai-service-enhanced.ts for chapter chunks instead.\n\t */\n\tstatic async batchUpdateSemanticVectors() {\n\t\tconsole.log(\"[SEMANTIC] Starting batch update for missing vectors...\");\n\n\t\t// Find IDs where vector is NULL\n\t\tconst records = await prisma.$queryRaw<{ id: number }[]>`\n\t\t\tSELECT id FROM file_list WHERE semantic_vector IS NULL\n\t\t`;\n\n\t\tconsole.log(`[SEMANTIC] Found ${records.length} records to update.`);\n\n\t\tfor (const record of records) {\n\t\t\tawait this.updateSemanticVector(record.id);\n\t\t}\n\n\t\tconsole.log(\"[SEMANTIC] Batch update completed.\");\n\t}\n}\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar token_error_exports = {};\n__export(token_error_exports, {\n  VercelOidcTokenError: () => VercelOidcTokenError\n});\nmodule.exports = __toCommonJS(token_error_exports);\nclass VercelOidcTokenError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.name = \"VercelOidcTokenError\";\n    this.cause = cause;\n  }\n  toString() {\n    if (this.cause) {\n      return `${this.name}: ${this.message}: ${this.cause}`;\n    }\n    return `${this.name}: ${this.message}`;\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  VercelOidcTokenError\n});\n","import prisma from \"@/lib/prisma\";\n\n// Minimal settings store using raw SQL to avoid Prisma schema changes.\n// It lazily creates the table `app_settings` if it does not exist, concurrency-safe.\n\nlet ensureOncePromise: Promise<void> | null = null;\nasync function ensureTableOnce(): Promise<void> {\n  if (ensureOncePromise) return ensureOncePromise;\n  ensureOncePromise = (async () => {\n    try {\n      // Serialize DDL using a Postgres advisory lock to avoid concurrent DDL conflicts\n      await prisma.$executeRawUnsafe(\n        `SELECT pg_advisory_lock(hashtext('cid_ai_app_settings_ddl_lock'));`\n      );\n      try {\n        await prisma.$executeRawUnsafe(\n          `CREATE TABLE IF NOT EXISTS app_settings (\n            key TEXT PRIMARY KEY,\n            value TEXT NOT NULL,\n            created_at TIMESTAMPTZ DEFAULT NOW(),\n            updated_at TIMESTAMPTZ DEFAULT NOW()\n          );`\n        );\n        await prisma.$executeRawUnsafe(\n          `CREATE OR REPLACE FUNCTION set_updated_at()\n           RETURNS TRIGGER AS $$\n           BEGIN\n             NEW.updated_at = NOW();\n             RETURN NEW;\n           END;\n           $$ LANGUAGE plpgsql;`\n        );\n        await prisma.$executeRawUnsafe(\n          `DO $$\n           BEGIN\n             IF NOT EXISTS (\n               SELECT 1 FROM pg_trigger WHERE tgname = 'app_settings_set_updated_at'\n             ) THEN\n               CREATE TRIGGER app_settings_set_updated_at\n               BEFORE UPDATE ON app_settings\n               FOR EACH ROW EXECUTE FUNCTION set_updated_at();\n             END IF;\n           END $$;`\n        );\n      } finally {\n        await prisma.$executeRawUnsafe(\n          `SELECT pg_advisory_unlock(hashtext('cid_ai_app_settings_ddl_lock'));`\n        );\n      }\n    } catch (e) {\n      // Do not block; log and continue. If permissions disallow DDL, reads will just 404.\n      console.warn(\"[APP-SETTINGS] ensureTable failed (non-fatal)\", e);\n    }\n  })();\n  return ensureOncePromise;\n}\n\nexport async function getSetting(key: string): Promise<string | null> {\n  try {\n    await ensureTableOnce();\n    const rows: Array<{ value: string }> = await prisma.$queryRawUnsafe(\n      `SELECT value FROM app_settings WHERE key = $1 LIMIT 1`,\n      key\n    );\n    if (rows && rows.length > 0) return rows[0].value;\n    return null;\n  } catch (e) {\n    console.warn(\"[APP-SETTINGS] getSetting failed\", e);\n    return null;\n  }\n}\n\nexport async function setSetting(key: string, value: string): Promise<void> {\n  await ensureTableOnce();\n  await prisma.$executeRawUnsafe(\n    `INSERT INTO app_settings (key, value)\n     VALUES ($1, $2)\n     ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value`,\n    key,\n    value\n  );\n}\n\nexport async function getSettingInt(key: string, defaultValue: number): Promise<number> {\n  const v = await getSetting(key);\n  if (v == null) return defaultValue;\n  const n = Number(v);\n  if (!Number.isFinite(n) || n <= 0) return defaultValue;\n  return Math.floor(n);\n}\n\nexport async function setSettingInt(key: string, value: number): Promise<void> {\n  if (!Number.isFinite(value) || value <= 0) {\n    throw new Error(\"Value must be a positive integer\");\n  }\n  await setSetting(key, String(Math.floor(value)));\n}\n","import { createClient } from \"@supabase/supabase-js\";\n\nconst supabaseUrl = process.env.SUPABASE_URL;\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceRoleKey) {\n\tconsole.warn(\n\t\t\"Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY environment variables\"\n\t);\n}\n\n// Supabase Admin client with Service Role Key for backend operations\n// Only create client if env vars are present to avoid errors\nexport const supabaseAdmin =\n\tsupabaseUrl && supabaseServiceRoleKey\n\t\t? createClient(supabaseUrl, supabaseServiceRoleKey, {\n\t\t\t\tauth: {\n\t\t\t\t\tautoRefreshToken: false,\n\t\t\t\t\tpersistSession: false,\n\t\t\t\t},\n\t\t  })\n\t\t: null;\n\n/**\n * Validates Supabase Storage connection and bucket access\n * @param bucketName Name of the bucket to test\n * @returns Object with connection status and details\n */\nexport async function validateSupabaseStorage(\n\tbucketName: string = \"chapter_pages\"\n): Promise<{\n\tconnected: boolean;\n\tbucketExists: boolean;\n\terror?: string;\n\tdetails?: {\n\t\turl: string;\n\t\tbucket: string;\n\t\tavailableBuckets?: string[];\n\t};\n}> {\n\ttry {\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Starting validation for bucket: ${bucketName}`\n\t\t);\n\n\t\t// Check environment variables\n\t\tif (!supabaseUrl || !supabaseServiceRoleKey) {\n\t\t\tconst error =\n\t\t\t\t\"Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY environment variables\";\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\treturn {\n\t\t\t\tconnected: false,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(`[SUPABASE-VALIDATION] Supabase URL: ${supabaseUrl}`);\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Service Role Key: ${supabaseServiceRoleKey.substring(\n\t\t\t\t0,\n\t\t\t\t10\n\t\t\t)}...`\n\t\t);\n\n\t\t// Check if client was created\n\t\tif (!supabaseAdmin) {\n\t\t\tconst error =\n\t\t\t\t\"Supabase client not initialized (missing environment variables)\";\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\treturn {\n\t\t\t\tconnected: false,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\n\t\t// Test connection by listing buckets\n\t\tconsole.log(`[SUPABASE-VALIDATION] Attempting to list buckets...`);\n\t\tconst { data: buckets, error: listError } =\n\t\t\tawait supabaseAdmin.storage.listBuckets();\n\n\t\tif (listError) {\n\t\t\tconst error = `Failed to connect to Supabase Storage: ${listError.message}`;\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] Error details:`, {\n\t\t\t\tname: listError.name,\n\t\t\t\tmessage: listError.message,\n\t\t\t\tstatus: (listError as any).status,\n\t\t\t\tstatusCode: (listError as any).statusCode,\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tconnected: false,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Successfully connected. Found ${\n\t\t\t\tbuckets?.length || 0\n\t\t\t} buckets`\n\t\t);\n\t\tconst availableBuckets = buckets?.map((b) => b.name) || [];\n\t\tconsole.log(`[SUPABASE-VALIDATION] Available buckets:`, availableBuckets);\n\n\t\t// Check if target bucket exists\n\t\tconst bucketExists =\n\t\t\tbuckets?.some((bucket) => bucket.name === bucketName) || false;\n\n\t\tif (!bucketExists) {\n\t\t\tconst error = `Bucket '${bucketName}' does not exist. Available buckets: ${\n\t\t\t\tavailableBuckets.join(\", \") || \"none\"\n\t\t\t}`;\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\treturn {\n\t\t\t\tconnected: true,\n\t\t\t\tbucketExists: false,\n\t\t\t\terror,\n\t\t\t\tdetails: {\n\t\t\t\t\turl: supabaseUrl,\n\t\t\t\t\tbucket: bucketName,\n\t\t\t\t\tavailableBuckets,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Bucket '${bucketName}' exists. Testing write access...`\n\t\t);\n\n\t\t// Test write access with a small test file\n\t\tconst testPath = `_test_connection_${Date.now()}.txt`;\n\t\tconst testContent = new Blob([\"connection test\"], { type: \"text/plain\" });\n\n\t\tconst { error: uploadError } = await supabaseAdmin.storage\n\t\t\t.from(bucketName)\n\t\t\t.upload(testPath, testContent, {\n\t\t\t\tcontentType: \"text/plain\",\n\t\t\t\tupsert: true,\n\t\t\t});\n\n\t\tif (uploadError) {\n\t\t\tconst error = `Bucket exists but write access failed: ${uploadError.message}`;\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] ${error}`);\n\t\t\tconsole.error(`[SUPABASE-VALIDATION] Upload error details:`, {\n\t\t\t\tname: uploadError.name,\n\t\t\t\tmessage: uploadError.message,\n\t\t\t\tstatus: (uploadError as any).status,\n\t\t\t\tstatusCode: (uploadError as any).statusCode,\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tconnected: true,\n\t\t\t\tbucketExists: true,\n\t\t\t\terror,\n\t\t\t\tdetails: {\n\t\t\t\t\turl: supabaseUrl,\n\t\t\t\t\tbucket: bucketName,\n\t\t\t\t\tavailableBuckets,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[SUPABASE-VALIDATION] Write access successful. Cleaning up test file...`\n\t\t);\n\n\t\t// Clean up test file\n\t\tconst { error: deleteError } = await supabaseAdmin.storage\n\t\t\t.from(bucketName)\n\t\t\t.remove([testPath]);\n\t\tif (deleteError) {\n\t\t\tconsole.warn(\n\t\t\t\t`[SUPABASE-VALIDATION] Failed to delete test file (non-critical):`,\n\t\t\t\tdeleteError.message\n\t\t\t);\n\t\t}\n\n\t\tconsole.log(`[SUPABASE-VALIDATION] âœ… Validation successful!`);\n\t\treturn {\n\t\t\tconnected: true,\n\t\t\tbucketExists: true,\n\t\t\tdetails: {\n\t\t\t\turl: supabaseUrl,\n\t\t\t\tbucket: bucketName,\n\t\t\t\tavailableBuckets,\n\t\t\t},\n\t\t};\n\t} catch (error: any) {\n\t\tconst errorMsg = `Connection validation failed: ${error.message}`;\n\t\tconsole.error(`[SUPABASE-VALIDATION] ${errorMsg}`);\n\t\tconsole.error(`[SUPABASE-VALIDATION] Error stack:`, error.stack);\n\t\treturn {\n\t\t\tconnected: false,\n\t\t\tbucketExists: false,\n\t\t\terror: errorMsg,\n\t\t};\n\t}\n}\n","import { prisma } from \"@/lib/prisma\";\nimport { BattleStatus } from \"@/generated/prisma\";\nimport { supabaseAdmin } from \"./supabase\";\n\nexport class BattleService {\n    /**\n     * Generates a unique 6-digit code\n     */\n    static async generateBattleCode(): Promise<string> {\n        let code = \"\";\n        let exists = true;\n\n        while (exists) {\n            code = Math.floor(100000 + Math.random() * 900000).toString();\n            const existing = await prisma.battle.findUnique({\n                where: { code }\n            });\n            if (!existing) exists = false;\n        }\n        return code;\n    }\n\n    /**\n     * Helper to broadcast events via Supabase\n     */\n    private static async broadcast(battleId: string, event: string, payload: any = {}) {\n        if (!supabaseAdmin) {\n            console.warn('[BATTLE-BROADCAST] supabaseAdmin not available');\n            return;\n        }\n\n        console.log('[BATTLE-BROADCAST] Broadcasting:', { battleId, event, payload });\n\n        const channel = supabaseAdmin.channel(`battle:${battleId}`);\n\n        try {\n            // Use httpSend if available to avoid fallback warning\n            // @ts-ignore\n            if (typeof channel.httpSend === 'function') {\n                // @ts-ignore\n                const result = await channel.httpSend(event, payload);\n                console.log('[BATTLE-BROADCAST] httpSend result:', result);\n            } else {\n                const result = await channel.send({\n                    type: 'broadcast',\n                    event,\n                    payload\n                });\n                console.log('[BATTLE-BROADCAST] send result:', result);\n            }\n        } catch (error) {\n            console.error('[BATTLE-BROADCAST] Error broadcasting:', error);\n        }\n    }\n\n    /**\n     * Creates a new battle\n     */\n    static async createBattle(userId: number, quizId: string) {\n        const code = await this.generateBattleCode();\n\n        const battle = await prisma.battle.create({\n            data: {\n                code,\n                quiz_id: quizId,\n                created_by: userId,\n                status: BattleStatus.WAITING,\n                participants: {\n                    create: {\n                        user_id: userId,\n                        joined_at: new Date(),\n                    }\n                }\n            },\n            include: {\n                quiz: {\n                    select: {\n                        title: true,\n                        questions: {\n                            select: { id: true, points: true }\n                        }\n                    }\n                }\n            }\n        });\n\n        return battle;\n    }\n\n    /**\n     * Joins an existing battle\n     */\n    static async joinBattle(userId: number, code: string) {\n        const battle = await prisma.battle.findUnique({\n            where: { code },\n            include: { participants: true }\n        });\n        console.log(`[BATTLE SERVICE] joinBattle lookup for code \"${code}\" returned:`, battle ? `Battle ID ${battle.id}` : \"null\");\n\n        if (!battle) {\n            throw new Error(\"Battle not found\");\n        }\n\n        if (battle.status !== BattleStatus.WAITING) {\n            throw new Error(\"Battle has already started or ended\");\n        }\n\n        if (battle.participants.some((p: { user_id: number }) => p.user_id === userId)) {\n            return battle; // Already joined\n        }\n\n        // Add participant\n        const updatedBattle = await prisma.battle.update({\n            where: { id: battle.id },\n            data: {\n                participants: {\n                    create: {\n                        user_id: userId,\n                        joined_at: new Date()\n                    }\n                },\n                // If we have 2 participants, we can start the countdown or wait for creator to start\n                // For now, let's keep it manual start or auto-start logic in frontend\n            },\n            include: {\n                participants: {\n                    include: { user: { select: { username: true, id: true } } }\n                },\n                quiz: {\n                    select: {\n                        title: true,\n                        questions: true\n                    }\n                }\n            }\n        });\n\n        // Broadcast player join to notify all participants\n        await this.broadcast(battle.id, 'BATTLE_UPDATE', { type: 'PLAYER_JOINED', userId });\n\n        return updatedBattle;\n    }\n\n    /**\n     * Updates participant progress\n     */\n    static async updateProgress(battleId: string, userId: number, score: number, questionIndex: number, finished: boolean = false) {\n        const participant = await prisma.battleParticipant.update({\n            where: {\n                battle_id_user_id: {\n                    battle_id: battleId,\n                    user_id: userId\n                }\n            },\n            data: {\n                score,\n                current_q_index: questionIndex,\n                finished,\n                last_active: new Date()\n            }\n        });\n\n        // Check if all participants finished\n        if (finished) {\n            const battle = await prisma.battle.findUnique({\n                where: { id: battleId },\n                include: { participants: true }\n            });\n\n            if (battle && battle.participants.every((p: { finished: boolean }) => p.finished)) {\n                await prisma.battle.update({\n                    where: { id: battleId },\n                    data: {\n                        status: BattleStatus.COMPLETED,\n                        ended_at: new Date()\n                    }\n                });\n\n                // Broadcast completion\n                await this.broadcast(battleId, 'BATTLE_UPDATE', { status: 'COMPLETED' });\n            }\n        }\n\n        // Broadcast progress update\n        await this.broadcast(battleId, 'BATTLE_UPDATE', {\n            type: 'PROGRESS',\n            userId,\n            score,\n            finished\n        });\n\n        return participant;\n    }\n\n    /**\n     * Start the battle\n     */\n    static async startBattle(battleId: string, userId: number) {\n        const battle = await prisma.battle.findUnique({\n            where: { id: battleId }\n        });\n\n        if (!battle) throw new Error(\"Battle not found\");\n        if (battle.created_by !== userId) throw new Error(\"Only creator can start battle\");\n\n        const updatedBattle = await prisma.battle.update({\n            where: { id: battleId },\n            data: {\n                status: BattleStatus.IN_PROGRESS,\n                started_at: new Date()\n            }\n        });\n\n        await this.broadcast(battleId, 'BATTLE_UPDATE', { status: 'IN_PROGRESS' });\n\n        return updatedBattle;\n    }\n\n    /**\n     * Create a rematch with the same participants\n     */\n    static async rematchBattle(battleId: string, newQuizId: string, requesterId: number) {\n        // Get original battle with participants\n        const originalBattle = await prisma.battle.findUnique({\n            where: { id: battleId },\n            include: {\n                participants: {\n                    include: {\n                        user: true\n                    }\n                }\n            }\n        });\n\n        if (!originalBattle) throw new Error(\"Original battle not found\");\n        if (originalBattle.participants.length !== 2) {\n            throw new Error(\"Can only rematch 1v1 battles\");\n        }\n\n        // Generate new battle code\n        const code = await this.generateBattleCode();\n\n        // Create new battle with ONLY the requester\n        const newBattle = await prisma.battle.create({\n            data: {\n                code,\n                quiz_id: newQuizId,\n                created_by: requesterId, // The requester becomes the creator\n                status: BattleStatus.WAITING,\n                participants: {\n                    create: {\n                        user_id: requesterId,\n                        score: 0,\n                        current_q_index: 0,\n                        finished: false,\n                        joined_at: new Date()\n                    }\n                }\n            },\n            include: {\n                participants: {\n                    include: {\n                        user: true\n                    }\n                },\n                quiz: {\n                    include: {\n                        questions: true\n                    }\n                }\n            }\n        });\n\n        // Broadcast rematch event to original battle channel\n        // Broadcast rematch event to original battle channel\n        await this.broadcast(battleId, 'REMATCH', {\n            newBattleId: newBattle.id,\n            newBattleCode: newBattle.code,\n            requesterId: requesterId\n        });\n\n        return newBattle;\n    }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n","/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","/**\n * Simple in-memory cache for quiz generation\n * Uses TTL-based expiration to prevent stale data\n */\n\ninterface CacheEntry<T> {\n\tvalue: T;\n\texpiresAt: number;\n}\n\nclass QuizCache {\n\tprivate cache: Map<string, CacheEntry<any>> = new Map();\n\tprivate defaultTTL: number = 60 * 60 * 1000; // 1 hour in milliseconds\n\n\t/**\n\t * Get value from cache\n\t */\n\tget<T>(key: string): T | null {\n\t\tconst entry = this.cache.get(key);\n\n\t\tif (!entry) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if expired\n\t\tif (Date.now() > entry.expiresAt) {\n\t\t\tthis.cache.delete(key);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn entry.value as T;\n\t}\n\n\t/**\n\t * Set value in cache with optional TTL\n\t */\n\tset<T>(key: string, value: T, ttlMs?: number): void {\n\t\tconst ttl = ttlMs ?? this.defaultTTL;\n\t\tconst expiresAt = Date.now() + ttl;\n\n\t\tthis.cache.set(key, {\n\t\t\tvalue,\n\t\t\texpiresAt,\n\t\t});\n\t}\n\n\t/**\n\t * Delete value from cache\n\t */\n\tdelete(key: string): void {\n\t\tthis.cache.delete(key);\n\t}\n\n\t/**\n\t * Clear all cache entries\n\t */\n\tclear(): void {\n\t\tthis.cache.clear();\n\t}\n\n\t/**\n\t * Remove expired entries\n\t */\n\tcleanup(): void {\n\t\tconst now = Date.now();\n\t\tfor (const [key, entry] of this.cache.entries()) {\n\t\t\tif (now > entry.expiresAt) {\n\t\t\t\tthis.cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get cache stats\n\t */\n\tstats() {\n\t\treturn {\n\t\t\tsize: this.cache.size,\n\t\t\tkeys: Array.from(this.cache.keys()),\n\t\t};\n\t}\n}\n\n// Singleton instance\nexport const quizCache = new QuizCache();\n\n// Clear cache on server start for fresh data (only at runtime, not during build)\n// Check if we're NOT in a build phase\nconst isBuildPhase =\n\tprocess.env.NEXT_PHASE === \"phase-production-build\" ||\n\tprocess.env.NEXT_PHASE === \"phase-development-build\";\n\nif (typeof window === \"undefined\" && !isBuildPhase) {\n\tconsole.log(\"[QUIZ-CACHE] Clearing cache on server start\");\n\tquizCache.clear();\n}\n\n// Periodic cleanup (every 10 minutes) - only at runtime, not during build\nif (typeof window === \"undefined\" && !isBuildPhase) {\n\tsetInterval(() => {\n\t\tquizCache.cleanup();\n\t}, 10 * 60 * 1000);\n}\n\n/**\n * Helper to generate cache keys\n */\nexport const CacheKeys = {\n\tchapterContext: (chapterId: number | bigint) =>\n\t\t`chapter:${chapterId}:context`,\n\tsubjectContext: (subjectId: number) => `subject:${subjectId}:context`,\n} as const;\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServer","registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"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","ignoreList":[3,4,6,10,11,12]}