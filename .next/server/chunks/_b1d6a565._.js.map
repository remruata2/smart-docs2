{"version":3,"sources":["../../../src/app/app/practice/actions.ts","../../../src/app/api/battle/rematch/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["\"use server\";\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth-options\";\nimport { prisma } from \"@/lib/prisma\";\nimport { generateQuiz, gradeQuiz, QuizGenerationConfig } from \"@/lib/ai-service-enhanced\";\nimport { QuestionType, QuizStatus } from \"@/generated/prisma\";\nimport { quizCache, CacheKeys } from \"@/lib/quiz-cache\";\n\n/**\n * Get chapter context with caching\n */\n/**\n * Get chapter context with caching\n */\nasync function getChapterContext(chapterId: number): Promise<{ title: string; context: string; board?: string; level?: string }> {\n    const cacheKey = CacheKeys.chapterContext(chapterId);\n    const cached = quizCache.get<{ title: string; context: string; board?: string; level?: string }>(cacheKey);\n\n    if (cached) {\n        console.log(`[QUIZ-CACHE] Hit for chapter ${chapterId}`);\n        return cached;\n    }\n\n    console.log(`[QUIZ-CACHE] Miss for chapter ${chapterId}, fetching from DB`);\n\n    // Fetch chapter metadata with relations\n    const chapter = await prisma.chapter.findUnique({\n        where: { id: BigInt(chapterId) },\n        select: {\n            title: true,\n            subject: {\n                select: {\n                    program: {\n                        select: {\n                            name: true,\n                            board: {\n                                select: { id: true }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n    });\n\n    if (!chapter) throw new Error(\"Chapter not found\");\n\n    // Fetch all chunks for this chapter (this is where the actual content is!)\n    const chunks = await prisma.chapterChunk.findMany({\n        where: { chapter_id: BigInt(chapterId) },\n        select: { content: true, chunk_index: true },\n        orderBy: { chunk_index: 'asc' },\n    });\n\n    console.log(`[QUIZ-CACHE] Found ${chunks.length} chunks for chapter ${chapterId}`);\n\n    // Concatenate all chunk content\n    const context = chunks.map(chunk => chunk.content).join(\"\\n\\n\");\n\n    console.log(`[QUIZ-CACHE] Total context length: ${context.length} characters`);\n\n    const result = {\n        title: chapter.title,\n        context,\n        board: chapter.subject?.program?.board?.id,\n        level: chapter.subject?.program?.name\n    };\n\n    // Cache for 1 hour\n    quizCache.set(cacheKey, result, 60 * 60 * 1000);\n\n    return result;\n}\n\n/**\n * Get subject-level context with random chapter sampling\n */\n/**\n * Get subject-level context with random chapter sampling\n */\nasync function getSubjectContext(subjectId: number): Promise<{ context: string; board?: string; level?: string }> {\n    const cacheKey = CacheKeys.subjectContext(subjectId);\n    const cached = quizCache.get<{ context: string; board?: string; level?: string }>(cacheKey);\n\n    if (cached) {\n        console.log(`[QUIZ-CACHE] Hit for subject ${subjectId}`);\n        return cached;\n    }\n\n    console.log(`[QUIZ-CACHE] Miss for subject ${subjectId}, fetching from DB`);\n\n    // Fetch Subject Metadata\n    const subject = await prisma.subject.findUnique({\n        where: { id: subjectId },\n        select: {\n            program: {\n                select: {\n                    name: true,\n                    board: { select: { id: true } }\n                }\n            }\n        }\n    });\n\n    // Get all chapter IDs, then randomly sample 3\n    const chapterIds = await prisma.chapter.findMany({\n        where: { subject_id: subjectId, is_active: true },\n        select: { id: true },\n    });\n\n    if (chapterIds.length === 0) {\n        throw new Error(\"No chapters found for subject\");\n    }\n\n    // Random sampling\n    const sampleSize = Math.min(3, chapterIds.length);\n    const shuffled = [...chapterIds].sort(() => Math.random() - 0.5);\n    const selectedIds = shuffled.slice(0, sampleSize).map(c => c.id);\n\n    console.log(`[QUIZ-CACHE] Sampling ${sampleSize} chapters for subject context`);\n\n    // Fetch chunks from selected chapters\n    const chunks = await prisma.chapterChunk.findMany({\n        where: { chapter_id: { in: selectedIds } },\n        select: { content: true, chunk_index: true, chapter_id: true },\n        orderBy: [\n            { chapter_id: 'asc' },\n            { chunk_index: 'asc' }\n        ],\n    });\n\n    console.log(`[QUIZ-CACHE] Found ${chunks.length} total chunks from ${sampleSize} chapters`);\n\n    const context = chunks.map(c => c.content).join(\"\\n\\n\");\n\n    const result = {\n        context,\n        board: subject?.program?.board?.id,\n        level: subject?.program?.name\n    };\n\n    // Cache for 30 minutes (less than chapter since it's random)\n    quizCache.set(cacheKey, result, 30 * 60 * 1000);\n\n    return result;\n}\n\n\nexport async function generateQuizAction(\n    subjectId: number,\n    chapterId: number | null,\n    difficulty: \"easy\" | \"medium\" | \"hard\" | \"exam\",\n    questionCount: number,\n    questionTypes: QuestionType[],\n    useAiFallback: boolean = true // New parameter, defaults to true for backward compatibility\n) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        let quizTitle = \"\";\n        let quizDescription = \"\";\n        let finalQuestions: any[] = [];\n\n        // STRATEGY 1: Question Bank (Priority)\n        if (chapterId) {\n            const bigChapterId = BigInt(chapterId);\n\n            // Build query filter\n            const whereClause: any = {\n                chapter_id: bigChapterId,\n                is_active: true,\n            };\n\n            // If difficulty is \"exam\", ONLY fetch exam questions and ignore types\n            if (difficulty === \"exam\") {\n                whereClause.difficulty = \"exam\";\n                // We intentionally ignore questionTypes for exam mode to get all available past paper questions\n            } else {\n                // Normal mode: filter by selected types and difficulty + exam questions\n                whereClause.question_type = { in: questionTypes };\n                // Include both selected difficulty AND exam questions (as they are high quality)\n                whereClause.difficulty = { in: [difficulty, \"exam\"] };\n            }\n\n            let availableQuestions = await prisma.question.findMany({\n                where: whereClause,\n                select: { id: true }\n            });\n\n            // For Exam Mode, we strictly require questions from the bank\n            if (difficulty === \"exam\") {\n                if (availableQuestions.length === 0) {\n                    throw new Error(\"No exam questions found for this chapter. Please upload past papers first.\");\n                }\n                // Use all found questions (up to limit)\n                console.log(`[QUIZ-GEN] Found ${availableQuestions.length} exam questions.`);\n            }\n\n            // FALLBACK STRATEGY: If strict mode (no AI) and not enough questions, try ANY difficulty\n            // This block is only relevant for non-exam difficulties if useAiFallback is false\n            if (difficulty !== \"exam\" && availableQuestions.length < questionCount && !useAiFallback) {\n                console.log(`[QUIZ-GEN] Not enough ${difficulty} questions. Trying ALL difficulties from bank...`);\n                const allDifficultyQuestions = await prisma.question.findMany({\n                    where: {\n                        chapter_id: bigChapterId,\n                        question_type: { in: questionTypes },\n                        is_active: true\n                    },\n                    select: { id: true }\n                });\n                // Add unique ones\n                const existingIds = new Set(availableQuestions.map(q => q.id));\n                for (const q of allDifficultyQuestions) {\n                    if (!existingIds.has(q.id)) {\n                        availableQuestions.push(q);\n                        existingIds.add(q.id);\n                    }\n                }\n            }\n\n            if (availableQuestions.length >= questionCount || (difficulty === \"exam\" && availableQuestions.length > 0)) {\n                console.log(`[QUIZ-GEN] Found ${availableQuestions.length} questions in bank for chapter ${chapterId}. Using Bank.`);\n\n                // Randomly select IDs\n                const shuffled = availableQuestions.sort(() => 0.5 - Math.random());\n                const selectedIds = shuffled.slice(0, questionCount).map(q => q.id);\n\n                // Fetch full question details\n                const questions = await prisma.question.findMany({\n                    where: { id: { in: selectedIds } }\n                });\n\n                finalQuestions = questions.map(q => ({\n                    question_text: q.question_text,\n                    question_type: q.question_type,\n                    options: q.options ? (q.options as any) : undefined,\n                    correct_answer: q.correct_answer,\n                    points: q.points,\n                    explanation: q.explanation || \"Correct answer\",\n                }));\n\n                const chapter = await prisma.chapter.findUnique({\n                    where: { id: bigChapterId },\n                    select: { title: true }\n                });\n\n                quizTitle = `${chapter?.title || 'Chapter'} Quiz`;\n                quizDescription = `A ${difficulty} difficulty quiz on ${chapter?.title}`;\n            } else {\n                console.log(`[QUIZ-GEN] Not enough questions in bank (${availableQuestions.length}/${questionCount}).`);\n\n                if (!useAiFallback) {\n                    throw new Error(`Not enough questions in the Question Bank for this chapter. Found ${availableQuestions.length}, needed ${questionCount}. Please contact admin.`);\n                }\n\n                console.log(`[QUIZ-GEN] Falling back to AI.`);\n            }\n        }\n\n        // STRATEGY 2: AI Generation (Fallback or Subject-level)\n        if (finalQuestions.length === 0) {\n            if (!useAiFallback) {\n                throw new Error(\"AI generation is disabled for this request (Battle Mode). Please select a chapter with existing questions.\");\n            }\n\n            // 1. Fetch Context (with caching)\n            let context = \"\";\n            let topicName = \"\";\n            let boardName = \"\";\n            let levelName = \"\";\n\n            const subject = await prisma.subject.findUnique({\n                where: { id: subjectId },\n                select: { name: true },\n            });\n            if (!subject) throw new Error(\"Subject not found\");\n            const subjectName = subject.name;\n\n            if (chapterId) {\n                const chapterData = await getChapterContext(chapterId);\n                topicName = chapterData.title;\n                context = chapterData.context;\n                boardName = chapterData.board || \"\";\n                levelName = chapterData.level || \"\";\n            } else {\n                topicName = \"General Review\";\n                const subjectData = await getSubjectContext(subjectId);\n                context = subjectData.context;\n                boardName = subjectData.board || \"\";\n                levelName = subjectData.level || \"\";\n            }\n\n            // Early validation\n            if (!context || context.trim().length < 200) {\n                throw new Error(\"Insufficient content available for quiz generation. Please ensure the chapter has content.\");\n            }\n\n            // 2. Generate Quiz via AI\n            const config: QuizGenerationConfig = {\n                subject: subjectName,\n                topic: topicName,\n                difficulty: difficulty as any, // Cast to any since AI service might not strictly type \"exam\" yet\n                questionCount,\n                questionTypes: questionTypes as any, // Cast to match AI service types\n                context,\n            };\n\n            const aiQuiz = await generateQuiz(config, {\n                board: boardName,\n                level: levelName\n            });\n            finalQuestions = aiQuiz.questions;\n            quizTitle = aiQuiz.title;\n            quizDescription = aiQuiz.description;\n\n            // OPTIONAL: We could save these to the Question Bank here for future use!\n            // But for now, we'll keep the existing behavior for AI generation.\n        }\n\n        // 3. Save to DB\n        const quiz = await prisma.quiz.create({\n            data: {\n                user_id: userId,\n                subject_id: subjectId,\n                chapter_id: chapterId ? BigInt(chapterId) : null,\n                title: quizTitle,\n                description: quizDescription,\n                total_points: finalQuestions.reduce((sum, q) => sum + q.points, 0),\n                questions: {\n                    create: finalQuestions.map(q => ({\n                        question_text: q.question_text,\n                        question_type: q.question_type as QuestionType,\n                        options: q.options ? q.options : undefined,\n                        correct_answer: q.correct_answer,\n                        points: q.points,\n                        explanation: q.explanation,\n                    })),\n                },\n            },\n            include: {\n                questions: true,\n            },\n        });\n\n        // Serialize BigInt for client\n        return {\n            ...quiz,\n            chapter_id: quiz.chapter_id?.toString() || null,\n            questions: quiz.questions.map(q => ({\n                ...q,\n                // Hide correct answer and explanation for the client!\n                correct_answer: null,\n                explanation: null,\n            })),\n        };\n\n    } catch (error: any) {\n        console.error(\"Error in generateQuizAction:\", error);\n        throw new Error(error.message || \"Failed to generate quiz\");\n    }\n}\n\nexport async function submitQuizAction(\n    quizId: string,\n    answers: Record<string, any> // questionId -> answer\n) {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        const quiz = await prisma.quiz.findUnique({\n            where: { id: quizId },\n            include: { questions: true },\n        });\n\n        if (!quiz) throw new Error(\"Quiz not found\");\n        if (quiz.user_id !== userId) throw new Error(\"Unauthorized\");\n        if (quiz.status === \"COMPLETED\") {\n            return { success: true, score: quiz.score, totalPoints: quiz.total_points };\n        }\n\n        let totalScore = 0;\n        const updates = [];\n        const questionsToGrade = [];\n\n        for (const question of quiz.questions) {\n            const userAnswer = answers[question.id];\n            let isCorrect = false;\n            let pointsAwarded = 0;\n            let feedback = null;\n\n            if ([\"SHORT_ANSWER\", \"LONG_ANSWER\"].includes(question.question_type)) {\n                // Defer to AI grading\n                questionsToGrade.push({\n                    id: question.id,\n                    question_text: question.question_text,\n                    user_answer: String(userAnswer),\n                    correct_answer: String(question.correct_answer),\n                    type: question.question_type,\n                    max_points: question.points,\n                });\n                continue; // Skip immediate update\n            } else {\n                // Auto-grade objective questions\n                // Handle various answer formats: string vs array vs mixed\n\n                const correctAnswer = question.correct_answer;\n                const userAnswerNormalized = userAnswer;\n                const correctAnswerNormalized = correctAnswer;\n\n                // Normalize to arrays for comparison\n                const userArray = Array.isArray(userAnswerNormalized) ? userAnswerNormalized : [userAnswerNormalized];\n                const correctArray = Array.isArray(correctAnswerNormalized) ? correctAnswerNormalized : [correctAnswerNormalized];\n\n                // Compare as sets (order-independent, handles both single and multi-select)\n                const correctSet = new Set(correctArray.map((a: any) => String(a).trim()));\n                const userSet = new Set(userArray.map((a: any) => String(a).trim()));\n\n                // Check if sets are equal (works for single-select AND multi-select)\n                if (correctSet.size === userSet.size &&\n                    [...correctSet].every(item => userSet.has(item))) {\n                    isCorrect = true;\n                    pointsAwarded = question.points;\n                }\n            }\n\n            totalScore += pointsAwarded;\n            updates.push(\n                prisma.quizQuestion.update({\n                    where: { id: question.id },\n                    data: {\n                        user_answer: userAnswer,\n                        is_correct: isCorrect,\n                    },\n                })\n            );\n        }\n\n        // Run AI grading if needed\n        if (questionsToGrade.length > 0) {\n            const grades = await gradeQuiz(questionsToGrade);\n\n            for (const grade of grades) {\n                // Find original question to get ID and max points\n                // The gradeQuiz returns array in same order or we need to match by text?\n                // Better to pass ID through gradeQuiz or match by text.\n                // gradeQuiz returns { question_text, is_correct, score_percentage, feedback }\n\n                const originalQ = questionsToGrade.find(q => q.question_text === grade.question_text);\n                if (originalQ) {\n                    const points = Math.round((grade.score_percentage / 100) * originalQ.max_points);\n                    totalScore += points;\n\n                    updates.push(\n                        prisma.quizQuestion.update({\n                            where: { id: originalQ.id },\n                            data: {\n                                user_answer: originalQ.user_answer,\n                                is_correct: grade.is_correct,\n                                feedback: grade.feedback,\n                            },\n                        })\n                    );\n                }\n            }\n        }\n\n        // Execute all question updates\n        await prisma.$transaction(updates);\n\n        // Update Quiz status and score\n        const updatedQuiz = await prisma.quiz.update({\n            where: { id: quizId },\n            data: {\n                status: \"COMPLETED\",\n                score: totalScore,\n                completed_at: new Date(),\n            },\n        });\n\n        // Award User Points\n        if (totalScore > 0) {\n            await prisma.userPoints.create({\n                data: {\n                    user_id: userId,\n                    points: totalScore,\n                    reason: \"quiz_completion\",\n                    metadata: { quiz_id: quizId, title: quiz.title },\n                },\n            });\n\n            // Check for streak badges\n            // We need to calculate streak AFTER adding the new point (activity)\n            // But calculateStreak checks DB, so it should be fine.\n            // Wait, calculateStreak checks created_at. The point we just added has now().\n            // So it counts as today's activity.\n\n            // Import dynamically to avoid circular deps if any (though unlikely here)\n            const { calculateStreak, checkAndAwardBadges } = await import(\"@/lib/streak-service\");\n            const currentStreak = await calculateStreak(userId);\n            await checkAndAwardBadges(userId, currentStreak);\n        }\n\n        return { success: true, score: totalScore, totalPoints: quiz.total_points };\n\n    } catch (error) {\n        console.error(\"Error submitting quiz:\", error);\n        throw new Error(\"Failed to submit quiz\");\n    }\n}\n\nexport async function getLeaderboardAction(limit = 10) {\n    try {\n        // Aggregate points by user\n        const leaderboard = await prisma.userPoints.groupBy({\n            by: ['user_id'],\n            _sum: {\n                points: true,\n            },\n            orderBy: {\n                _sum: {\n                    points: 'desc',\n                },\n            },\n            take: limit,\n        });\n\n        // Fetch user details\n        const userIds = leaderboard.map(l => l.user_id);\n        const users = await prisma.user.findMany({\n            where: { id: { in: userIds } },\n            select: { id: true, username: true }, // Add avatar if available\n        });\n\n        // Combine data\n        return leaderboard.map(entry => {\n            const user = users.find(u => u.id === entry.user_id);\n            return {\n                userId: entry.user_id,\n                username: user?.username || \"Unknown User\",\n                points: entry._sum.points || 0,\n            };\n        });\n\n    } catch (error) {\n        console.error(\"Error fetching leaderboard:\", error);\n        throw new Error(\"Failed to fetch leaderboard\");\n    }\n}\n\nexport async function getUserStatsAction() {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        throw new Error(\"Unauthorized\");\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        // Get user's total points\n        const userPointsResult = await prisma.userPoints.aggregate({\n            where: { user_id: userId },\n            _sum: { points: true },\n        });\n        const totalPoints = userPointsResult._sum.points || 0;\n\n        // Get quiz count\n        const quizCount = await prisma.quiz.count({\n            where: { user_id: userId, status: \"COMPLETED\" },\n        });\n\n        // Get average score\n        const quizzes = await prisma.quiz.findMany({\n            where: { user_id: userId, status: \"COMPLETED\" },\n            select: { score: true, total_points: true },\n        });\n        const avgPercentage = quizzes.length > 0\n            ? quizzes.reduce((sum, q) => sum + (q.score / q.total_points) * 100, 0) / quizzes.length\n            : 0;\n\n        // Calculate user's rank\n        const allUserPoints = await prisma.userPoints.groupBy({\n            by: ['user_id'],\n            _sum: { points: true },\n            orderBy: { _sum: { points: 'desc' } },\n        });\n        const userRank = allUserPoints.findIndex(entry => entry.user_id === userId) + 1;\n\n        // Get recent point history\n        const recentPoints = await prisma.userPoints.findMany({\n            where: { user_id: userId },\n            orderBy: { created_at: 'desc' },\n            take: 10,\n            select: {\n                points: true,\n                reason: true,\n                created_at: true,\n                metadata: true,\n            },\n        });\n\n        return {\n            totalPoints,\n            rank: userRank || null,\n            quizCount,\n            avgScore: Math.round(avgPercentage),\n            recentPoints: recentPoints.map(p => ({\n                ...p,\n                created_at: p.created_at.toISOString(),\n            })),\n        };\n    } catch (error) {\n        console.error(\"Error fetching user stats:\", error);\n        throw new Error(\"Failed to fetch user stats\");\n    }\n}\n\nexport async function getQuizHistory() {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.id) {\n        return null;\n    }\n    const userId = parseInt(session.user.id as string);\n\n    try {\n        const quizzes = await prisma.quiz.findMany({\n            where: {\n                user_id: userId,\n                status: QuizStatus.COMPLETED,\n            },\n            include: {\n                subject: { select: { name: true } },\n                chapter: { select: { title: true } },\n            },\n            orderBy: { completed_at: 'desc' },\n        });\n\n        return quizzes;\n    } catch (error) {\n        console.error(\"Error fetching quiz history:\", error);\n        throw new Error(\"Failed to fetch quiz history\");\n    }\n}\n","import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth-options\";\nimport { BattleService } from \"@/lib/battle-service\";\nimport { generateQuizAction } from \"@/app/app/practice/actions\";\nimport { prisma } from \"@/lib/prisma\";\n\nexport async function POST(req: Request) {\n    try {\n        const session = await getServerSession(authOptions);\n        if (!session?.user?.id) {\n            return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n        }\n\n        const userId = parseInt(session.user.id);\n        const { battleId } = await req.json();\n\n        if (!battleId) {\n            return NextResponse.json({ error: \"Battle ID required\" }, { status: 400 });\n        }\n\n        // Get original battle to fetch quiz settings\n        const originalBattle = await prisma.battle.findUnique({\n            where: { id: battleId },\n            include: {\n                quiz: {\n                    select: {\n                        subject_id: true,\n                        chapter_id: true,\n                        questions: {\n                            take: 1,\n                            select: { question_type: true }\n                        }\n                    }\n                },\n                participants: true\n            }\n        });\n\n        if (!originalBattle) {\n            return NextResponse.json({ error: \"Battle not found\" }, { status: 404 });\n        }\n\n        // Verify user is a participant\n        const isParticipant = originalBattle.participants.some(p => p.user_id === userId);\n        if (!isParticipant) {\n            return NextResponse.json({ error: \"Not a participant\" }, { status: 403 });\n        }\n\n        // Get opponent's user ID\n        const opponent = originalBattle.participants.find(p => p.user_id !== userId);\n        if (!opponent) {\n            return NextResponse.json({ error: \"Opponent not found\" }, { status: 404 });\n        }\n\n        // CHECK: Has the opponent already created a rematch?\n        // Look for recent battles (created in last 5 minutes) where:\n        // 1. Created by the opponent\n        // 2. Status is WAITING\n        // 3. Has only 1 participant (the opponent)\n        // 4. Uses the same quiz settings\n        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n\n        const existingRematch = await prisma.battle.findFirst({\n            where: {\n                created_by: opponent.user_id,\n                status: \"WAITING\",\n                created_at: {\n                    gte: fiveMinutesAgo\n                },\n                quiz: {\n                    subject_id: originalBattle.quiz.subject_id,\n                    chapter_id: originalBattle.quiz.chapter_id\n                },\n                participants: {\n                    every: {\n                        user_id: opponent.user_id\n                    }\n                }\n            },\n            include: {\n                quiz: {\n                    include: {\n                        questions: true\n                    }\n                },\n                participants: {\n                    include: {\n                        user: true\n                    }\n                }\n            },\n            orderBy: {\n                created_at: 'desc'\n            }\n        });\n\n        // If opponent already created a rematch, JOIN it automatically\n        if (existingRematch && existingRematch.participants.length === 1) {\n            console.log(`[REMATCH] Auto-joining opponent's battle: ${existingRematch.id}`);\n\n            // Join the existing battle\n            await BattleService.joinBattle(userId, existingRematch.code);\n\n            // Fetch the complete battle data with quiz included\n            const joinedBattle = await prisma.battle.findUnique({\n                where: { id: existingRematch.id },\n                include: {\n                    participants: {\n                        include: {\n                            user: true\n                        }\n                    },\n                    quiz: {\n                        include: {\n                            questions: true\n                        }\n                    }\n                }\n            });\n\n            if (!joinedBattle) {\n                return NextResponse.json({ error: \"Failed to fetch joined battle\" }, { status: 500 });\n            }\n\n            // Serialize BigInt fields\n            const sanitizedBattle = {\n                ...joinedBattle,\n                quiz: {\n                    ...joinedBattle.quiz,\n                    chapter_id: joinedBattle.quiz.chapter_id?.toString() || null,\n                    questions: joinedBattle.quiz.questions.map((q: any) => ({\n                        ...q,\n                        quiz_id: q.quiz_id?.toString() || null\n                    }))\n                }\n            };\n\n            return NextResponse.json({\n                success: true,\n                battleId: joinedBattle.id,\n                battle: sanitizedBattle,\n                autoJoined: true  // Flag to indicate this was an auto-join\n            });\n        }\n\n        // Otherwise, create a new rematch battle as usual\n        console.log(`[REMATCH] Creating new battle for user ${userId}`);\n\n        // Generate new quiz with same settings (now using strict bank mode for battles)\n        const newQuiz = await generateQuizAction(\n            originalBattle.quiz.subject_id,\n            originalBattle.quiz.chapter_id ? Number(originalBattle.quiz.chapter_id) : null,\n            \"medium\",\n            5,\n            [\"MCQ\"],\n            false  // Disable AI fallback - use only stored questions for battles\n        );\n\n        // Create rematch battle\n        const newBattle = await BattleService.rematchBattle(battleId, newQuiz.id, userId);\n\n        // Serialize BigInt fields\n        const sanitizedBattle = {\n            ...newBattle,\n            quiz: {\n                ...newBattle.quiz,\n                chapter_id: newBattle.quiz.chapter_id?.toString() || null,\n                questions: newBattle.quiz.questions.map((q: any) => ({\n                    ...q,\n                    quiz_id: q.quiz_id?.toString() || null\n                }))\n            }\n        };\n\n        return NextResponse.json({\n            success: true,\n            battleId: newBattle.id,\n            battle: sanitizedBattle\n        });\n\n    } catch (error: any) {\n        console.error(\"[BATTLE REMATCH] Error:\", error);\n        return NextResponse.json(\n            { error: error.message || \"Failed to create rematch\" },\n            { status: 500 }\n        );\n    }\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setReferenceManifestsSingleton","createServerModuleMap","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[2]}